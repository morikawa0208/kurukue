<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lane Battle 3x3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anta&family=Noto+Sans+JP:wght@400;700;900&display=swap');

        body {
            background-color: #020617;
            color: #f1f5f9;
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        body.h-screen {
            height: 100svh;
            min-height: 100svh;
        }

        body.p-4 {
            padding: clamp(8px, 2vw, 16px);
        }

        .anta { font-family: 'Anta', sans-serif; }

        .enemy-grid-shell {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .enemy-row-labels {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            font-size: 10px;
            color: #94a3b8;
            font-weight: 700;
            letter-spacing: 0.08em;
        }

        .enemy-row-labels span {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px;
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid #1f2937;
        }

        .enemy-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.85);
            border: 2px solid #1e293b;
        }

        .enemy-cell {
            position: relative;
            min-height: clamp(62px, 12vh, 86px);
            border-radius: 10px;
            border: 1px solid #1f2937;
            background: rgba(15, 23, 42, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .enemy-cell.is-empty {
            border-style: dashed;
            color: #475569;
            font-size: 10px;
        }

        .enemy-card {
            width: 100%;
            height: 100%;
            padding: 6px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(127, 29, 29, 0.6));
            border-radius: 8px;
            border: 1px solid rgba(248, 113, 113, 0.6);
        }

        .enemy-name {
            font-size: 10px;
            font-weight: 700;
            color: #fecaca;
        }

        .enemy-hp {
            font-size: 12px;
            font-weight: 900;
            color: #f87171;
        }

        .enemy-hp-bar {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(30, 41, 59, 0.8);
            overflow: hidden;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f87171, #dc2626);
            transition: width 0.2s ease;
        }

        .attack-btn {
            min-width: clamp(72px, 20vw, 96px);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 900;
            font-size: clamp(12px, 3vw, 14px);
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            color: #e0f2fe;
            box-shadow: 0 4px 0 rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .attack-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .lane-hint {
            font-size: 10px;
            color: #94a3b8;
            text-align: center;
        }

        #logs {
            max-height: 24vh;
            overflow: hidden;
            font-size: clamp(8px, 1.6vw, 11px);
        }

        .pop-up {
            position: absolute;
            animation: popUp 0.8s ease-out forwards;
            pointer-events: none;
            font-weight: 900;
            z-index: 50;
        }

        @keyframes popUp {
            0% { transform: translateY(0); opacity: 0; }
            20% { opacity: 1; transform: translateY(-16px); }
            100% { transform: translateY(-60px); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col h-screen p-4">
    <div class="mb-4">
        <div class="flex justify-between items-end mb-2 px-1">
            <span class="text-xs text-red-400 font-bold anta">ENEMY LANE 3x3</span>
            <span id="enemy-count" class="text-sm font-bold anta">9 / 9</span>
        </div>
        <div class="enemy-grid-shell">
            <div class="enemy-row-labels">
                <span>後列</span>
                <span>中列</span>
                <span class="text-cyan-300">前列</span>
            </div>
            <div id="enemy-grid" class="enemy-grid"></div>
        </div>
    </div>

    <div class="mb-4">
        <div class="text-[10px] text-slate-500 mb-2 text-center font-bold">攻撃対象の列を選択</div>
        <div class="flex items-center justify-center gap-3">
            <button class="attack-btn" data-col="0" type="button">左列 攻撃</button>
            <button class="attack-btn" data-col="1" type="button">中央 攻撃</button>
            <button class="attack-btn" data-col="2" type="button">右列 攻撃</button>
        </div>
    </div>

    <div class="mb-4">
        <div class="flex justify-between items-end mb-1 px-2">
            <div class="flex flex-col">
                <span class="text-[10px] text-green-400 font-bold">PLAYER HP</span>
                <span id="player-hp-txt" class="text-2xl font-black anta">100 / 100</span>
            </div>
            <div class="text-right">
                <span class="text-[10px] text-slate-400 font-bold">ENEMY ATTACK</span>
                <div class="w-24 bg-slate-800 h-1.5 rounded-full overflow-hidden mt-1">
                    <div id="enemy-attack-bar" class="bg-red-500 h-full w-full transition-all"></div>
                </div>
            </div>
        </div>
        <div class="w-full bg-slate-800 h-2.5 rounded-full overflow-hidden">
            <div id="player-hp-bar" class="bg-green-500 h-full w-full transition-all"></div>
        </div>
    </div>

    <div id="logs" class="flex-grow flex flex-col justify-end text-[10px] gap-1 opacity-60 font-mono mb-2">
        <div>-- BATTLE START --</div>
    </div>

    <div class="lane-hint">下が最前列。前列が倒れると後ろが前にスライドします。</div>

    <script>
        const enemyRows = 3;
        const enemyCols = 3;

        const state = {
            player: { hp: 100, maxHp: 100 },
            columns: [],
            isGameOver: false,
            lastEnemyAttack: 0,
            enemyAttackInterval: 3200
        };

        const enemyGrid = document.getElementById('enemy-grid');
        const enemyCountText = document.getElementById('enemy-count');
        const playerHpText = document.getElementById('player-hp-txt');
        const playerHpBar = document.getElementById('player-hp-bar');
        const enemyAttackBar = document.getElementById('enemy-attack-bar');
        const logs = document.getElementById('logs');

        function createEnemy(row, col) {
            const base = 80 + row * 30 + col * 10;
            return {
                id: `${row}-${col}-${Math.random()}`,
                name: `E${row + 1}-${col + 1}`,
                hp: base,
                maxHp: base
            };
        }

        function initEnemies() {
            state.columns = Array.from({ length: enemyCols }, (_, col) => (
                Array.from({ length: enemyRows }, (_, row) => createEnemy(row, col))
            ));
            render();
        }

        function addLog(message) {
            const div = document.createElement('div');
            div.innerText = `> ${message}`;
            logs.appendChild(div);
            if (logs.childNodes.length > 6) {
                logs.removeChild(logs.firstChild);
            }
        }

        function popText(text, color, x, y) {
            const el = document.createElement('div');
            el.className = `pop-up ${color} text-xl`;
            el.innerText = text;
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function countEnemies() {
            return state.columns.reduce((sum, column) => (
                sum + column.filter(Boolean).length
            ), 0);
        }

        function renderEnemies() {
            enemyGrid.innerHTML = '';
            for (let row = 0; row < enemyRows; row++) {
                for (let col = 0; col < enemyCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'enemy-cell';
                    const enemy = state.columns[col][row];
                    if (!enemy) {
                        cell.classList.add('is-empty');
                        cell.innerHTML = '<span>--</span>';
                    } else {
                        const card = document.createElement('div');
                        card.className = 'enemy-card';
                        card.innerHTML = `
                            <div>
                                <div class="enemy-name">${enemy.name}</div>
                                <div class="enemy-hp">${enemy.hp} / ${enemy.maxHp}</div>
                            </div>
                            <div class="enemy-hp-bar">
                                <div class="enemy-hp-fill" style="width:${(enemy.hp / enemy.maxHp) * 100}%"></div>
                            </div>
                        `;
                        cell.appendChild(card);
                    }
                    enemyGrid.appendChild(cell);
                }
            }
        }

        function render() {
            renderEnemies();
            updateUI();
        }

        function updateUI() {
            const remaining = countEnemies();
            enemyCountText.innerText = `${remaining} / ${enemyRows * enemyCols}`;
            playerHpText.innerText = `${state.player.hp} / ${state.player.maxHp}`;
            playerHpBar.style.width = `${(state.player.hp / state.player.maxHp) * 100}%`;
        }

        function shiftColumn(colIndex) {
            const column = state.columns[colIndex];
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) continue;
                let above = row - 1;
                while (above >= 0 && !column[above]) {
                    above -= 1;
                }
                if (above >= 0) {
                    column[row] = column[above];
                    column[above] = null;
                }
            }
        }

        function getFrontEnemyRow(column) {
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) return row;
            }
            return null;
        }

        function attackColumn(colIndex) {
            if (state.isGameOver) return;
            const column = state.columns[colIndex];
            const targetRow = getFrontEnemyRow(column);
            if (targetRow === null) {
                addLog(`列${colIndex + 1}に敵がいません。`);
                return;
            }
            const enemy = column[targetRow];
            const damage = 35;
            enemy.hp = Math.max(0, enemy.hp - damage);
            popText(`-${damage}`, 'text-red-400', 50, 30);
            addLog(`列${colIndex + 1}の前列に攻撃！ ${damage}ダメージ`);
            if (enemy.hp === 0) {
                addLog(`${enemy.name}を撃破！`);
                column[targetRow] = null;
                shiftColumn(colIndex);
            }
            if (countEnemies() === 0) {
                state.isGameOver = true;
                addLog('VICTORY!');
            }
            render();
        }

        function enemyAction() {
            if (state.isGameOver) return;
            const frontCount = state.columns.reduce((sum, column) => (
                sum + (column[enemyRows - 1] ? 1 : 0)
            ), 0);
            const damage = 6 + frontCount * 3;
            state.player.hp = Math.max(0, state.player.hp - damage);
            addLog(`敵の反撃！ ${damage}ダメージ`);
            if (state.player.hp === 0) {
                state.isGameOver = true;
                addLog('DEFEAT...');
            }
            render();
        }

        function updateEnemyAttackBar(progress) {
            enemyAttackBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        }

        function gameLoop(time) {
            if (state.isGameOver) return;
            const elapsed = time - state.lastEnemyAttack;
            const ratio = (elapsed / state.enemyAttackInterval) * 100;
            updateEnemyAttackBar(ratio);
            if (elapsed > state.enemyAttackInterval) {
                enemyAction();
                state.lastEnemyAttack = time;
                updateEnemyAttackBar(0);
            }
            requestAnimationFrame(gameLoop);
        }

        document.querySelectorAll('.attack-btn').forEach((button) => {
            button.addEventListener('click', () => {
                attackColumn(Number(button.dataset.col));
            });
        });

        initEnemies();
        requestAnimationFrame((time) => {
            state.lastEnemyAttack = time;
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
