<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>縦持ちハクスラ試作</title>
    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%23111827'/%3E%3Ctext x='50%25' y='58%25' text-anchor='middle' font-size='44'%3E⚔️%3C/text%3E%3C/svg%3E"
    />
    <style>
      :root {
        --bg: #0b0e14;
        --panel: #111827;
        --accent: #34d399;
        --accent-2: #60a5fa;
        --text: #e5e7eb;
        --muted: #9ca3af;
      }

      html {
        touch-action: manipulation;
      }

      * {
        box-sizing: border-box;
      }

      body {
        background:
          radial-gradient(
            circle at 20% 20%,
            rgba(52, 211, 153, 0.08),
            transparent 25%
          ),
          radial-gradient(
            circle at 80% 10%,
            rgba(96, 165, 250, 0.08),
            transparent 22%
          ),
          var(--bg);
        color: var(--text);
        font-family:
          "Segoe UI",
          "Hiragino Sans",
          system-ui,
          -apple-system,
          sans-serif;
        margin: 0;
        display: flex;
        justify-content: center;
        min-height: 100dvh;
        padding: 6px;
        overscroll-behavior-y: contain;
        overflow: hidden;
      }

      .phone {
        background: rgba(17, 24, 39, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        width: min(460px, 100%);
        height: min(860px, calc(100dvh - 12px));
        max-height: calc(100dvh - 12px);
        display: grid;
        grid-template-rows: auto auto auto auto 1fr;
        gap: 6px;
        padding: 8px;
        padding-bottom: 12px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        overflow-y: auto;
        overscroll-behavior-y: contain;
        position: relative;
      }

      .level-up-toast {
        position: fixed;
        top: 15px;
        left: 50%;
        transform: translate(-50%, -10px);
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 14px;
        border-radius: 12px;
        background: linear-gradient(
          120deg,
          rgba(52, 211, 153, 0.14),
          rgba(96, 165, 250, 0.12)
        );
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow:
          0 12px 30px rgba(0, 0, 0, 0.35),
          0 0 0 1px rgba(52, 211, 153, 0.08);
        color: var(--text);
        pointer-events: none;
        opacity: 0;
        gap: 8px;
        z-index: 10;
      }

      .level-up-toast.show {
        animation: levelUpToast 1.9s ease-out forwards;
      }

      .level-up-toast .toast-glow {
        width: 8px;
        height: 40px;
        border-radius: 8px;
        background: linear-gradient(
          180deg,
          rgba(52, 211, 153, 0.8),
          rgba(96, 165, 250, 0.7)
        );
        filter: blur(1px) drop-shadow(0 0 8px rgba(52, 211, 153, 0.65));
        opacity: 0.9;
        animation: toastGlow 1.6s ease-in-out infinite;
      }

      .level-up-toast .toast-body {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .level-up-toast .toast-icon {
        font-size: 18px;
        filter: drop-shadow(0 2px 6px rgba(52, 211, 153, 0.6));
      }

      .level-up-toast .toast-text {
        display: grid;
        gap: 2px;
        line-height: 1.25;
      }

      .level-up-toast .toast-label {
        font-weight: 800;
        letter-spacing: 0.06em;
        font-size: 11px;
        color: #a5f3fc;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
      }

      .level-up-toast .toast-level {
        font-weight: 700;
        font-size: 14px;
        color: #fef3c7;
        text-shadow: 0 1px 6px rgba(0, 0, 0, 0.45);
      }

      .level-up-toast .toast-trail {
        position: absolute;
        inset: 4px;
        border-radius: 12px;
        background:
          radial-gradient(
            circle at 20% 50%,
            rgba(52, 211, 153, 0.35),
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 50%,
            rgba(96, 165, 250, 0.35),
            transparent 50%
          );
        filter: blur(22px);
        opacity: 0;
        animation: toastTrail 1.4s ease-out forwards;
        pointer-events: none;
      }

      @keyframes levelUpToast {
        0% {
          opacity: 0;
          transform: translate(-50%, -6px) scale(0.96);
        }
        12% {
          opacity: 1;
          transform: translate(-50%, -2px) scale(1.04);
        }
        70% {
          opacity: 0.98;
          transform: translate(-50%, -8px) scale(1.02);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -22px) scale(1.02);
        }
      }

      @keyframes toastGlow {
        0%,
        100% {
          opacity: 0.75;
          transform: translateY(0);
        }
        50% {
          opacity: 1;
          transform: translateY(-4px);
        }
      }

      @keyframes toastTrail {
        0% {
          opacity: 0.6;
          transform: scale(0.9);
        }
        60% {
          opacity: 0.85;
          transform: scale(1.02);
        }
        100% {
          opacity: 0;
          transform: scale(1.08);
        }
      }

      .drop-toast-stack {
        position: fixed;
        top: 15px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        width: 100%;
        pointer-events: none;
        z-index: 30;
      }

      .drop-toast {
        --drop-primary: #fbbf24;
        --drop-secondary: #fef08a;
        --drop-highlight: #fcd34d;
        --drop-primary-rgb: 251, 191, 36;
        --drop-secondary-rgb: 254, 240, 138;
        --drop-highlight-rgb: 252, 211, 77;
      
        opacity: 0;
        transform: translateY(-10px) scale(0.98);
        transition: opacity 0.2s ease;
      
        /* ★ここが重要：幅を「中身基準」にする */
        width: fit-content;
        max-width: min(92vw, 560px);
      }


      .drop-toast.rare {
        --drop-primary: #f59e0b;
        --drop-secondary: #fde68a;
        --drop-highlight: #fcd34d;
        --drop-primary-rgb: 245, 158, 11;
        --drop-secondary-rgb: 253, 230, 138;
        --drop-highlight-rgb: 252, 211, 77;
      }

      .drop-toast.legendary {
        --drop-primary: #b45309;
        --drop-secondary: #f97316;
        --drop-highlight: #fcd34d;
        --drop-primary-rgb: 180, 83, 9;
        --drop-secondary-rgb: 249, 115, 22;
        --drop-highlight-rgb: 252, 211, 77;
      }

      .drop-toast.simple {
        --drop-primary: var(--panel);
        --drop-secondary: var(--panel);
        --drop-highlight: var(--text);
        --drop-primary-rgb: 17, 24, 39;
        --drop-secondary-rgb: 17, 24, 39;
        --drop-highlight-rgb: 229, 231, 235;
        min-width: auto;
      }

      .drop-toast.show {
        animation: dropToastEntrance 2.6s ease-out forwards;
      }

      .drop-toast .drop-toast-core {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px 12px 14px;
        border-radius: 16px;
        background:
          linear-gradient(
            120deg,
            rgba(var(--drop-primary-rgb), 0.28),
            rgba(var(--drop-secondary-rgb), 0.28)
          ),
          linear-gradient(145deg, rgba(11, 14, 20, 0.96), rgba(17, 24, 39, 0.9));
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow:
          0 18px 45px rgba(0, 0, 0, 0.45),
          0 0 38px rgba(var(--drop-highlight-rgb), 0.35);
        overflow: hidden;
        isolation: isolate;
        /* ★ここが重要：100%で伸ばさない */
        width: fit-content;
        max-width: 100%;
        justify-content: flex-start;   /* center → flex-start */
      }

      .drop-toast.simple .drop-toast-core {
        gap: 8px;
        padding: 10px 12px;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: none;
      }

      .drop-toast .drop-toast-core::before {
        content: "";
        position: absolute;
        inset: -50% -30%;
        background: conic-gradient(
          from 160deg,
          rgba(var(--drop-highlight-rgb), 0.08),
          rgba(var(--drop-highlight-rgb), 0.36),
          rgba(var(--drop-highlight-rgb), 0.08)
        );
        filter: blur(18px);
        animation: dropToastRays 2.8s linear infinite;
        z-index: 0;
      }

      .drop-toast .drop-toast-core::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          110deg,
          rgba(var(--drop-highlight-rgb), 0.14),
          transparent 58%
        );
        opacity: 0;
        animation: dropToastSweep 2s ease-out forwards;
        z-index: 1;
      }

      .drop-toast.simple .drop-toast-core::before,
      .drop-toast.simple .drop-toast-core::after {
        display: none;
      }

      .drop-toast .drop-toast-glow {
        position: absolute;
        inset: -10px;
        background:
          radial-gradient(
            circle at 20% 20%,
            rgba(var(--drop-primary-rgb), 0.3),
            transparent 40%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(var(--drop-secondary-rgb), 0.3),
            transparent 42%
          ),
          radial-gradient(
            circle at 50% 40%,
            rgba(var(--drop-highlight-rgb), 0.32),
            transparent 38%
          );
        filter: blur(16px);
        opacity: 0;
        animation: dropToastGlow 2.4s ease-out forwards;
        z-index: 0;
      }

      .drop-toast.simple .drop-toast-glow {
        display: none;
      }

      .drop-toast .drop-toast-body {
        position: relative;
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: center;
        justify-items: center;
        gap: 12px;
        z-index: 2;
        width: 100%;
        min-width: 0;
      }
      .drop-toast .drop-text {
        display: grid;
        gap: 6px;
        line-height: 1.25;
        min-width: 0;
        max-width: 100%;
        width: 100%;
        text-align: center;
      }

      .drop-toast.simple .drop-text {
        min-width: 0;
        max-width: 100%;
      }

      .drop-toast .drop-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 999px;
        background: linear-gradient(
          120deg,
          var(--drop-primary),
          var(--drop-secondary)
        );
        color: #0b0e14;
        font-weight: 900;
        letter-spacing: 0.08em;
        font-size: 12px;
        text-transform: uppercase;
        box-shadow:
          0 8px 24px rgba(0, 0, 0, 0.35),
          0 0 18px rgba(var(--drop-highlight-rgb), 0.55);
        border: 1px solid rgba(255, 255, 255, 0.4);
      }

      .drop-toast.simple .drop-pill {
        display: none;
      }

      .drop-toast .drop-item-name {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: clamp(13px, 3vw, 17px);
        font-weight: 800;
        letter-spacing: 0.03em;
        color: var(--drop-highlight);
        background: linear-gradient(
          145deg,
          rgba(var(--drop-primary-rgb), 0.18),
          rgba(var(--drop-secondary-rgb), 0.22)
        );
        border: 1px solid rgba(var(--drop-highlight-rgb), 0.55);
        box-shadow:
          0 12px 28px rgba(0, 0, 0, 0.35),
          inset 0 0 22px rgba(var(--drop-highlight-rgb), 0.3);
        text-shadow:
          0 3px 12px rgba(0, 0, 0, 0.4),
          0 0 12px rgba(var(--drop-highlight-rgb), 0.7);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        /* ★ここが重要：100%で伸ばさない */
        width: auto;
        max-width: min(78vw, 480px); /* 長い名前は省略 */
      }

      .drop-toast.simple .drop-item-name {
        padding: 0;
        background: none;
        border: none;
        box-shadow: none;
        text-shadow: none;
        color: var(--text);
        font-weight: 700;
      }

      .drop-toast .drop-sparkles {
        position: absolute;
        inset: -12px;
        background:
          radial-gradient(
            circle at 30% 20%,
            rgba(var(--drop-primary-rgb), 0.35),
            transparent 36%
          ),
          radial-gradient(
            circle at 70% 30%,
            rgba(var(--drop-secondary-rgb), 0.32),
            transparent 36%
          ),
          radial-gradient(
            circle at 50% 70%,
            rgba(var(--drop-highlight-rgb), 0.38),
            transparent 40%
          );
        mix-blend-mode: screen;
        opacity: 0;
        animation: dropToastSparkle 2.6s ease-out forwards;
        z-index: 1;
      }

      .drop-toast.simple .drop-sparkles {
        display: none;
      }

      .drop-toast .drop-ribbon {
        position: absolute;
        inset: -30%;
        background: conic-gradient(
          from 90deg,
          rgba(var(--drop-primary-rgb), 0.4),
          rgba(var(--drop-secondary-rgb), 0.08),
          rgba(var(--drop-highlight-rgb), 0.35),
          rgba(var(--drop-primary-rgb), 0.12)
        );
        filter: blur(22px);
        opacity: 0.85;
        transform: rotate(12deg);
        animation: dropToastRibbon 3s ease-in-out infinite;
        z-index: 0;
      }

      .drop-toast.simple .drop-ribbon {
        display: none;
      }

      @keyframes dropToastEntrance {
        0% {
          opacity: 0;
          transform: translateY(-6px) scale(0.9);
        }
        18% {
          opacity: 1;
          transform: translateY(-1px) scale(1.04);
        }
        60% {
          opacity: 1;
          transform: translateY(-6px) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(-18px) scale(1);
        }
      }

      @keyframes dropToastGlow {
        0% {
          opacity: 0.4;
          transform: scale(0.92);
        }
        30% {
          opacity: 0.9;
          transform: scale(1.03);
        }
        70% {
          opacity: 0.85;
          transform: scale(1.02);
        }
        100% {
          opacity: 0;
          transform: scale(1.08);
        }
      }

      @keyframes dropToastRays {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(1turn);
        }
      }

      @keyframes dropToastSweep {
        0% {
          opacity: 0;
          transform: translateX(-28%);
        }
        35% {
          opacity: 0.6;
          transform: translateX(6%);
        }
        100% {
          opacity: 0;
          transform: translateX(26%);
        }
      }

      @keyframes dropToastPop {
        0% {
          opacity: 0;
          transform: scale(0.6) rotate(-10deg);
        }
        35% {
          opacity: 1;
          transform: scale(1.08) rotate(4deg);
        }
        70% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: scale(1) translateY(-6px);
        }
      }

      @keyframes dropToastSparkle {
        0% {
          opacity: 0;
          filter: blur(14px);
        }
        25% {
          opacity: 0.9;
          filter: blur(10px);
        }
        60% {
          opacity: 0.6;
          filter: blur(12px);
        }
        100% {
          opacity: 0;
          filter: blur(16px);
        }
      }

      @keyframes dropToastRibbon {
        0%,
        100% {
          transform: rotate(12deg) scale(0.96);
          opacity: 0.9;
        }
        50% {
          transform: rotate(0deg) scale(1.02);
          opacity: 0.75;
        }
      }

      .player-down-overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        gap: 10px;
        font-weight: 900;
        font-size: 32px;
        color: rgba(248, 113, 113, 0.9);
        background: radial-gradient(
          circle,
          rgba(15, 23, 42, 0.55),
          rgba(15, 23, 42, 0.92)
        );
        text-shadow: 0 3px 16px rgba(0, 0, 0, 0.6);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: scale(1.02);
        transition:
          opacity 0.3s ease,
          transform 0.3s ease,
          visibility 0.3s ease;
        z-index: 12;
        width: min(460px, 100%);
        height: min(860px, calc(100dvh - 12px));
        max-height: calc(100dvh - 12px);
        margin: auto;
        padding: 12px;
        text-align: center;
        user-select: none;
      }

      .player-down-overlay.show {
        opacity: 1;
        visibility: visible;
        transform: scale(1);
      }

      .player-down-overlay.interactive {
        pointer-events: auto;
        cursor: pointer;
      }

      .player-down-overlay .player-down-hint {
        font-size: 14px;
        color: #f8fafc;
        background: rgba(248, 113, 113, 0.12);
        border: 1px solid rgba(248, 113, 113, 0.26);
        padding: 6px 10px;
        border-radius: 999px;
        letter-spacing: 0.04em;
        text-shadow: none;
        opacity: 0;
        transform: translateY(4px);
        transition:
          opacity 0.2s ease,
          transform 0.2s ease;
      }

      .player-down-overlay.interactive .player-down-hint {
        opacity: 0.9;
        transform: translateY(0);
      }

      .card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
        padding: 4px;
      }

      .subtle {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 4px;
      }

      .bars {
        display: grid;
        gap: 6px;
      }

      .bar {
        position: relative;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 999px;
        height: 22px;
        overflow: visible;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      @keyframes barPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(252, 165, 165, 0.6);
        }
        100% {
          box-shadow: 0 0 0 12px rgba(252, 165, 165, 0);
        }
      }

      .gold-pill {
        margin-left: auto;
        background: rgba(234, 179, 8, 0.14);
        border: 1px solid rgba(234, 179, 8, 0.28);
        color: #fef3c7;
        font-weight: 800;
        letter-spacing: 0.02em;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }

      .bar span {
        position: absolute;
        inset: 0;
        width: 50%;
        border-radius: 999px;
        transition: width 0.28s ease;
        z-index: 1;
      }

      .bar.flash {
        animation: barPulse 0.5s ease;
      }

      .bar .label {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-size: 12px;
        color: #f8fafc;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        pointer-events: none;
        z-index: 3;
      }

      .bar .hp {
        background: #ef4444;
      }

      .bar .damage-popup {
        top: -10px;
      }

      .bar .barrier {
        background: linear-gradient(120deg, rgba(96, 165, 250, 0.65), rgba(125, 211, 252, 0.45));
        mix-blend-mode: screen;
        opacity: 0.65;
        z-index: 2;
      }

      .bar .mp {
        background: #3b82f6;
      }

      .bar .exp {
        background: #facc15;
      }

      #log {
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 10px;
        font-size: 12px;
        line-height: 1.5;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        height: clamp(180px, 40vh, 320px);
        max-height: clamp(180px, 40vh, 320px);
        resize: none;
      }

      #log .entry {
        opacity: 0.95;
        padding: 4px 6px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
        animation: logEnter 0.26s ease;
      }

      #log .entry.info {
        color: #e5e7eb;
      }

      #log .entry.player {
        color: #93c5fd;
      }

      #log .entry.enemy {
        color: #fca5a5;
      }

      #log .entry.good {
        color: #6ee7b7;
      }

      #log .entry.warning {
        color: #fcd34d;
      }

      #log .entry.danger {
        color: #fb7185;
      }

      @keyframes logEnter {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 4px;
        margin-bottom: 4px;
      }

      .turn-order-list {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
        min-height: 42px;
      }

      .turn-order-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 2px;
      }

      .turn-order-bar .turn-order-list {
        flex: 1;
      }

      .turn-order-hint {
        color: var(--muted);
        font-size: 12px;
        white-space: nowrap;
      }

      .turn-badge {
        min-width: 24px;
        height: 24px;
        border-radius: 999px;
        display: grid;
        place-items: center;
        font-weight: 800;
        letter-spacing: 0.03em;
        background: linear-gradient(
          140deg,
          rgba(52, 211, 153, 0.18),
          rgba(96, 165, 250, 0.16)
        );
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        animation: orderPop 0.32s ease;
      }

      .turn-badge.steady {
        animation: none;
      }

      .turn-badge.player {
        color: #a5f3fc;
        text-shadow: 0 1px 4px rgba(96, 165, 250, 0.4);
      }

      .turn-badge.enemy {
        color: #fef3c7;
        background: linear-gradient(
          140deg,
          rgba(251, 191, 36, 0.2),
          rgba(248, 113, 113, 0.18)
        );
        border-color: rgba(251, 191, 36, 0.3);
      }

      .turn-badge.next {
        box-shadow:
          0 0 0 2px rgba(96, 165, 250, 0.25),
          0 10px 24px rgba(0, 0, 0, 0.3);
        transform: translateY(-1px);
      }

      .turn-badge.acting {
        animation: orderPulse 0.9s ease-in-out infinite;
      }

      .turn-badge.acted {
        opacity: 0.72;
        filter: saturate(0.9);
      }

      .turn-order-list.turn-order-refresh {
        animation: orderShuffle 0.32s ease;
      }

      .turn-order-empty {
        color: var(--muted);
        font-size: 12px;
      }

      @keyframes orderPop {
        from {
          transform: scale(0.84) translateY(6px);
          opacity: 0;
        }
        to {
          transform: scale(1) translateY(0);
          opacity: 1;
        }
      }

      @keyframes orderShuffle {
        0% {
          transform: translateX(6px);
        }
        50% {
          transform: translateX(-4px);
        }
        100% {
          transform: translateX(0);
        }
      }

      @keyframes orderPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.4);
        }
        100% {
          box-shadow: 0 0 0 10px rgba(52, 211, 153, 0);
        }
      }

      .panel-title {
        font-weight: 800;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .panel-hint {
        color: var(--muted);
        font-size: 12px;
      }

      .enemy-panel,
      .log-card {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 2px;
      }

      #actions {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2px;
      }

      button {
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(96, 165, 250, 0.2)
        );
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 12px;
        cursor: pointer;
        transition:
          transform 0.08s ease,
          box-shadow 0.1s ease;
      }

      button:active {
        transform: translateY(1px);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .menu {
        display: flex;
        justify-content: space-around;
        gap: 6px;

        padding-top: 4px;
        padding-bottom: 4px;
        padding-left: 2px;
        padding-right: 2px;

        background: rgba(17, 24, 39, 0.94);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
      }

      .menu-button-highlight {
        position: relative;
        box-shadow:
          0 0 0 1px rgba(52, 211, 153, 0.65),
          0 12px 30px rgba(52, 211, 153, 0.35);
        animation: guidancePulse 1.2s ease-in-out infinite;
        isolation: isolate;
      }

      .menu-button-highlight::after {
        content: "";
        position: absolute;
        inset: -4px;
        border-radius: 12px;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(52, 211, 153, 0.22),
          rgba(96, 165, 250, 0.1)
        );
        z-index: -1;
        filter: blur(6px);
      }

      @keyframes guidancePulse {
        0%,
        100% {
          transform: translateY(0) scale(1);
          box-shadow:
            0 0 0 1px rgba(52, 211, 153, 0.55),
            0 12px 30px rgba(52, 211, 153, 0.25);
        }
        50% {
          transform: translateY(-1px) scale(1.02);
          box-shadow:
            0 0 0 2px rgba(52, 211, 153, 0.8),
            0 16px 36px rgba(52, 211, 153, 0.4);
        }
      }

      .level-up-guidance {
        position: absolute;
        left: 50%;
        bottom: 96px;
        transform: translate(-50%, 10px);
        width: min(440px, calc(100% - 16px));
        background:
          radial-gradient(
            circle at 20% 20%,
            rgba(52, 211, 153, 0.18),
            transparent 38%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(96, 165, 250, 0.2),
            transparent 44%
          ),
          rgba(11, 14, 20, 0.96);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 12px;
        padding: 14px 14px 12px;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
        box-shadow:
          0 18px 48px rgba(0, 0, 0, 0.65),
          0 0 0 1px rgba(52, 211, 153, 0.18),
          0 0 0 2px rgba(255, 255, 255, 0.04);
        z-index: 35;
        opacity: 0;
        pointer-events: none;
        transition:
          opacity 0.28s ease,
          transform 0.26s ease;
      }

      .level-up-guidance.show {
        opacity: 1;
        transform: translate(-50%, 0);
        pointer-events: auto;
      }

      .level-up-guidance .guidance-icon {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        display: grid;
        place-items: center;
        font-size: 20px;
        background: rgba(255, 255, 255, 0.12);
        box-shadow:
          inset 0 0 0 1px rgba(255, 255, 255, 0.12),
          0 8px 18px rgba(0, 0, 0, 0.35);
      }

      .level-up-guidance .guidance-body {
        display: grid;
        gap: 6px;
      }

      .level-up-guidance .guidance-title {
        font-weight: 800;
        letter-spacing: 0.02em;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .level-up-guidance .guidance-text {
        color: var(--muted);
        line-height: 1.4;
        font-size: 13px;
      }

      .level-up-guidance .guidance-actions {
        display: flex;
        justify-content: flex-end;
      }

      .enemy-guidance {
        top: 78px;
        bottom: auto;
        transform: translate(-50%, -12px);
      }

      .enemy-guidance.show {
        transform: translate(-50%, 0);
      }

      .enemy-highlight {
        position: relative;
        box-shadow:
          0 0 0 1px rgba(52, 211, 153, 0.65),
          0 12px 30px rgba(52, 211, 153, 0.35);
        animation: guidancePulse 1.2s ease-in-out infinite;
        isolation: isolate;
      }

      .enemy-highlight::after {
        content: "";
        position: absolute;
        inset: -6px;
        border-radius: 14px;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(52, 211, 153, 0.22),
          rgba(96, 165, 250, 0.1)
        );
        z-index: -1;
        filter: blur(8px);
        pointer-events: none;
      }

      .pill {
        font-size: 12px;
        background: rgba(255, 255, 255, 0.06);
        padding: 4px 8px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .tag {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 6px;
        font-size: 11px;
        letter-spacing: 0.03em;
      }

      .tag.clickable {
        cursor: pointer;
        border: 1px solid rgba(96, 165, 250, 0.5);
        background: rgba(96, 165, 250, 0.12);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
        font-size: 12px;
      }

      #inventory-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        height: 60vh;
        overflow-y: auto;
        padding-right: 4px;
      }

      .inventory-filter-grid {
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 6px;
        margin-top: 8px;
      }

      .inventory-filter-button {
        font-size: 12px;
        padding: 8px 6px;
        line-height: 1.1;
      }

      .inventory-filter-button.active {
        border-color: rgba(52, 211, 153, 0.7);
        box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.35);
      }

      .bulk-sell-rarity-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 8px;
      }

      .bulk-sell-rarity-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .bulk-sell-rarity-main {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
        min-width: 0;
      }

      .bulk-sell-rarity-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: var(--accent);
      }

      .bulk-sell-rarity-item .label {
        font-weight: 700;
      }

      .bulk-sell-rarity-item .desc {
        color: var(--muted);
        font-size: 11px;
      }

      .bulk-sell-rarity-actions {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-left: auto;
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
      }

      .bulk-sell-rarity-action {
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
      }

      .bulk-sell-summary {
        margin-top: 10px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(52, 211, 153, 0.08);
        border: 1px solid rgba(52, 211, 153, 0.25);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-weight: 700;
      }

      .bulk-sell-summary .amount {
        color: #fcd34d;
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
      }

      .inventory-row {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 8px 10px;
        cursor: pointer;
        transition: background 0.1s ease;
        text-align: left;
      }

      .inventory-row:hover {
        background: rgba(255, 255, 255, 0.07);
      }

      .inventory-row:active {
        transform: translateY(1px);
      }

      .inventory-row .name {
        font-weight: 700;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .equip-badge {
        color: var(--accent);
        font-weight: 800;
        letter-spacing: 0.02em;
      }

      .enhance-badge {
        display: inline-flex;
        align-items: center;
        font-weight: 800;
        font-size: 12px;
        margin-left: 4px;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
      }

      .enhance-badge.broken {
        color: #cbd5e1;
        opacity: 0.9;
      }

      .broken-text {
        color: #cbd5e1 !important;
        opacity: 0.88;
      }

      .enhance-info-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-top: 8px;
      }

      .enhance-note {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .enhance-table {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 6px;
      }

      .enhance-row {
        padding: 8px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.04);
        display: grid;
        gap: 4px;
        font-size: 12px;
      }

      .enhance-row.current {
        border-color: rgba(52, 211, 153, 0.6);
        box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.35);
      }

      .enhance-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }

      .enhance-overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(52, 211, 153, 0.16),
          rgba(0, 0, 0, 0.6)
        );
        padding: 12px;
        z-index: 4;
        cursor: pointer;
      }

      .enhance-overlay-card {
        width: min(440px, 92%);
        padding: 16px 14px;
        background: rgba(17, 24, 39, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow:
          0 18px 40px rgba(0, 0, 0, 0.45),
          0 0 0 1px rgba(255, 255, 255, 0.06);
        border-radius: 14px;
        display: grid;
        gap: 6px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .enhance-overlay-card::after {
        content: "";
        position: absolute;
        inset: 8px;
        border-radius: 10px;
        background:
          radial-gradient(
            circle at 30% 30%,
            rgba(52, 211, 153, 0.15),
            transparent 45%
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(96, 165, 250, 0.12),
            transparent 40%
          );
        opacity: 0.8;
        pointer-events: none;
      }

      .enhance-overlay-icon {
        font-size: 30px;
        filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.45));
      }

      .enhance-overlay-title {
        font-weight: 800;
        font-size: 16px;
        letter-spacing: 0.02em;
      }

      .enhance-overlay-detail {
        color: var(--muted);
        line-height: 1.4;
      }

      .enhance-overlay-gain {
        font-weight: 800;
        color: #bef264;
        text-shadow: 0 2px 10px rgba(190, 242, 100, 0.3);
      }

      .enhance-overlay-hint {
        font-size: 11px;
        color: var(--muted);
        opacity: 0.8;
      }

      .enhance-overlay.is-progress .enhance-overlay-icon {
        animation: forgeShake 0.42s ease-in-out infinite;
      }

      .enhance-overlay.is-success .enhance-overlay-card {
        border-color: rgba(52, 211, 153, 0.65);
        box-shadow:
          0 0 0 1px rgba(52, 211, 153, 0.35),
          0 12px 30px rgba(52, 211, 153, 0.2);
      }

      .enhance-overlay.is-success .enhance-overlay-icon {
        animation: resultPulse 0.9s ease-in-out infinite;
      }

      .enhance-overlay.is-fail .enhance-overlay-card {
        border-color: rgba(239, 68, 68, 0.45);
        box-shadow:
          0 0 0 1px rgba(239, 68, 68, 0.25),
          0 12px 30px rgba(0, 0, 0, 0.3);
      }

      .enhance-overlay.is-fail .enhance-overlay-gain {
        color: #fca5a5;
        text-shadow: 0 2px 10px rgba(239, 68, 68, 0.25);
      }

      .enhance-overlay.is-broken .enhance-overlay-icon {
        animation: brokenShake 0.18s ease-in-out 0s 6;
      }

      @keyframes forgeShake {
        0%,
        100% {
          transform: rotate(-6deg) translateY(0);
        }
        50% {
          transform: rotate(4deg) translateY(-3px);
        }
      }

      @keyframes resultPulse {
        0% {
          transform: scale(0.96);
          filter: drop-shadow(0 0 0 rgba(52, 211, 153, 0.4));
        }
        50% {
          transform: scale(1.04);
          filter: drop-shadow(0 0 12px rgba(52, 211, 153, 0.45));
        }
        100% {
          transform: scale(1);
          filter: drop-shadow(0 0 4px rgba(52, 211, 153, 0.35));
        }
      }

      @keyframes brokenShake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-4px);
        }
        75% {
          transform: translateX(4px);
        }
      }

      .favorite-badge {
        color: #fcd34d;
        font-weight: 900;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
      }

      .inline-buttons {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 6px;
      }

      .rarity-normal {
        color: #e5e7eb;
      }

      .rarity-magic {
        color: #60a5fa;
      }

      .rarity-rare {
        color: #fcd34d;
      }

      .rarity-legendary {
        color: #b45309;
      }

      .stat-diff-list {
        display: grid;
        gap: 4px;
        margin-top: 4px;
      }

      .stat-diff {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 6px 8px;
        font-weight: 700;
      }

      .stat-diff.positive {
        color: #34d399;
      }

      .stat-diff.negative {
        color: #f87171;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 4px;
        margin-top: 2px;
      }

      .primary-grid {
        display: grid;
        gap: 4px;
        align-items: start;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
        padding: 2px 4px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .stat-label {
        display: grid;
        gap: 2px;
        font-size: 12px;
        color: var(--muted);
      }

      .stat-label.secondary {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        white-space: nowrap;
        line-height: 1.2;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .stat-value {
        font-weight: 700;
        font-size: 12px;
        text-align: right;
      }

      .stat-value .total {
        font-weight: 800;
      }

      .stat-value .base {
        color: var(--muted);
        font-weight: 600;
      }

      .stat-value .bonus {
        color: var(--accent);
        font-weight: 800;
      }

      .stat-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .primary-row {
        align-items: center;
      }

      .primary-info {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 700;
        min-width: 0;
      }

      .primary-actions {
        display: flex;
        gap: 6px;
        flex-shrink: 0;
        align-items: center;
      }

      .primary-actions .mini-btn {
        padding: 6px 10px;
        font-size: 12px;
        min-width: 50px;
      }

      .stat-label.inline {
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
      }

      .step-button {
        min-width: 78px;
        padding: 8px 10px;
        font-size: 12px;
      }

      .enemy-list {
        --enemy-slot-height: 38px;
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: minmax(var(--enemy-slot-height), auto);
        gap: 4px;
        font-size: 12px;
        padding-bottom: 0;
        min-height: calc(var(--enemy-slot-height) * 3 + 12px);
      }

      .enemy-card {
        display: grid;
        gap: 2px;
        padding-top: 2px;
        padding-left: 6px;
        padding-bottom: 2px;
        padding-right: 6px;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        cursor: pointer;
        transition:
          transform 0.08s ease,
          border-color 0.12s ease,
          box-shadow 0.12s ease;
        min-width: 0;
        position: relative;
        overflow: visible;
        height: 100%;
      }

      .enemy-card.boss-card {
        padding-top: 20px;
        padding-bottom: 20px;
        border: 1px solid rgba(255, 235, 173, 0.5);
        box-shadow:
          0 0 0 1px rgba(255, 255, 255, 0.04),
          0 10px 26px rgba(0, 0, 0, 0.45),
          0 0 18px rgba(255, 214, 102, 0.28);
        background:
          radial-gradient(
            circle at 20% 20%,
            rgba(255, 201, 102, 0.16),
            transparent 45%
          ),
          radial-gradient(
            circle at 80% 15%,
            rgba(96, 165, 250, 0.12),
            transparent 40%
          ),
          linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.06),
            rgba(255, 255, 255, 0.02)
          );
      }

      .enemy-card.boss-card::before,
      .enemy-card.boss-card::after {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: 10px;
        pointer-events: none;
      }

      .enemy-card.boss-card::before {
        border: 1px solid rgba(255, 214, 102, 0.5);
        box-shadow: 0 0 24px rgba(255, 214, 102, 0.2);
        opacity: 0.9;
      }

      .enemy-card.boss-card::after {
        border: 1px solid rgba(96, 165, 250, 0.2);
        mix-blend-mode: screen;
        animation: bossGlow 1.8s ease-in-out infinite;
      }

      @keyframes bossGlow {
        0%,
        100% {
          opacity: 0.35;
          transform: scale(1);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.01);
        }
      }

      .boss-ornament {
        position: absolute;
        left: 10px;
        right: 10px;
        top: 8px;
        display: none;
        align-items: center;
        justify-content: space-between;
        pointer-events: none;
        z-index: 1;
      }

      .boss-crest {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 800;
        letter-spacing: 0.06em;
        font-size: 11px;
        text-transform: uppercase;
        color: #0b0e14;
        background: linear-gradient(
          135deg,
          #ffe082,
          #f59e0b 50%,
          #a5b4fc 100%
        );
        box-shadow:
          0 10px 24px rgba(0, 0, 0, 0.35),
          0 0 16px rgba(255, 214, 102, 0.45);
      }

      .boss-crest .icon {
        font-size: 13px;
        filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.35));
      }

      .boss-line {
        flex: 1;
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 214, 102, 0.6),
          transparent
        );
        filter: drop-shadow(0 0 10px rgba(255, 214, 102, 0.45));
      }

      .enemy-card:active {
        transform: translateY(1px);
      }

      .enemy-card:hover {
        border-color: rgba(255, 255, 255, 0.16);
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
      }

      .boss-retry-toggle {
        position: absolute;
        right: 6px;
        bottom: 6px;
        padding: 4px 10px;
        font-size: 11px;
        border-radius: 999px;
        background: linear-gradient(
          120deg,
          rgba(52, 211, 153, 0.24),
          rgba(96, 165, 250, 0.18)
        );
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: var(--text);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .boss-retry-toggle input {
        margin: 0;
        accent-color: #fcd34d;
      }

      .enemy-card.boss-card .boss-retry-toggle {
        background: linear-gradient(
          120deg,
          rgba(255, 214, 102, 0.32),
          rgba(96, 165, 250, 0.22)
        );
        border-color: rgba(255, 255, 255, 0.28);
        color: #0b0e14;
        font-weight: 700;
      }

      .enemy-card.boss-card .enemy-name {
        color: #ffe082;
        text-shadow:
          0 1px 4px rgba(0, 0, 0, 0.4),
          0 0 8px rgba(255, 214, 102, 0.45);
      }

      .enemy-card.boss-card .enemy-bar .fill {
        background: linear-gradient(90deg, #fbbf24, #f97316, #3b82f6);
        box-shadow: 0 0 8px rgba(255, 214, 102, 0.45);
      }

      .attack-badge {
        position: absolute;
        top: 6px;
        right: 6px;
        background: rgba(52, 211, 153, 0.18);
        border: 1px solid rgba(52, 211, 153, 0.5);
        color: #ecfdf3;
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 999px;
        line-height: 1.2;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .enemy-card .row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 2px;
        align-items: center;
        min-width: 0;
      }

      .enemy-info {
        display: grid;
        gap: 2px;
        min-width: 0;
      }

      .enemy-name-row {
        display: flex;
        align-items: center;
        gap: 2px;
        flex-wrap: wrap;
        min-width: 0;
      }

      .enemy-name {
        font-weight: 600;
        letter-spacing: 0.02em;
        min-width: 0;
        display: inline-flex;
        align-items: center;
        gap: 2px;
      }

      .enemy-meta {
        display: flex;
        align-items: center;
        gap: 2px;
        color: var(--muted);
        font-size: 12px;
      }

      .enemy-bar.pulse {
        animation: barPulse 0.5s ease;
      }

      .damage-popup {
        position: absolute;
        left: 50%;
        top: 6px;
        transform: translate(-50%, 0);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        min-width: max-content;
        font-weight: 800;
        font-size: 14px;
        letter-spacing: 0.01em;
        white-space: nowrap;
        padding: 4px 10px;
        border-radius: 12px;
        pointer-events: none;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.45);
        opacity: 0;
        animation: damageFloat 0.8s ease forwards;
        z-index: 5;
      }

      .damage-popup.player {
        color: #fecdd3;
      }

      .damage-popup.enemy {
        color: #bbf7d0;
      }

      .damage-popup.critical {
        color: #fcd34d;
        text-shadow:
          0 2px 10px rgba(252, 211, 77, 0.65),
          0 0 14px rgba(248, 250, 252, 0.35);
        filter: drop-shadow(0 0 6px rgba(250, 204, 21, 0.45));
        letter-spacing: 0.03em;
        animation:
          damageFloat 0.9s ease forwards,
          critFlash 0.9s ease-out;
      }

      .damage-popup .crit-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 999px;
        background: linear-gradient(120deg, rgba(250, 204, 21, 0.9), rgba(251, 191, 36, 0.65));
        color: #0b0e14;
        font-size: 11px;
        text-transform: uppercase;
        box-shadow:
          0 4px 16px rgba(0, 0, 0, 0.35),
          0 0 0 1px rgba(252, 211, 77, 0.6);
      }

      .damage-popup .crit-star {
        font-size: 12px;
        filter: drop-shadow(0 0 6px rgba(252, 211, 77, 0.8));
      }

    /* プレイヤーHPバー周辺（popupの親）を、敵カードと同じ条件にする */
    .popup-anchor {
      position: relative;   /* absoluteの基準を安定させる */
      overflow: visible;    /* これが最重要：見切れて縮んで見えるのを防ぐ */
      min-width: 1px;       /* 念のため */
    }
    
    /* 万が一、他の要素に負けて背面に回る場合の保険 */
    .popup-anchor .damage-popup {
      z-index: 9999;
    }

      /* 画面最前面のポップアップレイヤー（transformの影響を受けない） */
#popup-layer {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9999;
}

      
      .damage-popup.mp {
        color: #bfdbfe;
        background: none;
        box-shadow: none;
        filter: none;
        text-shadow: none;
        padding: 0;
        gap: 0;
      }

      .damage-popup.heal {
        color: #a5f3fc;
        text-shadow: 0 1px 6px rgba(45, 212, 191, 0.5);
      }

      .skill-popup {
        position: absolute;
        left: 50%;
        top: -8px;
        transform: translate(-50%, -8px);
        padding: 6px 12px;
        border-radius: 12px;
        font-weight: 800;
        letter-spacing: 0.04em;
        font-size: 12px;
        background: linear-gradient(135deg, rgba(52, 211, 153, 0.2), rgba(96, 165, 250, 0.2));
        color: #e0f2fe;
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow:
          0 8px 22px rgba(0, 0, 0, 0.35),
          0 0 0 1px rgba(52, 211, 153, 0.12);
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
        pointer-events: none;
        opacity: 0;
        animation: skillPopupFloat 1.1s ease forwards;
        z-index: 6;
        white-space: nowrap;
      }

      .skill-popup.enemy {
        background: linear-gradient(135deg, rgba(250, 204, 21, 0.28), rgba(248, 113, 113, 0.25));
        color: #fff7ed;
        border-color: rgba(250, 204, 21, 0.3);
        box-shadow:
          0 10px 26px rgba(0, 0, 0, 0.35),
          0 0 0 1px rgba(248, 113, 113, 0.18);
      }

      @keyframes skillPopupFloat {
        0% {
          opacity: 0;
          transform: translate(-50%, -2px) scale(0.95);
          filter: drop-shadow(0 0 0 rgba(96, 165, 250, 0));
        }
        20% {
          opacity: 1;
          transform: translate(-50%, -10px) scale(1.04);
          filter: drop-shadow(0 0 10px rgba(52, 211, 153, 0.6));
        }
        70% {
          opacity: 1;
          transform: translate(-50%, -14px) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -18px) scale(1.02);
          filter: drop-shadow(0 0 4px rgba(96, 165, 250, 0.25));
        }
      }

      @keyframes damageFloat {
        0% {
          opacity: 0;
          transform: translate(-50%, 6px) scale(0.95);
        }
        25% {
          opacity: 1;
          transform: translate(-50%, 0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -16px) scale(1.04);
        }
      }

      @keyframes critFlash {
        0% {
          transform: translate(-50%, 6px) scale(0.95);
          filter: drop-shadow(0 0 0 rgba(252, 211, 77, 0));
        }
        20% {
          transform: translate(-50%, 0) scale(1.08);
          filter: drop-shadow(0 0 12px rgba(252, 211, 77, 0.75));
        }
        100% {
          transform: translate(-50%, -16px) scale(1.04);
          filter: drop-shadow(0 0 4px rgba(252, 211, 77, 0.2));
        }
      }

      /*
    @keyframes enemyDefeated {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      to {
        opacity: 0.45;
        transform: translateY(4px) scale(0.97);
      }
    }
    */

      .enemy-card.defeated {
        filter: grayscale(0.75);
        position: relative;
        animation: enemyDefeated 0.5s ease forwards;
      }

      .enemy-card.defeated::after {
        content: "✖";
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-size: 48px;
        color: rgba(248, 113, 113, 0.6);
        pointer-events: none;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .action-button-wrapper {
        position: relative;
      }

      .action-button-wrapper > .main-action {
        width: 100%;
        height: 100%;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding-top: 10px;
        padding-bottom: 10px;
      }

      .actions-row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 6px;
        align-items: stretch;
      }

      .action-card {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: space-between;
        gap: 2px;
        padding: 4px 6px 6px;
        min-height: 40px;
        text-align: left;
      }

      .auto-skill-toggle {
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.16),
          rgba(96, 165, 250, 0.12)
        );
        border: 1px solid rgba(52, 211, 153, 0.4);
        color: var(--text);
        align-items: center;
        justify-content: center;
        gap: 4px;
      }

      .auto-skill-toggle.is-on {
        box-shadow:
          0 0 0 1px rgba(52, 211, 153, 0.4),
          0 12px 30px rgba(52, 211, 153, 0.22);
      }

      .auto-skill-toggle .auto-skill-label {
        font-weight: 700;
        font-size: 13px;
      }

      .auto-skill-toggle .auto-skill-state {
        font-size: 12px;
        color: var(--muted);
      }

      .action-top {
        width: 100%;
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: space-around;
        gap: 2px;
      }

      .potion-button {
        background: linear-gradient(
          135deg,
          rgba(248, 113, 113, 0.22),
          rgba(96, 165, 250, 0.15)
        );
      }

      .potion-icon {
        font-size: 16px;
        width: 28px;
        height: 28px;
        display: grid;
        place-items: center;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        flex-shrink: 0;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
      }

      .potion-fill {
        flex: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 2px;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .info-chip {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        padding: 0;
        font-weight: 800;
        background: rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
        display: grid;
        place-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        cursor: pointer;
      }

      .info-chip:focus-visible {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .skill-button {
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.16),
          rgba(96, 165, 250, 0.14)
        );
      }

      .skill-meta {
        display: grid;
        gap: 2px;
        min-width: 0;
      }

      .skill-name {
        font-weight: 700;
        font-size: 12px;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .skill-status {
        color: var(--muted);
        font-size: 11px;
        line-height: 1.1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .enemy-top {
        display: flex;
        align-items: center;
        gap: 2px;
        justify-content: space-between;
      }

      .enemy-name {
        display: grid;
        gap: 2px;
        font-weight: 600;
      }

      .enemy-meta {
        display: flex;
        align-items: center;
        gap: 2px;
        color: var(--muted);
        font-size: 10px;
      }

      .enemy-bar {
        position: relative;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 999px;
        height: 14px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .enemy-bar .fill {
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, #ef4444, #f87171);
        width: 50%;
        border-radius: 999px;
        transition: width 0.28s ease;
      }

      .enemy-bar .label {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        line-height: 1;
        color: #f8fafc;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        pointer-events: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 50;
      }

      #reset-modal,
      #skill-reset-modal {
        z-index: 60;
      }

      #weapon-enhance-modal {
        z-index: 70;
      }

      #codex-modal,
      #codex-detail-modal {
        z-index: 80;
      }

      .hidden {
        display: none !important;
      }

      .modal.hidden {
        display: none;
      }

      .debug-tabs {
        display: flex;
        gap: 6px;
        margin-bottom: 8px;
      }

      .tab-button {
        flex: 1;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
        border-radius: 8px;
        font-weight: 700;
        transition:
          background 0.15s ease,
          color 0.15s ease,
          border-color 0.15s ease;
      }

      .tab-button.active {
        background: rgba(52, 211, 153, 0.15);
        border-color: rgba(52, 211, 153, 0.45);
        color: #f8fafc;
        box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.35);
      }

      .debug-tab-button {
        flex: 1;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 8px;
        font-weight: 700;
      }

      .debug-tab-button.active {
        border-color: rgba(52, 211, 153, 0.6);
        box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.3);
      }

      .debug-tab-panel.hidden {
        display: none;
      }

      .save-slot-list {
        display: grid;
        gap: 8px;
        margin-top: 8px;
      }

      .save-slot-card {
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.04);
        border-radius: 10px;
        padding: 10px;
        display: grid;
        gap: 6px;
      }

      .save-slot-card.active {
        border-color: rgba(52, 211, 153, 0.6);
        box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.24);
      }

      .save-slot-header {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: baseline;
      }

      .save-slot-title {
        font-weight: 800;
        letter-spacing: 0.02em;
      }

      .save-slot-meta {
        font-size: 12px;
        color: var(--muted);
      }

      .save-slot-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .save-slot-actions button {
        flex: 1;
        min-width: 120px;
        font-size: 12px;
        padding: 8px;
      }

      .save-slot-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
      }

      .equipment-option-list {
        display: grid;
        gap: 4px;
        margin-top: 6px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 8px;
      }

      .equipment-option-list .option-label {
        font-size: 12px;
        color: var(--muted);
      }

      .equipment-option-list .option-value {
        font-weight: 700;
      }

      .modal-content {
        width: min(420px, 94%);
        background: rgba(17, 24, 39, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 8px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
        max-height: 88vh;
        overflow-y: auto;
      }

      .inventory-modal-content {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .player-modal-content {
        display: flex;
        flex-direction: column;
        max-height: 88vh;
        overflow: hidden;
        gap: 6px;
      }

      .player-modal-page {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .player-modal-actions {
        justify-content: center;
        gap: 10px;
      }

      .player-modal-actions button.active {
        background: linear-gradient(
          120deg,
          rgba(52, 211, 153, 0.16),
          rgba(96, 165, 250, 0.14)
        );
        border-color: rgba(255, 255, 255, 0.14);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
      }

      .secondary-scroll {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        padding-right: 4px;
        margin-bottom: 4px;
      }

      .primary-fixed {
        flex-shrink: 0;
        display: grid;
        gap: 8px;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 12px;
        flex-wrap: wrap;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .equipment-list {
        display: grid;
        gap: 8px;
      }

      .equipment-row {
        display: grid;
        grid-template-columns: 80px 1fr;
        gap: 10px;
        align-items: start;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: rgba(255, 255, 255, 0.02);
      }

      .equipment-body {
        display: grid;
        gap: 6px;
      }

      .equipment-slot-label {
        font-weight: 700;
        color: var(--muted);
        font-size: 13px;
      }

      .equipment-name {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 700;
        word-break: break-all;
      }

      .equipment-empty {
        color: var(--muted);
        font-size: 13px;
      }

      .equipment-option-list.compact .option-label {
        font-size: 11px;
        color: var(--muted);
        margin-bottom: 2px;
      }

      .equipment-option-list.compact .option-value {
        font-size: 12px;
        padding: 0;
      }

      .equipment-option-list.compact {
        gap: 4px;
      }

      .equipment-bonus-list {
        display: grid;
        gap: 6px;
      }

      .section-title {
        font-size: 14px;
        font-weight: 800;
        letter-spacing: 0.03em;
      }

      .help-icon {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        font-weight: 800;
        cursor: pointer;
      }

      .help-panel {
        margin-top: 8px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
        font-size: 12px;
        line-height: 1.5;
      }

      .modal-body-title {
        font-weight: 700;
        margin-bottom: 6px;
      }

      .help-panel ul {
        padding-left: 16px;
        margin: 6px 0;
      }

      .modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        border-radius: 999px;
        width: 30px;
        height: 30px;
        cursor: pointer;
      }

      .status-list {
        display: flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
        min-height: 18px;
      }

      .enemy-statuses {
        align-items: flex-start;
        gap: 2px;
      }

      .status-pill {
        font-size: 10px;
        padding: 3px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.05);
        color: #e5e7eb;
        cursor: pointer;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }

      .status-pill.control {
        border-color: rgba(255, 99, 132, 0.4);
        background: rgba(248, 113, 113, 0.12);
      }

      .status-pill.dot {
        border-color: rgba(74, 222, 128, 0.35);
        background: rgba(34, 197, 94, 0.12);
      }

      .status-pill.debuff {
        border-color: rgba(96, 165, 250, 0.35);
        background: rgba(59, 130, 246, 0.12);
      }

      .status-pill.buff {
        border-color: rgba(52, 211, 153, 0.35);
        background: rgba(52, 211, 153, 0.12);
      }

      .status-popover {
        position: fixed;
        inset: auto 12px 20px 12px;
        background: rgba(15, 23, 42, 0.96);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        padding: 10px;
        color: var(--text);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        z-index: 70;
        max-width: 460px;
        margin: 0 auto;
      }

      .status-popover.hidden {
        display: none;
      }

      .status-popover .title {
        font-weight: 800;
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .status-popover .body {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.5;
      }

      .status-popover .effect-list {
        display: grid;
        gap: 8px;
        margin-top: 8px;
      }

      .status-popover .effect-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .status-popover .effect-row.highlight {
        border-color: rgba(96, 165, 250, 0.35);
        background: rgba(59, 130, 246, 0.14);
      }

      .status-popover .effect-meta {
        display: grid;
        gap: 2px;
        min-width: 0;
      }

      .status-popover .effect-name {
        font-weight: 800;
        font-size: 13px;
      }

      .status-popover .effect-desc {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .status-popover .effect-turns {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
      }

      .debug-selects {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin: 6px 0 4px;
      }

      .debug-selects label {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .debug-selects input {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        padding: 6px;
        color: var(--text);
        width: 96px;
      }

      .debug-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        margin: 6px 0 4px;
      }

      .debug-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 4px;
      }

      .debug-section {
        margin-top: 8px;
        padding: 8px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .debug-section h4 {
        margin: 0 0 6px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.04em;
      }

      .legendary-records {
        display: grid;
        gap: 6px;
        margin-top: 6px;
      }

      .legendary-record-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 14px;
        gap: 6px;
      }

      .legendary-extreme {
        color: var(--accent);
        font-weight: 800;
        font-size: 12px;
        padding-left: 6px;
        white-space: nowrap;
      }

      .codex-tabs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        gap: 6px;
        margin-bottom: 10px;
      }

      .codex-tab {
        padding: 10px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.03);
        color: var(--text);
        font-weight: 700;
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .codex-tab.active {
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.18),
          rgba(96, 165, 250, 0.16)
        );
        border-color: rgba(255, 255, 255, 0.18);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      }

      .codex-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        max-height: 420px;
        overflow-y: auto;
        padding-right: 2px;
      }

      .codex-entry {
        width: 100%;
        text-align: left;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.02);
        padding: 10px;
        display: grid;
        gap: 6px;
        cursor: pointer;
      }

      .codex-entry:hover {
        border-color: rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.04);
      }

      .codex-entry .codex-name {
        font-weight: 800;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .codex-entry .codex-name .pill {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .codex-entry .codex-desc {
        color: var(--muted);
        font-size: 13px;
        line-height: 1.4;
      }

      .codex-entry.undiscovered {
        opacity: 0.72;
        filter: grayscale(0.35);
      }

      .codex-detail-body {
        display: grid;
        gap: 8px;
        max-height: 420px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .codex-detail-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .codex-detail-row .label {
        min-width: 70px;
        color: var(--muted);
        font-size: 13px;
      }

      .codex-detail-row .value {
        font-weight: 700;
      }

      .codex-detail-empty {
        text-align: center;
        padding: 20px 10px;
        color: var(--muted);
      }

      .warp-section {
        margin-top: 10px;
        display: grid;
        gap: 6px;
      }

      .warp-boss-list {
        display: grid;
        gap: 6px;
      }

      .warp-boss-row {
        display: grid;
        grid-template-columns: 1fr 44px;
        gap: 6px;
        align-items: center;
      }

      .warp-boss-row .info-btn {
        padding: 6px;
        font-weight: 800;
      }

      .warp-note {
        color: var(--muted);
        font-size: 12px;
      }

      .passive-tree-modal-content {
        width: min(980px, 96vw);
        height: min(860px, 92vh);
        padding: 0;
        overflow: hidden;
        background: #01040a;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .passive-tree-shell {
        display: grid;
        grid-template-rows: auto auto auto 1fr;
        height: 100%;
      }

      .passive-tree-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: rgba(1, 4, 10, 0.92);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .passive-tree-header .title {
        font-size: 16px;
        font-weight: 800;
        letter-spacing: 0.08em;
      }

      .passive-tree-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        padding: 10px 16px;
        background: rgba(1, 4, 10, 0.9);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      .passive-tree-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 16px;
        background: rgba(1, 4, 10, 0.88);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      .passive-tree-tabs button {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(15, 23, 42, 0.7);
        color: var(--text);
        font-size: 12px;
        font-weight: 700;
      }

      .passive-tree-tabs button.active {
        background: rgba(59, 130, 246, 0.2);
        border-color: rgba(59, 130, 246, 0.6);
        color: #dbeafe;
      }

      .passive-tree-body {
        position: relative;
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100%;
      }

      .passive-tree-panel {
        padding: 14px 16px;
        display: grid;
        gap: 8px;
        background: rgba(3, 7, 18, 0.92);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        max-height: 220px;
        overflow-y: auto;
      }

      .passive-tree-panel .node-title {
        font-weight: 800;
        font-size: 14px;
      }

      .passive-tree-panel .node-type {
        color: var(--muted);
        font-size: 12px;
      }

      .passive-tree-panel .node-effect {
        font-size: 12px;
        line-height: 1.5;
      }

      .passive-tree-panel .node-actions {
        display: grid;
        gap: 6px;
      }

      .passive-tree-panel .node-actions button {
        width: 100%;
      }

      .passive-tree-panel .node-meta {
        font-size: 12px;
        color: var(--muted);
      }

      .passive-tree-panel .node-warning {
        font-size: 12px;
        color: #fca5a5;
      }

      .passive-tree-panel .node-success {
        font-size: 12px;
        color: #86efac;
      }

      :root {
        --bg-color: #01040a;
        --accent-blue: #3b82f6;
        --keystone-gold: #fbbf24;
        --active-red: #f43f5e;
        --line-inactive: rgba(255, 255, 255, 0.05);
      }

      #canvas-container {
        width: 100%;
        height: 100%;
        min-height: 520px;
        background:
          radial-gradient(circle at center, #0a1b35 0%, #01040a 100%),
          linear-gradient(var(--line-inactive) 1px, transparent 1px),
          linear-gradient(90deg, var(--line-inactive) 1px, transparent 1px);
        background-size: 100% 100%, 100px 100px, 100px 100px;
        touch-action: none;
      }

      #canvas-container.tree-bg-sword {
        background:
          radial-gradient(circle at center, #0f1d35 0%, #030712 100%),
          linear-gradient(var(--line-inactive) 1px, transparent 1px),
          linear-gradient(90deg, var(--line-inactive) 1px, transparent 1px);
      }

      #canvas-container.tree-bg-mage {
        background:
          radial-gradient(circle at center, #1a0f35 0%, #07030f 100%),
          linear-gradient(var(--line-inactive) 1px, transparent 1px),
          linear-gradient(90deg, var(--line-inactive) 1px, transparent 1px);
      }

      #canvas-container.tree-bg-cleric {
        background:
          radial-gradient(circle at center, #12301f 0%, #030a06 100%),
          linear-gradient(var(--line-inactive) 1px, transparent 1px),
          linear-gradient(90deg, var(--line-inactive) 1px, transparent 1px);
      }

      #canvas-container.tree-bg-vampire {
        background:
          radial-gradient(circle at center, #2b0f17 0%, #0b0307 100%),
          linear-gradient(var(--line-inactive) 1px, transparent 1px),
          linear-gradient(90deg, var(--line-inactive) 1px, transparent 1px);
      }

      .node {
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
      }
      .node:hover {
        filter: brightness(1.6) scale(1.1);
      }

      .node.locked {
        opacity: 0.55;
      }

      .node.unlockable {
        filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.65));
      }

      .active-path {
        stroke: var(--accent-blue);
        stroke-width: 4.5;
        filter: drop-shadow(0 0 12px var(--accent-blue));
        stroke-dasharray: 12;
        animation: dashflow 1.5s linear infinite;
      }
      @keyframes dashflow {
        from {
          stroke-dashoffset: 24;
        }
        to {
          stroke-dashoffset: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="phone">
      <div id="player-down-overlay" class="player-down-overlay" aria-live="polite">
        <div>戦闘不能</div>
        <div class="player-down-hint">タップ / クリックで復帰</div>
      </div>

      <section class="card log-card">
        <div id="log"></div>
      </section>

      <section class="card enemy-panel">
        <div class="turn-order-bar" aria-label="行動順">
          <div
            id="turn-order-list"
            class="turn-order-list"
            aria-live="polite"
          ></div>
          <div class="turn-order-hint">敵タップで詳細表示</div>
        </div>
        <div id="enemies" class="enemy-list"></div>
      </section>

      <div
        id="enemy-guidance"
        class="level-up-guidance enemy-guidance"
        role="status"
        aria-live="polite"
        aria-hidden="true"
      >
        <div class="guidance-icon" aria-hidden="true">👾</div>
        <div class="guidance-body">
          <div class="guidance-title">
            敵カードとアーキタイプを確認しよう
          </div>
          <div class="guidance-text">
            Lv1ではまず敵の特徴をチェック！メッセージはタップで詳細を確認できます。
          </div>
          <div class="guidance-actions">
            <button id="enemy-guidance-close" type="button">OK</button>
          </div>
        </div>
      </div>

      <section class="card">
        <div
          class="subtle"
          style="justify-content: flex-start; gap: 10px; margin-bottom: 4px"
        >
          <span>LV <span id="level"></span></span>
          <div
            id="player-status-list"
            class="status-list"
            aria-label="プレイヤー状態"
          ></div>
          <span class="pill">階層 <span id="floor-inline"></span>F</span>
          <span class="pill gold-pill">💰 <span id="gold"></span>G</span>
        </div>
        <div class="bars">
          <div class="bar">
            <span id="hp-bar" class="hp"></span>
            <span id="hp-barrier" class="barrier"></span>
            <span id="hp-label" class="label"></span>
          </div>
          <div class="bar">
            <span id="mp-bar" class="mp"></span>
            <span id="mp-label" class="label"></span>
          </div>
          <div class="bar">
            <span id="exp-bar" class="exp"></span>
            <span id="exp-label" class="label"></span>
          </div>
        </div>
      </section>

      <section class="card">
        <div id="actions"></div>
      </section>

      <nav class="menu">
        <button id="btn-player-modal">プレイヤー詳細</button>
        <button id="btn-skill-tree">パッシブツリー</button>
        <button id="btn-inventory">アイテム</button>
        <button id="btn-codex">図鑑</button>
        <button id="btn-warp">ワープ</button>
        <button id="btn-debug">デバッグ</button>
      </nav>

      <div
        id="level-up-guidance"
        class="level-up-guidance"
        role="status"
        aria-live="polite"
        aria-hidden="true"
      >
        <div class="guidance-icon" aria-hidden="true">🎉</div>
        <div class="guidance-body">
          <div class="guidance-title">Lv2到達おめでとう！</div>
          <div class="guidance-text">
            レベルが上がるとステータスポイント5ポイント、スキルポイント1ポイント、パッシブポイント1ポイント付与される。リセットも出来るので色々試してみてください。
          </div>
          <div class="guidance-actions">
            <button id="level-up-guidance-close" type="button">OK</button>
          </div>
        </div>
      </div>

      <div id="level-up-toast" class="level-up-toast" aria-hidden="true">
        <div class="toast-glow"></div>
        <div class="toast-body">
          <span class="toast-icon" aria-hidden="true">✨</span>
          <div class="toast-text">
            <div class="toast-label">LEVEL UP</div>
            <div class="toast-level">
              Lv <span id="level-up-value"></span> に到達
            </div>
          </div>
        </div>
        <div class="toast-trail"></div>
      </div>

      <div id="drop-toast-stack" class="drop-toast-stack" aria-live="polite"></div>
      <template id="drop-toast-template">
        <div class="drop-toast" aria-hidden="true">
          <div class="drop-toast-core">
            <div class="drop-toast-glow"></div>
            <div class="drop-toast-body">
              <div class="drop-text">
                <div class="drop-pill">RARE DROP</div>
                <div class="drop-item-name"></div>
              </div>
            </div>
            <div class="drop-sparkles"></div>
            <div class="drop-ribbon"></div>
          </div>
        </div>
      </template>
    </div>

    <div id="enemy-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">敵の詳細</div>
            <div id="modal-name" style="font-weight: 700"></div>
          </div>
          <button id="modal-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="stats" style="margin-top: 10px">
          <div>HP <span id="modal-hp"></span></div>
          <div>ATK <span id="modal-atk"></span></div>
          <div>DEF <span id="modal-def"></span></div>
          <div>SPD <span id="modal-spd"></span></div>
          <div>命中 <span id="modal-acc"></span></div>
          <div>回避 <span id="modal-evd"></span></div>
          <div>耐性 <span id="modal-resist"></span></div>
        </div>
        <div
          class="pill"
          id="modal-tag"
          style="margin-top: 10px; display: inline-flex"
        >
          BOSS
        </div>
        <div
          id="modal-feature"
          class="help-panel"
          style="margin-top: 10px"
        ></div>
        <div
          id="modal-legendary-section"
          class="help-panel hidden"
          style="margin-top: 10px"
        >
          <div class="option-label" style="margin-bottom: 6px">
            ボスレジェンダリー
          </div>
          <div class="option-value" id="modal-boss-kills"></div>
          <div class="option-value" id="modal-legendary-name"></div>
          <div class="option-value" id="modal-legendary-status"></div>
          <div id="modal-legendary-stats" class="legendary-records"></div>
        </div>
      </div>
    </div>

    <div
      id="archetype-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">アーキタイプ詳細</div>
            <div id="archetype-modal-name" style="font-weight: 700"></div>
          </div>
          <button id="archetype-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div
          class="help-panel"
          id="archetype-modal-desc"
          style="margin-top: 10px"
        ></div>
        <div class="option-label" style="margin-top: 10px">付与能力</div>
        <div id="archetype-modal-abilities" class="option-value"></div>
      </div>
    </div>

    <div id="potion-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">ポーション詳細</div>
            <div id="potion-modal-name" style="font-weight: 700"></div>
          </div>
          <button id="potion-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="stats" style="margin-top: 10px">
          <div>種類 <span id="potion-modal-type"></span></div>
          <div>ランク <span id="potion-modal-rarity"></span></div>
          <div>効果 <span id="potion-modal-effect"></span></div>
          <div>消費 <span id="potion-modal-cost"></span></div>
          <div>残量 <span id="potion-modal-fill"></span></div>
          <div>前置詞 <span id="potion-modal-prefix"></span></div>
          <div>後置詞 <span id="potion-modal-suffix"></span></div>
          <div>説明 <span id="potion-modal-desc"></span></div>
        </div>
        <div class="help-panel" style="margin-top: 10px">
          敵を倒すと少しずつ補充されます。
        </div>
      </div>
    </div>

    <div
      id="skill-info-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">スキル詳細</div>
            <div id="skill-info-name" style="font-weight: 700"></div>
          </div>
          <button id="skill-info-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="stats" style="margin-top: 10px">
          <div>種類 <span id="skill-info-type"></span></div>
          <div>CT <span id="skill-info-cooldown"></span></div>
          <div>習得状況 <span id="skill-info-level"></span></div>
          <div>効果 <span id="skill-info-effect"></span></div>
        </div>
        <div
          class="help-panel"
          id="skill-info-note"
          style="margin-top: 10px"
        ></div>
      </div>
    </div>

    <div id="player-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content player-modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">プレイヤー詳細</div>
          </div>
          <button id="player-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div id="player-status-view" class="player-modal-page">
          <div class="secondary-scroll">
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
              "
            >
              <div class="section-title" style="margin: 8px 0 4px">
                二次ステータス
              </div>
              <button class="help-icon" id="stat-help" aria-label="計算式メモ">
                ？
              </button>
            </div>
            <div id="secondary-stats" class="stat-grid"></div>
          </div>
          <div class="primary-fixed">
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
              "
            >
              <div class="section-title" style="margin: 2px 0 4px">
                一次ステータス
              </div>
              <div style="display: flex; align-items: center; gap: 6px">
                <div class="inline-buttons">
                  <div class="pill">能力P: <span id="stat-points"></span></div>
                </div>
                <button
                  id="stat-step"
                  class="step-button"
                  aria-label="増減幅を切り替え"
                >
                  ±1
                </button>
                <button
                  id="reset-stats"
                  class="help-icon"
                  aria-label="ステータスをリセット"
                >
                  ↺
                </button>
              </div>
            </div>
            <div id="primary-stats" class="primary-grid"></div>
          </div>
        </div>
        <div id="player-equipment-view" class="player-modal-page hidden">
          <div class="secondary-scroll">
            <div class="section-title" style="margin: 8px 0 4px">装備一覧</div>
            <div id="player-equipment-list" class="equipment-list"></div>
            <div class="section-title" style="margin: 8px 0 4px">
              装備ボーナス
            </div>
            <div
              id="equipment-bonus-summary"
              class="equipment-bonus-list"
            ></div>
          </div>
        </div>
        <div class="modal-actions player-modal-actions">
          <button id="player-modal-status-btn" class="active">
            ステータス
          </button>
          <button id="player-modal-equipment-btn">装備</button>
        </div>
      </div>
    </div>

    <div id="memo-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div class="section-title" style="margin: 0">計算メモ</div>
          <button id="memo-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="modal-body-title">攻撃・防御</div>
        <div class="help-panel">
          <ul>
            <li>最大HP = 基礎HP + 体力 × 16 (+装備補正)</li>
            <li>最大MP = 基礎MP + 知識 × 7 (+装備補正)</li>
            <li>物理攻撃力 = 武器 + 力 × 2.8</li>
            <li>魔法攻撃力 = 魔器 + 知識 × 3.1</li>
            <li>物理防御力 = 体力×1.2 + 力×0.45</li>
            <li>魔法防御力 = 体力×1.0 + 知識×0.7</li>
            <li>物理貫通 = 力による軽減無視 (上限60%)</li>
            <li>魔法貫通 = 知識による軽減無視 (上限60%)</li>
            <li>被ダメージ軽減 = 体力由来の軽減 (上限80%)</li>
            <li>ブロック率 = 体力ベース (上限50%)</li>
          </ul>
        </div>
        <div class="modal-body-title">行動・会心</div>
        <div class="help-panel">
          <ul>
            <li>行動速度 = 基礎速度 + 敏捷×2.2</li>
            <li>命中率 = 140% + 敏捷×0.26% (上限200%)</li>
            <li>クリティカル率 / 回避率 = (敏捷+運) 減衰式 (上限あり)</li>
            <li>クリティカルダメージ = 150% + クリダメ% (上限100%)</li>
            <li>クールタイム短縮 = 敏捷/知識由来 (上限40%)</li>
          </ul>
        </div>
        <div class="modal-body-title">抵抗・補助・ハクスラ</div>
        <div class="help-panel">
          <ul>
            <li>
              行動阻害抵抗 / DoT抵抗 / 弱体化抵抗 = 体力＋各種ステ由来 (上限120%)
            </li>
            <li>HP再生 = 体力 × 0.4 / ターン</li>
            <li>HP吸収 = 与ダメ × 吸収% (力と運の高い方×0.2%、上限20%)</li>
            <li>バリア = 体力×4 + 知識×2</li>
            <li>
              ドロップ率UP / レアリティUP = 運による減衰式
              (ドロップ50%、レアリティ30%上限)
            </li>
            <li>称号付与率UP = 運による減衰式 (上限80%)</li>
            <li>ネームド遭遇率 = 運による減衰式 (上限90%)</li>
            <li>ゴールド確率 = 基礎100% + ボーナス (0%未満にならない)</li>
          </ul>
        </div>
      </div>
    </div>

    <div id="reset-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div class="section-title" style="margin: 0">
            ステータスをリセット
          </div>
          <button id="reset-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div>
          振り分けたポイント(<span id="reset-spent"></span
          >P)を戻します。よろしいですか？
        </div>
        <div class="modal-actions">
          <button id="reset-cancel">キャンセル</button>
          <button id="reset-confirm">リセットする</button>
        </div>
      </div>
    </div>

    <div
      id="skill-reset-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div class="section-title" style="margin: 0">スキルをリセット</div>
          <button
            id="skill-reset-close"
            class="modal-close"
            aria-label="閉じる"
          >
            ×
          </button>
        </div>
        <div>
          習得したポイント(<span id="skill-reset-spent"></span
          >P)を戻します。よろしいですか？
        </div>
        <div class="modal-actions">
          <button id="skill-reset-cancel">キャンセル</button>
          <button id="skill-reset-confirm">リセットする</button>
        </div>
      </div>
    </div>

    <div
      id="passive-tree-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content passive-tree-modal-content">
        <div class="passive-tree-shell">
          <div class="passive-tree-header">
            <div class="title">パッシブツリー</div>
            <button id="passive-tree-close" class="modal-close" aria-label="閉じる">
              ×
            </button>
          </div>
          <div class="passive-tree-toolbar">
            <div class="pill">パッシブP: <span id="passive-points"></span></div>
            <button id="passive-tree-open-skills" class="mini-btn">
              スキル管理へ
            </button>
            <button id="passive-tree-reset" class="help-icon">
              ルートリセット
            </button>
          </div>
          <div id="passive-tree-tabs" class="passive-tree-tabs"></div>
          <div class="passive-tree-body">
            <div class="passive-tree-panel" id="passive-tree-panel">
              <div class="node-title">ノード未選択</div>
              <div class="node-meta">
                ツリー上のノードを選ぶと効果が表示されます。
              </div>
            </div>
            <div id="canvas-container">
              <svg id="svg-root" width="100%" height="100%">
                <g id="viewport">
                  <g id="links-group"></g>
                  <g id="nodes-group"></g>
                </g>
              </svg>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="skills-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">スキル管理</div>
            <div style="font-weight: 700">セットとスキルLv強化</div>
          </div>
          <button id="skills-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div
          class="inline-buttons"
          style="margin-bottom: 6px; align-items: center"
        >
          <div class="pill">スキルP: <span id="skill-points-skill"></span></div>
          <button
            id="skill-step"
            class="step-button"
            aria-label="スキル増減幅を切り替え"
          >
            ±1
          </button>
          <button
            id="reset-skills"
            class="help-icon"
            aria-label="スキルをリセット"
          >
            ↺
          </button>
        </div>
        <div
          class="inline-buttons"
          style="margin-bottom: 6px; align-items: center"
        >
          <button
            id="skill-summary-toggle"
            class="mini-btn"
            aria-pressed="false"
          >
            全職業一覧を表示
          </button>
        </div>
        <div
          class="inline-buttons"
          id="skill-category-tabs"
          style="margin-bottom: 4px"
        ></div>
        <div
          class="inline-buttons"
          id="skill-type-tabs"
          style="margin-bottom: 6px"
        ></div>
        <div id="skill-detail-view">
          <div
            id="active-skill-loadout"
            class="help-panel"
            style="margin-bottom: 6px"
          ></div>
          <div id="skills" style="margin-top: 6px"></div>
        </div>
      </div>
    </div>

    <div
      id="skill-summary-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">全職業スキル一覧</div>
            <div style="font-weight: 700">
              取得レベルと習得状況をまとめて確認
            </div>
          </div>
          <button
            id="skill-summary-close"
            class="modal-close"
            aria-label="閉じる"
          >
            ×
          </button>
        </div>
        <div id="skill-summary-body">
          <div id="skills-summary" style="margin-top: 6px"></div>
        </div>
      </div>
    </div>

    <div
      id="weapon-enhance-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">装備強化</div>
            <div style="font-weight: 700">費用と成功率を確認して強化</div>
          </div>
          <button
            id="weapon-enhance-close"
            class="modal-close"
            aria-label="閉じる"
          >
            ×
          </button>
        </div>
        <div
          id="weapon-enhance-summary"
          class="equipment-option-list"
          style="margin-top: 8px"
        ></div>
        <div class="enhance-actions" id="weapon-enhance-actions"></div>
        <div class="enhance-note" id="weapon-enhance-note"></div>
        <div class="modal-body-title" style="margin-top: 12px">
          次の強化ステップ
        </div>
        <div id="weapon-enhance-table" class="enhance-table"></div>
      </div>
      <div id="weapon-enhance-animation" class="enhance-overlay hidden">
        <div class="enhance-overlay-card">
          <div id="weapon-enhance-animation-icon" class="enhance-overlay-icon">
            🔨
          </div>
          <div
            id="weapon-enhance-animation-title"
            class="enhance-overlay-title"
          >
            鍛冶開始
          </div>
          <div
            id="weapon-enhance-animation-detail"
            class="enhance-overlay-detail"
          ></div>
          <div
            id="weapon-enhance-animation-gain"
            class="enhance-overlay-gain"
          ></div>
          <div class="enhance-overlay-hint">タップでスキップ</div>
        </div>
      </div>
    </div>

    <div
      id="inventory-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content inventory-modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">インベントリ</div>
            <div style="font-weight: 700">所持アイテムの確認</div>
          </div>
          <button id="inventory-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div id="inventory-list" class="stats"></div>
        <div id="inventory-filters" class="inventory-filter-grid"></div>
      </div>
    </div>

    <div
      id="bulk-sell-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">一括売却</div>
            <div id="bulk-sell-filter-label" style="font-weight: 700"></div>
          </div>
          <button id="bulk-sell-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="body" style="margin-top: 6px">
          表示中のカテゴリから、選んだレア度のアイテムを一括売却します。
          装備中・お気に入り登録中のものは対象外です。
        </div>
        <div id="bulk-sell-rarity-list" class="bulk-sell-rarity-list"></div>
        <div id="bulk-sell-summary" class="bulk-sell-summary"></div>
        <button id="bulk-sell-execute" class="primary full">
          一括売却する
        </button>
      </div>
    </div>

    <div
      id="inventory-item-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">アイテム詳細</div>
            <div id="inventory-item-name" style="font-weight: 700"></div>
          </div>
          <button
            id="inventory-item-close"
            class="modal-close"
            aria-label="閉じる"
          >
            ×
          </button>
        </div>
        <div
          id="inventory-item-desc"
          class="body"
          style="margin-top: 6px"
        ></div>
        <div
          id="inventory-item-meta"
          class="subtle"
          style="margin: 8px 0 4px"
        ></div>
        <div
          id="inventory-item-detail"
          class="stats"
          style="
            grid-template-columns: repeat(2, minmax(0, 1fr));
            margin-top: 6px;
          "
        ></div>
        <div
          id="inventory-compare-result"
          class="equipment-option-list"
          style="margin-top: 8px; display: none"
        ></div>
        <div
          id="inventory-item-actions"
          class="inline-buttons"
          style="margin-top: 10px"
        ></div>
      </div>
    </div>

    <div id="codex-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">図鑑</div>
            <div style="font-weight: 700">発見した情報を一覧で確認</div>
          </div>
          <button id="codex-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div id="codex-tabs" class="codex-tabs"></div>
        <div id="codex-list" class="codex-grid"></div>
      </div>
    </div>

    <div
      id="codex-detail-modal"
      class="modal hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">詳細</div>
            <div id="codex-detail-name" style="font-weight: 700"></div>
          </div>
          <button
            id="codex-detail-close"
            class="modal-close"
            aria-label="閉じる"
          >
            ×
          </button>
        </div>
        <div id="codex-detail-body" class="codex-detail-body"></div>
      </div>
    </div>

    <div id="warp-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0">ワープ</div>
            <div style="font-weight: 700">到達済み階層へ移動</div>
          </div>
          <button id="warp-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="help-panel">
          <div class="option-label">現在地</div>
          <div class="option-value">
            <span id="warp-current-floor"></span>F / 最高
            <span id="warp-max-label"></span>F
          </div>
          <div class="warp-note">戦闘開始前の階層に即座に移動します。</div>
        </div>
        <div class="warp-section">
          <div class="option-label">ボス階</div>
          <div id="warp-boss-list" class="warp-boss-list"></div>
        </div>
        <div class="warp-section">
          <div class="option-label">その他</div>
          <button id="warp-max-floor">最大到達階へ</button>
        </div>
      </div>
    </div>

    <div id="debug-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div class="section-title" style="margin: 0">デバッグ</div>
          <button id="debug-close" class="modal-close" aria-label="閉じる">
            ×
          </button>
        </div>
        <div class="debug-tabs">
          <button class="debug-tab-button active" data-tab="status">
            状態異常
          </button>
          <button class="debug-tab-button" data-tab="equipment">
            装備生成
          </button>
          <button class="debug-tab-button" data-tab="adjust">数値</button>
          <button class="debug-tab-button" data-tab="save">セーブ</button>
        </div>
        <div id="debug-tab-status" class="debug-tab-panel">
          <div class="debug-selects">
            <label>
              対象:
              <select id="debug-target">
                <option value="enemy">敵</option>
                <option value="player">プレイヤー</option>
              </select>
            </label>
            <label>
              敵選択:
              <select id="debug-enemy"></select>
            </label>
          </div>
          <div id="debug-status-buttons"></div>
          <div class="modal-actions">
            <button id="debug-clear-status">選択対象の状態異常を全解除</button>
          </div>
        </div>
        <div id="debug-tab-equipment" class="debug-tab-panel hidden">
          <div class="debug-selects">
            <label>
              部位:
              <select id="debug-gear-slot"></select>
            </label>
            <label>
              レア度:
              <select id="debug-gear-rarity"></select>
            </label>
            <label>
              強化値:
              <input
                id="debug-gear-enhance"
                type="number"
                min="0"
                max="21"
                step="1"
                inputmode="numeric"
                value="0"
              />
            </label>
          </div>
          <div id="debug-legendary-wrapper" class="debug-selects hidden">
            <label>
              レジェンド装備:
              <select id="debug-legendary-template"></select>
            </label>
          </div>
          <div id="debug-gear-preview" class="equipment-option-list">
            <div class="option-label">プレビューがここに表示されます</div>
          </div>
          <div class="modal-actions">
            <button id="debug-generate-gear">装備品を作成して追加</button>
            <button id="debug-generate-gear-random">ランダム作成</button>
          </div>
          <div class="debug-section" style="margin-top: 12px">
            <h4>ポーション生成</h4>
            <div class="debug-selects">
              <label>
                種類:
                <select id="debug-potion-template"></select>
              </label>
              <label>
                バリエーション:
                <select id="debug-potion-variant"></select>
              </label>
            </div>
            <div class="debug-selects">
              <label>
                レア度:
                <select id="debug-potion-rarity"></select>
              </label>
              <label>
                装備先:
                <select id="debug-potion-slot"></select>
              </label>
            </div>
            <div
              id="debug-potion-legendary-wrapper"
              class="debug-selects hidden"
            >
              <label>
                レジェンダリーポーション:
                <select id="debug-potion-legendary-template"></select>
              </label>
            </div>
            <div id="debug-potion-preview" class="equipment-option-list">
              <div class="option-label">
                ポーションのプレビューがここに表示されます
              </div>
            </div>
            <div class="modal-actions">
              <button id="debug-generate-potion">
                ポーションを作成して追加
              </button>
              <button id="debug-generate-potion-random">ランダム作成</button>
              <button id="debug-reroll-potion">再生成（プレビューのみ）</button>
            </div>
          </div>
        </div>
        <div id="debug-tab-adjust" class="debug-tab-panel hidden">
          <div class="debug-section">
            <h4>プレイヤー調整</h4>
            <div class="debug-selects">
              <label>
                レベル:
                <input
                  id="debug-level-input"
                  type="number"
                  min="1"
                  step="1"
                  inputmode="numeric"
                />
              </label>
              <button id="debug-apply-level">反映</button>
            </div>
            <div class="debug-selects">
              <label>
                HP:
                <input
                  id="debug-hp-input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                />
              </label>
              <button id="debug-apply-hp">反映</button>
            </div>
            <div class="debug-selects">
              <label>
                所持金:
                <input
                  id="debug-gold-input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                />
              </label>
              <button id="debug-apply-gold">反映</button>
            </div>
          </div>
          <div class="debug-section">
            <h4>階層調整</h4>
            <div class="debug-selects">
              <label>
                階層:
                <input
                  id="debug-floor-input"
                  type="number"
                  min="1"
                  step="1"
                  inputmode="numeric"
                />
              </label>
              <button id="debug-apply-floor">移動</button>
            </div>
            <div class="debug-selects" style="align-items: flex-start">
              <div style="font-size: 12px; color: var(--muted)">
                ボス階直行:
              </div>
              <div class="inline-buttons" style="margin-top: 0">
                <button data-debug-boss-floor="10">10F</button>
                <button data-debug-boss-floor="20">20F</button>
                <button data-debug-boss-floor="30">30F</button>
                <button data-debug-boss-floor="50">50F</button>
                <button data-debug-boss-floor="100">100F</button>
                <button data-debug-boss-floor="200">200F</button>
                <button data-debug-boss-floor="500">500F</button>
                <button data-debug-boss-floor="700">700F</button>
                <button data-debug-boss-floor="1000">1000F</button>
              </div>
            </div>
          </div>
          <div class="debug-section">
            <h4>ドロップ</h4>
            <label class="debug-checkbox">
              <input id="debug-force-legendary" type="checkbox" />
              ボス撃破時にレジェンダリーを必ずドロップ
            </label>
            <div class="subtle">デバッグ専用。再読み込みでオフに戻ります。</div>
          </div>
          <div class="debug-section">
            <h4>自動進行</h4>
            <label class="debug-checkbox">
              <input id="debug-auto-attack" type="checkbox" />
              自動こうげき（こうげきボタン押しっぱなし相当）
            </label>
            <div class="subtle">デバッグ専用。再読み込みでオフに戻ります。</div>
          </div>
          <div class="debug-section">
            <h4>図鑑</h4>
            <label class="debug-checkbox">
              <input id="debug-codex-unlock" type="checkbox" />
              図鑑を全解放
            </label>
            <div class="subtle">
              デバッグ専用。再読み込みでセーブの状態に戻ります。
            </div>
          </div>
          <div class="modal-actions">
            <button id="debug-new-run">新しく始める</button>
          </div>
        </div>
        <div id="debug-tab-save" class="debug-tab-panel hidden">
          <div class="help-panel">
            <div class="option-label">
              冗長セーブ (ローカル保存 + 自動バックアップ)
            </div>
            <div class="option-value">
              各スロットは保存ごとに最新データとバックアップを2重で記録します。
            </div>
          </div>
          <div id="save-slot-list" class="save-slot-list"></div>
          <div class="subtle">
            <span>バックアップは保存時に自動更新</span>
            <span>JSONコピーで手動バックアップも可能</span>
          </div>
        </div>
      </div>
    </div>

    <div
      id="status-popover"
      class="status-popover hidden"
      role="status"
      aria-live="polite"
    >
      <div class="title">
        <span id="status-popover-name"></span>
        <span
          id="status-popover-turns"
          class="pill"
          style="background: rgba(255, 255, 255, 0.08)"
        ></span>
      </div>
      <div id="status-popover-desc" class="body"></div>
      <div id="status-popover-list" class="effect-list"></div>
    </div>

    <script>
      (() => {
        if (window.__HAKUSURA_BOOTED__) return;
        window.__HAKUSURA_BOOTED__ = true;

        const STATUS_DEFINITIONS = {
          stun: {
            name: "スタン",
            short: "STN",
            category: "control",
            description: "行動完全不能（通常攻撃・スキル不可）",
          },
          sleep: {
            name: "睡眠",
            short: "SLP",
            category: "control",
            description: "行動不能。被ダメージで解除 (DoT除く)",
          },
          confusion: {
            name: "混乱",
            short: "CNF",
            category: "control",
            description: "攻撃対象がランダム化。味方を攻撃する可能性も",
          },
          silence: {
            name: "沈黙",
            short: "SIL",
            category: "control",
            description: "スキル使用不可（通常攻撃のみ可能）",
          },
          knockdown: {
            name: "転倒",
            short: "KD",
            category: "control",
            description: "次ターンの行動順が最後になる（行動遅延）",
          },
          seal: {
            name: "封印",
            short: "SEAL",
            category: "control",
            description: "パッシブや常時効果を無効化する",
          },
          bleed: {
            name: "出血",
            short: "BLD",
            category: "dot",
            description: "物理DoT（攻撃力に依存）",
          },
          poison: {
            name: "毒",
            short: "PSN",
            category: "dot",
            description: "固定値 or 最大HP割合のDoT",
          },
          curse: {
            name: "呪い",
            short: "CUR",
            category: "dot",
            description: "与ダメ低下＋小DoT（複合デバフでも可）",
          },
          burn: {
            name: "火傷",
            short: "BRN",
            category: "dot",
            description: "魔法系DoTとして扱う",
          },
          physAttackDown: {
            name: "物理攻撃ダウン",
            short: "PATK↓",
            category: "debuff",
            description: "物理ダメージ係数ダウン",
            potency: 0.2,
          },
          magAttackDown: {
            name: "魔法攻撃ダウン",
            short: "MATK↓",
            category: "debuff",
            description: "魔法ダメージ係数ダウン",
            potency: 0.2,
          },
          physDefenseDown: {
            name: "物理防御ダウン",
            short: "PDEF↓",
            category: "debuff",
            description: "受ける物理ダメージ増加",
            potency: 0.2,
          },
          magDefenseDown: {
            name: "魔法防御ダウン",
            short: "MDEF↓",
            category: "debuff",
            description: "受ける魔法ダメージ増加",
            potency: 0.2,
          },
          accuracyDown: {
            name: "命中率ダウン",
            short: "ACC↓",
            category: "debuff",
            description: "攻撃が当たりにくくなる",
            potency: 0.15,
          },
          evasionDown: {
            name: "回避率ダウン",
            short: "EVA↓",
            category: "debuff",
            description: "攻撃が当たりやすくなる",
            potency: 0.15,
          },
          speedDown: {
            name: "速度ダウン",
            short: "SPD↓",
            category: "debuff",
            description: "行動順が遅くなる／行動頻度減少",
            potency: 0.25,
          },
        };

        const BUFF_DEFINITIONS = {
          guard: {
            name: "防御",
            short: "DEF↑",
            description: "被ダメージを軽減する防御態勢",
          },
          haste: {
            name: "加速",
            short: "HST",
            description: "行動速度が上昇し、行動順が早まる",
          },
          focus: {
            name: "集中",
            short: "FOC",
            description: "会心率と一部効果量が上昇する集中状態",
          },
        };

        const STATUS_CATEGORIES = {
          control: "control",
          dot: "dot",
          debuff: "debuff",
        };

        function generateId(prefix = "id") {
          let uuid;

          // crypto.randomUUID が使える環境ならそのまま呼び出す
          if (
            typeof globalThis !== "undefined" &&
            globalThis.crypto &&
            typeof globalThis.crypto.randomUUID === "function"
          ) {
            uuid = globalThis.crypto.randomUUID();
          } else {
            // フォールバック（簡易ID）
            uuid = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
          }

          return prefix ? `${prefix}-${uuid}` : uuid;
        }

        const POTION_REFILL_ON_KILL = 12;
        const INVENTORY_FILTER_OPTIONS = [
          { key: "all", label: "すべて" },
          { key: "weapon", label: "メイン(武器)" },
          { key: "subWeapon", label: "サブ(武器)" },
          { key: "head", label: "頭" },
          { key: "body", label: "胴" },
          { key: "hands", label: "手" },
          { key: "feet", label: "足" },
          { key: "accessory", label: "装飾品" },
          { key: "items", label: "アイテム" },
          { key: "bulkSell", label: "一括売却" },
          { key: "sort", label: "並び替え" },
        ];
        const INVENTORY_SORT_LABEL = {
          acquire: "入手順",
          rarity: "レア度順",
        };
        let inventoryFilter = "all";
        const BULK_SELL_RARITY_ORDER = [
          "normal",
          "magic",
          "rare",
          "legendary",
        ];
        let bulkSellSelectedRarities = new Set(["normal", "magic"]);
        let dropToastNotificationRarities = new Set(BULK_SELL_RARITY_ORDER);
        let autoSellRarities = new Set();
        let inventorySortMode = "acquire";
        let inventoryAcquireSequence = 0;
        let weaponEnhanceTarget = null;
        let enhanceAnimationState = {
          active: false,
          phase: "idle",
          timers: [],
          pendingOutcome: null,
          completed: false,
        };
        let currentInventorySelection = null;

        const EQUIPMENT_SLOTS = {
          weapon: { label: "メイン(武器)" },
          subWeapon: { label: "サブ(武器)" },
          head: { label: "頭" },
          body: { label: "胴" },
          hands: { label: "手" },
          feet: { label: "足" },
          accessory: { label: "装飾品" },
        };

        const PLAYER_EQUIPMENT_SLOTS = {
          weapon: { label: "メイン(武器)" },
          subWeapon: { label: "サブ(武器)" },
          head: { label: "頭" },
          body: { label: "胴" },
          hands: { label: "手" },
          feet: { label: "足" },
          accessory1: { label: "装飾品1" },
          accessory2: { label: "装飾品2" },
        };

        const EQUIPMENT_RARITIES = {
          normal: {
            key: "normal",
            label: "ノーマル",
            color: "#e5e7eb",
            rank: 0,
            baseOptions: 3,
            randomOptions: 0,
          },
          magic: {
            key: "magic",
            label: "マジック",
            color: "#60a5fa",
            rank: 1,
            baseOptions: 3,
            randomOptions: 2,
          },
          rare: {
            key: "rare",
            label: "レア",
            color: "#fcd34d",
            rank: 2,
            baseOptions: 3,
            randomOptions: 3,
          },
          legendary: {
            key: "legendary",
            label: "レジェンド",
            color: "#b45309",
            rank: 3,
            baseOptions: 5,
            randomOptions: 5,
          },
        };

        const SELL_VALUE_BY_RARITY = {
          normal: 1,
          magic: 10,
          rare: 100,
          legendary: 10000,
        };

        const WEAPON_ENHANCE_PROGRESSION = [
          { from: 0, to: 1, success: 100 },
          { from: 1, to: 2, success: 100 },
          { from: 2, to: 3, success: 100 },
          { from: 3, to: 4, success: 100 },
          { from: 4, to: 5, success: 100 },
          { from: 5, to: 6, success: 90 },
          { from: 6, to: 7, success: 70 },
          { from: 7, to: 8, success: 70 },
          { from: 8, to: 9, success: 50 },
          { from: 9, to: 10, success: 50 },
          { from: 10, to: 11, success: 45 },
          { from: 11, to: 12, success: 45 },
          { from: 12, to: 13, success: 30 },
          { from: 13, to: 14, success: 30 },
          { from: 14, to: 15, success: 7.5 },
          { from: 15, to: 16, success: 7.5 },
          { from: 16, to: 17, success: 5 },
          { from: 17, to: 18, success: 5 },
          { from: 18, to: 19, success: 2 },
          { from: 19, to: 20, success: 2 },
          { from: 20, to: 21, success: 0.01 },
        ];

        const MAX_ENHANCE_LEVEL = WEAPON_ENHANCE_PROGRESSION.reduce(
          (max, step) => Math.max(max, step.to),
          0,
        );

        const WEAPON_ENHANCE_COLORS = [
          { min: 20, color: "#f8fafc" },
          { min: 17, color: "#fbbf24" },
          { min: 15, color: "#fb923c" },
          { min: 13, color: "#f9a8d4" },
          { min: 9, color: "#60a5fa" },
          { min: 7, color: "#facc15" },
          { min: 1, color: "#34d399" },
        ];

        const WEAPON_ENHANCE_POWER_PER_LEVEL = 0.02; // 1段階ごとに+2%補正
        const WEAPON_ENHANCE_BASE_COST = 240;
        const WEAPON_ENHANCE_COST_GROWTH = 1.48;

        const DEBUG_RARITY_OPTIONS = [
          { key: "legendary", label: "レジェンド" },
          { key: "random", label: "ランダム（ノーマル〜レア）" },
        ];

        const DEBUG_POTION_RARITY_OPTIONS = [
          { key: "legendary", label: "レジェンダリー" },
          { key: "rare", label: "レア" },
          { key: "magic", label: "マジック" },
          { key: "normal", label: "ノーマル" },
          { key: "random", label: "ランダム（ノーマル〜レア）" },
        ];

        const NON_LEGENDARY_RARITIES = ["normal", "magic", "rare"];

        const POTION_RARITIES = {
          normal: {
            key: "normal",
            label: "ノーマル",
            color: "#e5e7eb",
            rank: 0,
            amountRange: [0.9, 1.0],
            useCostRange: [0.95, 1.05],
            fullnessRange: [0.9, 1.0],
          },
          magic: {
            key: "magic",
            label: "マジック",
            color: "#60a5fa",
            rank: 1,
            amountRange: [1.05, 1.15],
            useCostRange: [0.85, 0.95],
            fullnessRange: [1.0, 1.1],
          },
          rare: {
            key: "rare",
            label: "レア",
            color: "#fcd34d",
            rank: 2,
            amountRange: [1.2, 1.35],
            useCostRange: [0.7, 0.85],
            fullnessRange: [1.05, 1.2],
          },
          legendary: {
            key: "legendary",
            label: "レジェンダリー",
            color: "#b45309",
            rank: 3,
            amountRange: [1.35, 1.5],
            useCostRange: [0.55, 0.75],
            fullnessRange: [1.1, 1.25],
          },
        };

        const POTION_RARITY_WEIGHTS = [
          { key: "normal", weight: 52 },
          { key: "magic", weight: 33 },
          { key: "rare", weight: 15 },
        ];

        const DROP_ITEM_TYPE_WEIGHTS = [
          { key: "equipment", weight: 70 },
          { key: "potion", weight: 30 },
        ];

        const BOSS_DROP_ITEM_TYPE_WEIGHTS = [
          { key: "equipment", weight: 70 },
          { key: "potion", weight: 30 },
        ];

        const POTION_PREFIXES = {
          general: [
            { key: "condensed", name: "濃縮", effect: "効果量 +20〜30%" },
            { key: "pure", name: "純粋", effect: "効率UP / デメリット軽減" },
            { key: "temporal", name: "時禍", effect: "効果ターン +1" },
            {
              key: "insightful",
              name: "冥視",
              effect: "効果内容を拡張（影響範囲/サブ効果）",
            },
            {
              key: "sanctified",
              name: "聖別",
              effect: "使用時に小バフ or 小シールド",
            },
            { key: "thrifty", name: "倹約", effect: "ポーション消費量 −25%" },
          ],
          recovery: [
            { key: "sacred", name: "神聖", effect: "回復時シールド付与" },
            { key: "soothing", name: "癒気", effect: "回復後に再生バフ" },
            { key: "earthen", name: "地脈", effect: "回復に防御UP付与" },
            {
              key: "blessed",
              name: "恩寵",
              effect: "回復量拡張 / 一時的最大HP上限UP",
            },
            { key: "renewal", name: "再誕", effect: "回復時 状態異常解除" },
          ],
          buff: [
            { key: "fervent", name: "強心", effect: "攻撃系効果強化" },
            { key: "ironbound", name: "鋼守", effect: "防御効果強化" },
            { key: "rush", name: "疾走", effect: "行動速度UP効果強化" },
            { key: "crimson", name: "緋色", effect: "HP低いほど効果増" },
            {
              key: "aggressive",
              name: "猛勢",
              effect: "代償と引き換えに効果増",
            },
          ],
          legendaryGeneral: [
            {
              key: "miraculous",
              name: "奇跡",
              effect: "効果そのものが限界突破（質と威力変換）",
            },
            {
              key: "fatebound",
              name: "運命",
              effect: "ランダムな追加効果が発動",
            },
          ],
          legendaryRecovery: [
            { key: "salvation", name: "救済", effect: "致死回避 / 蘇生系" },
            {
              key: "holyblood",
              name: "聖血",
              effect: "回復値の一部を攻撃またはシールドへ変換",
            },
          ],
          legendaryBuff: [
            {
              key: "overlord",
              name: "狂皇",
              effect: "効果中ターン毎に累積成長",
            },
            {
              key: "judgment",
              name: "断罪",
              effect: "HPが低い敵へ処刑判定を持つ",
            },
          ],
          legendaryCost: [
            {
              key: "zeroTributePrefix",
              name: "零喉",
              effect: "設定消費の −70〜80%軽減（ゼロにならない）",
            },
          ],
        };

        const POTION_SUFFIXES = {
          general: [
            { key: "afterglow", name: "の余韻", effect: "効果延長" },
            { key: "merit", name: "の真価", effect: "終了時 小バフ" },
            { key: "halo", name: "の光環", effect: "終了時 小シールド" },
            { key: "resurgence", name: "の帰還", effect: "終了時 小回復" },
            {
              key: "awakening",
              name: "の覚醒",
              effect: "効果中の撃破で微成長",
            },
            {
              key: "efficiency",
              name: "の節減",
              effect: "次回のポーション消費量 −10%",
            },
            { key: "refill", name: "の再充填", effect: "使用消費の20%を還元" },
          ],
          recovery: [
            { key: "vitalPulse", name: "の鼓動", effect: "終了時HP回復" },
            { key: "purity", name: "の清涼", effect: "MP少量回復" },
            { key: "shelter", name: "の包翼", effect: "回復時に防御UP" },
            {
              key: "guidance",
              name: "の導き",
              effect: "回復量とシールド効果連動",
            },
            { key: "restoration", name: "の慈雨", effect: "回復が二段発生" },
          ],
          buff: [
            { key: "venom", name: "の毒", effect: "終了時HP微減" },
            { key: "echo", name: "の反響", effect: "終了後 小バフ再発動" },
            { key: "pursuit", name: "の追撃", effect: "終了後追加ダメージ" },
            { key: "momentum", name: "の飛翔", effect: "終了後速度UP" },
            { key: "fury", name: "の激昂", effect: "被弾時火力成長" },
          ],
          legendaryGeneral: [
            {
              key: "miracleEcho",
              name: "の奇跡転写",
              effect: "効果が弱化してもう一度発動",
            },
          ],
          legendaryRecovery: [
            {
              key: "blessedReversal",
              name: "の恩寵還元",
              effect: "回復量をシールド化し弱体系無効",
            },
            {
              key: "graceDelegation",
              name: "の代行",
              effect: "戦闘中一回 自動回復が発動",
            },
          ],
          legendaryBuff: [
            {
              key: "finalMastery",
              name: "の極意",
              effect: "同じ行動ほど累積強化",
            },
            {
              key: "executionRite",
              name: "の処断",
              effect: "終了時 最もHP低い敵へ必殺判定",
            },
          ],
          legendaryCost: [
            {
              key: "zeroTributeSuffix",
              name: "の恩寵",
              effect: "このポーションの消費量 −60〜70%",
            },
          ],
        };

        const POTION_BASE_TEMPLATES = {
          hp: {
            key: "hp",
            label: "生命ポーション",
            type: "hp",
            category: "recovery",
            icon: "🧪",
            variants: [
              {
                key: "small",
                label: "(小)",
                short: "HP小",
                amount: 24,
                useCost: 30,
                maxFullness: 100,
              },
              {
                key: "medium",
                label: "(中)",
                short: "HP中",
                amount: 45,
                useCost: 38,
                maxFullness: 100,
              },
              {
                key: "large",
                label: "(大)",
                short: "HP大",
                amount: 80,
                useCost: 55,
                maxFullness: 100,
              },
            ],
          },
          mp: {
            key: "mp",
            label: "魔力ポーション",
            type: "mp",
            category: "recovery",
            icon: "🔮",
            variants: [
              {
                key: "small",
                label: "(小)",
                short: "MP小",
                amount: 20,
                useCost: 28,
                maxFullness: 100,
              },
              {
                key: "medium",
                label: "(中)",
                short: "MP中",
                amount: 40,
                useCost: 36,
                maxFullness: 100,
              },
              {
                key: "large",
                label: "(大)",
                short: "MP大",
                amount: 70,
                useCost: 50,
                maxFullness: 100,
              },
            ],
          },
          berserker: {
            key: "berserker",
            label: "狂戦士薬",
            type: "buff",
            category: "buff",
            icon: "💢",
            summary: "攻撃上昇と代償を伴う短期決戦用バフ",
            variants: [
              {
                key: "standard",
                label: "",
                short: "狂戦士",
                amount: 32,
                useCost: 36,
                maxFullness: 100,
                duration: 3,
                penalty: 18,
                buildEffectText: (values, { variant }) =>
                  `${variant.duration}ターン 攻撃+${values.amount}% / 被ダメ+${variant.penalty}%`,
              },
            ],
          },
          haste: {
            key: "haste",
            label: "疾走薬",
            type: "buff",
            category: "buff",
            icon: "💨",
            summary: "行動速度とCT短縮を上げる機動戦バフ",
            variants: [
              {
                key: "standard",
                label: "",
                short: "疾走",
                amount: 26,
                useCost: 32,
                maxFullness: 100,
                duration: 3,
                buildEffectText: (values, { variant }) => {
                  const ctReduction = Math.max(
                    8,
                    Math.round(values.amount * 0.6),
                  );
                  return `${variant.duration}ターン 行動速度+${values.amount}% / スキルCT-${ctReduction}%`;
                },
              },
            ],
          },
          bulwark: {
            key: "bulwark",
            label: "鋼守の薬",
            type: "buff",
            category: "buff",
            icon: "🛡️",
            summary: "被ダメ軽減とバリア付与で粘る防御バフ",
            variants: [
              {
                key: "standard",
                label: "",
                short: "鋼守",
                amount: 28,
                useCost: 34,
                maxFullness: 100,
                duration: 3,
                buildEffectText: (values, { variant }) => {
                  const barrier = Math.round(values.amount * 3.2);
                  return `${variant.duration}ターン 被ダメ-${values.amount}% / バリア+${barrier}`;
                },
              },
            ],
          },
        };

        const LEGENDARY_POTIONS = [
          {
            key: "phoenixCryst",
            name: "フェニックス血晶",
            category: "recovery",
            type: "hp",
            icon: "🔥",
            summary:
              "この戦闘中一度だけ戦闘不能を無効化し、HP50%で復活し直後1ターン無敵",
            tagline: "絶対死なない保険",
          },
          {
            key: "herosLegacy",
            name: "英雄の遺酒",
            category: "recovery",
            type: "hybrid",
            icon: "⚔️",
            summary:
              "HP/MP即時全回復＋3ターン回復量+200%、撃破時に攻撃/防御/速度が成長",
            tagline: "勝つための回復 × 成長",
          },
          {
            key: "pactOfSalvation",
            name: "救済の契約酒",
            category: "recovery",
            type: "hybrid",
            icon: "📜",
            summary: "即時全回復＆2ターン無敵。終了後は最大HP-20% (戦闘中のみ)",
            tagline: "一度だけの切り札",
          },
          {
            key: "sanctuaryChalice",
            name: "聖域の祝杯",
            category: "recovery",
            type: "hybrid",
            icon: "🛡️",
            summary: "全回復＋3ターン状態異常完全無効",
            tagline: "状態異常・デバフ支配",
          },
          {
            key: "zealChalice",
            name: "狂信者の盃",
            category: "buff",
            type: "buff",
            icon: "💢",
            summary: "2ターン与ダメ+120% / 被ダメ+40%、撃破毎に攻撃+10% 永続",
            tagline: "倒すほど伸びる",
          },
          {
            key: "judgementBrew",
            name: "断罪の符酒",
            category: "buff",
            type: "buff",
            icon: "🎯",
            summary:
              "次の3回攻撃が確定クリティカル＋防御貫通と固定ダメージを付与",
            tagline: "確実に前進",
          },
          {
            key: "aegisBlackForge",
            name: "黒鉄の祈酒",
            category: "buff",
            type: "buff",
            icon: "🛡️",
            summary: "3ターン防御強化＆被ダメ-60%、初撃無効、攻撃-25%",
            tagline: "極限防御",
          },
          {
            key: "shadowcloneAmbrosia",
            name: "千の影の蜜",
            category: "buff",
            type: "buff",
            icon: "🌀",
            summary: "次の3回被弾時に攻撃無効化＋反撃（クリ率優遇）",
            tagline: "受けて攻める",
          },
        ];

        const BASE_DROP_CHANCE = 40;
        const BOSS_DROP_BONUS = 18;
        const DROP_RARITY_WEIGHTS = [
          { key: "normal", weight: 55 },
          { key: "magic", weight: 32 },
          { key: "rare", weight: 13 },
        ];
        const BOSS_DROP_RARITY_WEIGHTS = [
          { key: "normal", weight: 38 },
          { key: "magic", weight: 40 },
          { key: "rare", weight: 22 },
        ];
        const BOSS_FLOORS = [10, 20, 30, 50, 100, 200, 500, 700, 1000];
        const BOSS_DEFINITIONS = {
          10: {
            name: "灰翼の斥候アエロー", // 敏捷特化のスカウトタイプ
            flavor: "灰色の翼で舞い、毒煙を撒く素早い偵察者。",
            modifiers: {
              spd: 1.1,
              evade: 1.15,
              accuracy: 1.05,
              resist: { control: 1.05 },
            },
            legendaryKey: "aeroScoutMantle",
          },
          20: {
            name: "氷蔦の主セレスティア", // 冷気と足止め
            flavor: "氷の蔦で足元を絡め取り、冷気を纏う森の支配者。",
            modifiers: {
              def: 1.12,
              hp: 1.12,
              spd: 1.05,
              resist: { control: 1.1, dot: 1.05 },
            },
            legendaryKey: "celestiaFrostbrand",
          },
          30: {
            name: "砂紋の狩人ザラフ", // 命中阻害と継続削り
            flavor: "砂嵐に紛れて矢雨を放つ狡猾なハンター。",
            modifiers: {
              atk: 1.16,
              accuracy: 1.12,
              evade: 1.08,
              resist: { debuff: 1.05 },
            },
            legendaryKey: "zharafSandmask",
          },
          50: {
            name: "宝守竜グランフォス", // 防御とシールド
            flavor: "金貨を抱えた巨竜。身を覆う結界で粘り強く守る。",
            modifiers: {
              hp: 1.3,
              def: 1.15,
              resist: { debuff: 1.2, dot: 1.15 },
            },
            legendaryKey: "granphosAurumGauntlet",
          },
          100: {
            name: "燼滅王イグニシオ", // 火炎特化
            flavor: "燃え盛る王冠を戴く焔の暴君。攻撃のたび焦熱を残す。",
            modifiers: {
              atk: 1.25,
              hp: 1.15,
              accuracy: 1.1,
              resist: { control: 1.1 },
            },
            legendaryKey: "ignisioCinderOrb",
          },
          200: {
            name: "深渦の奏者リヴァン", // 魔力波
            flavor: "水柱を操る竜人の楽師。リズムに合わせて魔力が高鳴る。",
            modifiers: {
              atk: 1.2,
              spd: 1.05,
              evade: 1.05,
              resist: { control: 1.15, dot: 1.05 },
            },
            legendaryKey: "rivanTideGlyph",
          },
          500: {
            name: "虚星の審問官オルド", // 闇・デバフ
            flavor: "星を喰らう審問官。魔眼で弱点を暴き、命を削る。",
            modifiers: {
              atk: 1.28,
              accuracy: 1.15,
              resist: { debuff: 1.25, control: 1.2 },
            },
            legendaryKey: "ordoVoidstride",
          },
          700: {
            name: "雷礫の戦神ガロルド", // 連撃と速度
            flavor: "雷鎚を振るう戦神。大地を砕きながら連撃を叩き込む。",
            modifiers: { atk: 1.35, spd: 1.15, hp: 1.12, resist: { dot: 1.1 } },
            legendaryKey: "garoldThunderplate",
          },
          1000: {
            name: "黎明竜フェンラディア", // 最終ボス
            flavor: "夜明けの光を纏う古竜。すべての属性を操り、終焉を告げる。",
            modifiers: {
              atk: 1.4,
              hp: 1.35,
              def: 1.2,
              accuracy: 1.2,
              resist: { control: 1.25, dot: 1.2 },
            },
            legendaryKey: "fenradiaDawnbreaker",
          },
        };

        const BOSS_SKILLS = {
          10: {
            name: "毒翼の奇襲",
            cooldown: 3,
            description: "高速突撃+毒と速度低下をばら撒く",
            action: () => {
              const effects = [];
              if (applyStatus(player, "poison", { duration: 3, chance: 75 })) {
                effects.push("毒付与");
              }
              if (
                applyStatus(player, "speedDown", { duration: 2, chance: 60 })
              ) {
                effects.push("速度低下");
              }
              return { message: effects.join(" / ") || "毒煙をまとって急襲" };
            },
          },
          20: {
            name: "氷霧の緊縛",
            cooldown: 3,
            description: "速度低下と短時間の行動不能を狙う冷気",
            action: () => {
              const effects = [];
              if (
                applyStatus(player, "speedDown", {
                  duration: 2,
                  chance: 75,
                  potency: 0.28,
                })
              ) {
                effects.push("鈍化");
              }
              if (applyStatus(player, "stun", { duration: 1, chance: 40 })) {
                effects.push("凍結足止め");
              }
              return { message: effects.join(" / ") || "冷気で足元を縛る" };
            },
          },
          30: {
            name: "砂塵の矢雨",
            cooldown: 3,
            description: "命中率を奪いつつ出血を狙う矢の連射",
            action: () => {
              const effects = [];
              if (
                applyStatus(player, "accuracyDown", {
                  duration: 3,
                  chance: 75,
                  potency: 0.2,
                })
              ) {
                effects.push("命中低下");
              }
              if (applyStatus(player, "bleed", { duration: 3, chance: 65 })) {
                effects.push("出血");
              }
              return { message: effects.join(" / ") || "砂煙に紛れて射抜く" };
            },
          },
          50: {
            name: "黄金の護膜",
            cooldown: 4,
            description: "自己回復しつつ物理攻撃を鈍らせる",
            action: (enemy) => {
              const healed = Math.min(
                Math.round(enemy.maxHp * 0.12),
                enemy.maxHp - enemy.hp,
              );
              const healedAmount = applyHealing(enemy, healed);
              const debuffed = applyStatus(player, "physAttackDown", {
                duration: 3,
                chance: 70,
                potency: 0.22,
              });
              const effects = [];
              if (healedAmount > 0) effects.push(`自己回復+${healedAmount}`);
              if (debuffed) effects.push("物理攻撃低下");
              return { message: effects.join(" / ") || "鱗を硬化させた" };
            },
          },
          100: {
            name: "焦熱の波動",
            cooldown: 3,
            description: "火傷と魔法防御低下を与える灼熱波",
            action: () => {
              const effects = [];
              if (applyStatus(player, "burn", { duration: 3, chance: 80 })) {
                effects.push("火傷");
              }
              if (
                applyStatus(player, "magDefenseDown", {
                  duration: 3,
                  chance: 70,
                  potency: 0.22,
                })
              ) {
                effects.push("魔防低下");
              }
              return { message: effects.join(" / ") || "灼熱の気配" };
            },
          },
          200: {
            name: "深渦の律動",
            cooldown: 3,
            description: "速度低下と短時間の眠りを誘う波動",
            action: () => {
              const effects = [];
              if (
                applyStatus(player, "speedDown", {
                  duration: 2,
                  chance: 70,
                  potency: 0.3,
                })
              ) {
                effects.push("鈍化");
              }
              if (applyStatus(player, "sleep", { duration: 1, chance: 35 })) {
                effects.push("一瞬の眠り");
              }
              return { message: effects.join(" / ") || "潮のうねりを溜め込む" };
            },
          },
          500: {
            name: "虚星の審問",
            cooldown: 4,
            description: "呪いと沈黙で弱体化させる暗黒審問",
            action: () => {
              const effects = [];
              if (
                applyStatus(player, "curse", {
                  duration: 3,
                  chance: 100,
                  potency: 0.14,
                })
              ) {
                effects.push("呪縛");
              }
              if (applyStatus(player, "silence", { duration: 2, chance: 50 })) {
                effects.push("沈黙");
              }
              return { message: effects.join(" / ") || "魔眼が光を放つ" };
            },
          },
          700: {
            name: "雷礫の連鎖",
            cooldown: 3,
            description: "追撃とスタンを伴う雷撃連鎖",
            action: (enemy) => {
              const effects = ["追撃+1"];
              const baseAttacks = Math.max(
                0,
                Math.floor(enemy.attacksRemaining ?? enemy.attackCount ?? 1),
              );
              enemy.attacksRemaining = baseAttacks + 1;
              if (applyStatus(player, "stun", { duration: 1, chance: 45 })) {
                effects.push("感電スタン");
              }
              return { message: effects.join(" / "), extraAttacks: 0 };
            },
          },
          1000: {
            name: "黎明の終焉",
            cooldown: 2,
            description: "焼灼・呪詛・行動遅延をまとめて叩き込む",
            action: () => {
              const effects = [];
              if (applyStatus(player, "burn", { duration: 3, chance: 75 }))
                effects.push("焼灼");
              if (
                applyStatus(player, "curse", {
                  duration: 3,
                  chance: 100,
                  potency: 0.18,
                })
              )
                effects.push("終焉の呪詛");
              if (applyStatus(player, "knockdown", { duration: 1, chance: 60 }))
                effects.push("行動遅延");
              if (applyStatus(player, "silence", { duration: 1, chance: 50 }))
                effects.push("静寂");
              return { message: effects.join(" / ") || "光が収束する" };
            },
          },
        };

        const BOSS_LEGENDARY_POTIONS = {
          50: ["phoenixCryst", "zealChalice"],
          100: ["herosLegacy", "judgementBrew"],
          200: ["pactOfSalvation", "aegisBlackForge"],
          500: ["sanctuaryChalice", "shadowcloneAmbrosia"],
        };

        const ARCHETYPE_RANK_WEIGHTS = [
          { rank: 1, weight: 55 },
          { rank: 2, weight: 30 },
          { rank: 3, weight: 15 },
        ];

        const ARCHETYPE_STATUS_ON_HIT = {
          venom: {
            status: "poison",
            minRank: 2,
            baseChance: 30,
            rankBonus: 10,
            duration: 3,
            label: "毒牙の猛毒",
          },
          plague: {
            status: "curse",
            minRank: 2,
            baseChance: 24,
            rankBonus: 9,
            duration: 3,
            potency: 0.12,
            label: "瘴疫の呪詛",
          },
          pyre: {
            status: "burn",
            minRank: 2,
            baseChance: 28,
            rankBonus: 8,
            duration: 2,
            label: "焔輪の灼熱",
          },
          frost: {
            status: "speedDown",
            minRank: 2,
            baseChance: 26,
            rankBonus: 8,
            duration: 2,
            potency: 0.3,
            label: "凍霜の冷気",
          },
          dread: {
            status: "stun",
            minRank: 3,
            baseChance: 22,
            rankBonus: 6,
            duration: 1,
            label: "戦慄の硬直",
          },
        };

        const ENEMY_VARIANTS = [
          {
            key: "brute",
            label: "剛腕",
            tagLabels: ["剛腕", "豪槌", "覇鎚"],
            rankLabels: ["剛腕の徒", "剛腕の豪傑", "剛腕の覇鎚"],
            description: "単純だが痛い一撃を振り下ろす。",
            weight: 3,
            minFloor: 1,
            baseModifiers: { atk: 1.1, hp: 1.05, def: 0.98 },
            abilities: [
              {
                label: "粉砕打ち", 
                modifiers: { atk: 1.08, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 4 },
              },
              { 
                label: "激昂",
                modifiers: { attackCountBonus: 1, hp: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 4 },
              },
              {
                label: "強奪",
                modifiers: { atk: 1.05, hp: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 4 },
              },
            ],
          },
          {
            key: "bulwark",
            label: "重甲",
            tagLabels: ["重甲", "巨壁", "堅城"],
            rankLabels: ["重甲の守り手", "重甲の城壁", "重甲の要塞"],
            description: "硬い外殻で攻撃をいなし、じわじわ迫る。",
            weight: 2,
            minFloor: 5,
            baseModifiers: { def: 1.4, hp: 1.18, spd: 0.9 },
            abilities: [
              {
                label: "鉄壁",
                modifiers: { def: 1.15, hp: 1.08 } ,
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
              {
                label: "頑健",
                modifiers: { resist: { debuff: 1.12, dot: 1.12 }, def: 1.08 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
              {
                label: "宝殻",
                modifiers: { def: 1.07, hp: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "skirmisher",
            label: "疾走",
            tagLabels: ["疾走", "影刃", "迅雷"],
            rankLabels: ["疾走の斥候", "疾走の影刃", "疾走の迅雷"],
            description: "素早く間合いを詰め、ヒット＆アウェイを狙う。",
            weight: 2,
            minFloor: 15,
            baseModifiers: { spd: 1.32, evade: 1.14, def: 0.92, atk: 1.08 },
            abilities: [
              {
                label: "踏み込み",
                modifiers: { accuracy: 1.08, atk: 1.08 } ,
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
              {
                label: "二連斬",
                modifiers: { attackCountBonus: 1 } ,
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
              {
                label: "奇襲者",
                modifiers: { spd: 1.05, evade: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "hexer",
            label: "呪詠",
            tagLabels: ["呪詠", "典礼", "導師"],
            rankLabels: ["呪詠の徒", "呪詠の典礼師", "呪詠の大導師"],
            description: "呪気をまとい、異常耐性がやや高い。",
            weight: 1,
            minFloor: 30,
            baseModifiers: {
              atk: 1.12,
              def: 0.96,
              resist: { control: 1.12, dot: 1.12, debuff: 1.12 },
            },
            abilities: [
              {
                label: "穢れの紋",
                modifiers: { hp: 1.06, atk: 1.08 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 6 },
              },
              {
                label: "呪文連鎖",
                modifiers: { attackCountBonus: 1, spd: 1.05 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 6 },
              },
              {
                label: "魔染の贈り物",
                modifiers: { atk: 1.05, resist: { debuff: 1.08 } },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "berserker",
            label: "狂戦",
            tagLabels: ["狂戦", "猛撃", "暴帝"],
            rankLabels: ["狂戦の鬨", "狂戦の猛者", "狂戦の暴帝"],
            description: "手数で押す荒ぶる敵。防御はやや薄い。",
            weight: 1,
            minFloor: 50,
            baseModifiers: {
              atk: 1.12,
              def: 0.92,
              hp: 0.97,
              attackCountBonus: 1,
            },
            abilities: [
              {
                label: "血煙",
                modifiers: { atk: 1.08, spd: 1.08 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "乱撃",
                modifiers: { attackCountBonus: 1, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "血染めの戦利品",
                modifiers: { atk: 1.06, spd: 1.03 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "frost",
            label: "凍霜",
            tagLabels: ["凍霜", "氷鎧", "永劫氷"],
            rankLabels: ["凍霜の徒", "凍霜の守人", "凍霜の永劫"],
            description: "冷気で身を固め、命中と耐久を底上げする。",
            weight: 2,
            minFloor: 12,
            baseModifiers: { def: 1.16, hp: 1.08, accuracy: 1.05, spd: 0.94 },
            abilities: [
              {
                label: "冷気の膜",
                modifiers: { def: 1.08, debuffResist: 1.08 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 4 },
              },
              {
                label: "凍てつく吐息",
                modifiers: { resist: { control: 1.12, dot: 1.08 }, atk: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 4 },
              },
              {
                label: "霜宝",
                modifiers: { def: 1.05, hp: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 4 },
              },
            ],
          },
          {
            key: "zephyr",
            label: "風迅",
            tagLabels: ["風迅", "風刃", "颶風"],
            rankLabels: ["風迅の斥候", "風迅の斬将", "風迅の颶風"],
            description: "風のように立ち回り、回避と速度に秀でる。",
            weight: 2,
            minFloor: 18,
            baseModifiers: { spd: 1.22, evade: 1.18, atk: 1.04, def: 0.94 },
            abilities: [
              {
                label: "疾風脚",
                modifiers: { spd: 1.08, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 6 },
              },
              {
                label: "舞い散る刃",
                modifiers: { attackCountBonus: 1, critRate: 1.05 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 6 },
              },
              {
                label: "風鳴りの残滓",
                modifiers: { spd: 1.06, evade: 1.05 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "arcanist",
            label: "秘呪",
            tagLabels: ["秘呪", "秘儀", "禁呪"],
            rankLabels: ["秘呪の徒", "秘呪の典匠", "秘呪の大禁術士"],
            description: "魔力を操り、攻撃と抵抗を底上げする。",
            weight: 1,
            minFloor: 25,
            baseModifiers: {
              atk: 1.15,
              magAtk: 1.12,
              resist: { debuff: 1.08 },
              def: 0.95,
            },
            abilities: [
              {
                label: "魔符",
                modifiers: { magPen: 1.08, accuracy: 1.06 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "秘奥連携",
                modifiers: { attackCountBonus: 1, spd: 1.04 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "禁呪の供物",
                modifiers: { accuracy: 1.06, spd: 1.03 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "plague",
            label: "瘴疫",
            tagLabels: ["瘴疫", "疫霧", "疫王"],
            rankLabels: ["瘴疫の徒", "瘴疫の巫", "瘴疫の王"],
            description: "毒と呪詛で蝕む。DoT耐性が高い。",
            weight: 1,
            minFloor: 32,
            baseModifiers: {
              resist: { dot: 1.18, debuff: 1.12 },
              atk: 1.08,
              def: 0.96,
            },
            abilities: [
              {
                label: "瘴気",
                modifiers: { hp: 1.06, atk: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "疫の波",
                modifiers: { attackCountBonus: 1, resist: { dot: 1.12 } },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "瘴財",
                modifiers: { atk: 1.05, resist: { dot: 1.1 } },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "warden",
            label: "監視",
            tagLabels: ["監視", "守視", "監王"],
            rankLabels: ["監視の歩哨", "監視の守視", "監視の王座"],
            description: "崩れない守りで味方を守るかのように立ち塞がる。",
            weight: 2,
            minFloor: 28,
            baseModifiers: { def: 1.24, hp: 1.15, spd: 0.9 },
            abilities: [
              {
                label: "堅瞳",
                modifiers: { accuracy: 1.05, debuffResist: 1.1 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "守備陣形",
                modifiers: { def: 1.12, damageReduction: 1.06 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "警邏の徴",
                modifiers: { def: 1.06, resist: { control: 1.05 } },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "shadow",
            label: "影潜",
            tagLabels: ["影潜", "闇刃", "無影"],
            rankLabels: ["影潜の徒", "影潜の暗刃", "影潜の無影"],
            description: "影に紛れ命中と回避を高める。",
            weight: 2,
            minFloor: 20,
            baseModifiers: {
              evade: 1.16,
              accuracy: 1.08,
              atk: 1.06,
              def: 0.94,
            },
            abilities: [
              {
                label: "闇歩き",
                modifiers: { spd: 1.06, evade: 1.08 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 4 },
              },
              {
                label: "暗殺刃",
                modifiers: { critRate: 1.06, attackCountBonus: 1 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 4 },
              },
              {
                label: "影の略奪",
                modifiers: { evade: 1.07, spd: 1.03 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 4 },
              },
            ],
          },
          {
            key: "charger",
            label: "突駆",
            tagLabels: ["突駆", "轟突", "地響"],
            rankLabels: ["突駆の歩兵", "突駆の猛進", "突駆の地響"],
            description: "突進力で一気に距離を詰める。速度と攻撃に優れる。",
            weight: 2,
            minFloor: 10,
            baseModifiers: { spd: 1.18, atk: 1.1, accuracy: 1.04, def: 0.92 },
            abilities: [
              {
                label: "体当たり",
                modifiers: { atk: 1.06, damageReduction: 1.04 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 5 },
              },
              {
                label: "猛進",
                modifiers: { attackCountBonus: 1, spd: 1.04 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 5 },
              },
              {
                label: "略奪",
                modifiers: { atk: 1.05, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 4, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "tempest",
            label: "雷渦",
            tagLabels: ["雷渦", "雷轟", "雷帝"],
            rankLabels: ["雷渦の徒", "雷渦の轟", "雷渦の帝"],
            description: "雷光の加護で攻撃と速度を高める。",
            weight: 1,
            minFloor: 35,
            baseModifiers: { atk: 1.16, spd: 1.14, accuracy: 1.05, def: 0.93 },
            abilities: [
              {
                label: "電撃",
                modifiers: { atk: 1.08, magAtk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "雷迅",
                modifiers: { attackCountBonus: 1, spd: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "雷冠",
                modifiers: { spd: 1.05, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "geomancer",
            label: "土紋",
            tagLabels: ["土紋", "岩鞴", "震域"],
            rankLabels: ["土紋の徒", "土紋の守", "土紋の震域"],
            description: "大地の加護で頑強。状態異常への抵抗も高い。",
            weight: 2,
            minFloor: 22,
            baseModifiers: {
              def: 1.2,
              hp: 1.12,
              resist: { control: 1.08 },
              spd: 0.92,
            },
            abilities: [
              {
                label: "岩甲",
                modifiers: { def: 1.1, damageReduction: 1.05 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "震脚",
                modifiers: { attackCountBonus: 1, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "地脈の宝",
                modifiers: { hp: 1.05, def: 1.05 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "juggernaut",
            label: "破城",
            tagLabels: ["破城", "城砕", "城滅"],
            rankLabels: ["破城の徒", "破城の豪傑", "破城の滅砕"],
            description: "重い一撃で防壁を破壊する。防御貫通に秀でる。",
            weight: 1,
            minFloor: 40,
            baseModifiers: {
              atk: 1.18,
              accuracy: 1.06,
              def: 0.98,
              magPen: 1.06,
            },
            abilities: [
              {
                label: "城砕き",
                modifiers: { atk: 1.1, physPen: 1.08 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
              {
                label: "強行軍",
                modifiers: { attackCountBonus: 1, hp: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
              {
                label: "略奪の旗",
                modifiers: { atk: 1.07, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "phantom",
            label: "幻影",
            tagLabels: ["幻影", "蜃気", "幻王"],
            rankLabels: ["幻影の徒", "幻影の術者", "幻影の王"],
            description: "幻惑で被弾を避け、命中を高める。",
            weight: 2,
            minFloor: 30,
            baseModifiers: { evade: 1.2, accuracy: 1.08, def: 0.92, hp: 1.02 },
            abilities: [
              {
                label: "蜃気楼",
                modifiers: { evade: 1.08, debuffResist: 1.06 },
              },
              {
                label: "幻撃",
                modifiers: { attackCountBonus: 1, atk: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "幻宝",
                modifiers: { evade: 1.07, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "venom",
            label: "毒牙",
            tagLabels: ["毒牙", "毒蛇", "毒皇"],
            rankLabels: ["毒牙の徒", "毒牙の蛇将", "毒牙の皇"],
            description: "毒を仕込み、持続的な痛手を与える。",
            weight: 2,
            minFloor: 16,
            baseModifiers: {
              atk: 1.08,
              accuracy: 1.05,
              resist: { dot: 1.1 },
              def: 0.95,
            },
            abilities: [
              {
                label: "猛毒",
                modifiers: { atk: 1.06, magAtk: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "毒の連牙",
                modifiers: { attackCountBonus: 1, critRate: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "蛇毒の遺物",
                modifiers: { atk: 1.05, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "radiant",
            label: "光冠",
            tagLabels: ["光冠", "光翼", "燦耀"],
            rankLabels: ["光冠の徒", "光冠の翼", "光冠の燦耀"],
            description: "光の加護で命中と抵抗を高める。",
            weight: 1,
            minFloor: 45,
            baseModifiers: {
              accuracy: 1.12,
              resist: { debuff: 1.12, control: 1.08 },
              def: 1.04,
            },
            abilities: [
              {
                label: "輝盾",
                modifiers: { def: 1.08, damageReduction: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "光翼",
                modifiers: { spd: 1.06, evade: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "光宝",
                modifiers: { accuracy: 1.07, resist: { debuff: 1.08 } },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "abyss",
            label: "深淵",
            tagLabels: ["深淵", "奈落", "無明"],
            rankLabels: ["深淵の徒", "深淵の導者", "深淵の王"],
            description: "闇に包まれ、抵抗と魔力を高める。",
            weight: 1,
            minFloor: 52,
            baseModifiers: {
              magAtk: 1.14,
              resist: { control: 1.14, debuff: 1.12 },
              def: 1.02,
            },
            abilities: [
              {
                label: "闇纏い",
                modifiers: { evade: 1.06, debuffResist: 1.1 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "奈落の眼",
                modifiers: { accuracy: 1.06, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "深淵の遺物",
                modifiers: { atk: 1.05, resist: { control: 1.08 } },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "immortal",
            label: "不滅",
            tagLabels: ["不滅", "不朽", "不死王"],
            rankLabels: ["不滅の徒", "不滅の守", "不滅の王"],
            description: "しぶとく耐え、持久力に優れる。",
            weight: 1,
            minFloor: 60,
            baseModifiers: {
              hp: 1.24,
              def: 1.14,
              resist: { dot: 1.14 },
              spd: 0.9,
            },
            abilities: [
              {
                label: "永劫の肉体",
                modifiers: { hp: 1.08, hpRegen: 1.06 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 7 },
              },
              {
                label: "不死性",
                modifiers: { resist: { control: 1.08 }, damageReduction: 1.05 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 7 },
              },
              {
                label: "不滅の財",
                modifiers: { hp: 1.08, def: 1.06 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "pyre",
            label: "焔輪",
            tagLabels: ["焔輪", "炎禍", "炎帝"],
            rankLabels: ["焔輪の徒", "焔輪の使い", "焔輪の炎帝"],
            description: "火炎を纏い、攻撃と魔攻を底上げする。",
            weight: 2,
            minFloor: 14,
            baseModifiers: { atk: 1.12, magAtk: 1.1, def: 0.96, spd: 1.02 },
            abilities: [
              {
                label: "灼熱",
                modifiers: { atk: 1.06, magAtk: 1.06 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
              {
                label: "燃え盛る連鎖",
                modifiers: { attackCountBonus: 1, critRate: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
              {
                label: "紅蓮の遺宝",
                modifiers: { atk: 1.06, spd: 1.03 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "dread",
            label: "戦慄",
            tagLabels: ["戦慄", "恐刃", "恐王"],
            rankLabels: ["戦慄の徒", "戦慄の恐刃", "戦慄の王"],
            description: "恐怖を振りまき、命中と抵抗を高める。",
            weight: 1,
            minFloor: 42,
            baseModifiers: {
              accuracy: 1.1,
              atk: 1.08,
              resist: { control: 1.1 },
              def: 0.98,
            },
            abilities: [
              {
                label: "怯ませ",
                modifiers: { accuracy: 1.06, debuffResist: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "恐刃連撃",
                modifiers: { attackCountBonus: 1, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "恐怖の戦利",
                modifiers: { accuracy: 1.06, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "stonegaze",
            label: "石瞳",
            tagLabels: ["石瞳", "石化", "石帝"],
            rankLabels: ["石瞳の徒", "石瞳の凝視", "石瞳の帝"],
            description: "凝視で相手を鈍らせ、守りを固める。",
            weight: 2,
            minFloor: 24,
            baseModifiers: { def: 1.18, hp: 1.1, accuracy: 1.04, spd: 0.92 },
            abilities: [
              {
                label: "石皮",
                modifiers: { def: 1.08, damageReduction: 1.05 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "凝視",
                modifiers: { resist: { control: 1.08 }, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "石像の財",
                modifiers: { def: 1.07, accuracy: 1.03 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "reaver",
            label: "刈手",
            tagLabels: ["刈手", "刈鎌", "刈帝"],
            rankLabels: ["刈手の徒", "刈手の殺鎌", "刈手の帝"],
            description: "斬撃に長け、クリティカルを狙う。",
            weight: 2,
            minFloor: 26,
            baseModifiers: { atk: 1.14, critRate: 1.12, def: 0.94, spd: 1.02 },
            abilities: [
              {
                label: "刈り払い",
                modifiers: { atk: 1.08, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "血の刈取り",
                modifiers: { attackCountBonus: 1, lifeSteal: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "刈り取った戦利",
                modifiers: { atk: 1.07, spd: 1.03 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "aurora",
            label: "極光",
            tagLabels: ["極光", "光霧", "極冠"],
            rankLabels: ["極光の徒", "極光の霧", "極光の冠"],
            description: "霧光をまとい、回避と抵抗を高める。",
            weight: 1,
            minFloor: 55,
            baseModifiers: {
              evade: 1.16,
              debuffResist: 1.12,
              def: 1.02,
              spd: 1.02,
            },
            abilities: [
              {
                label: "光幕",
                modifiers: { evade: 1.08, damageReduction: 1.04 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
              {
                label: "光刃",
                modifiers: { attackCountBonus: 1, accuracy: 1.06 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
              {
                label: "極光の遺宝",
                modifiers: { evade: 1.06, resist: { debuff: 1.08 } },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "eclipse",
            label: "蝕影",
            tagLabels: ["蝕影", "蝕刃", "黒蝕"],
            rankLabels: ["蝕影の徒", "蝕影の刃", "蝕影の黒蝕"],
            description: "日蝕の影のように攻守を反転させる巧みさを持つ。",
            weight: 1,
            minFloor: 48,
            baseModifiers: {
              atk: 1.1,
              magAtk: 1.08,
              resist: { control: 1.1 },
              def: 0.96,
            },
            abilities: [
              {
                label: "陰の障壁",
                modifiers: { debuffResist: 1.1, def: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "蝕刃",
                modifiers: { attackCountBonus: 1, critRate: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "蝕影の財",
                modifiers: { accuracy: 1.05, spd: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "tideborn",
            label: "潮生",
            tagLabels: ["潮生", "波骸", "潮王"],
            rankLabels: ["潮生の徒", "潮生の波", "潮生の王"],
            description: "潮のうねりを力に変え、耐久と再生を高める。",
            weight: 2,
            minFloor: 34,
            baseModifiers: { hp: 1.16, hpRegen: 1.08, def: 1.06, spd: 0.96 },
            abilities: [
              {
                label: "潮衣",
                modifiers: { hp: 1.08, debuffResist: 1.06 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "波の連撃",
                modifiers: { attackCountBonus: 1, spd: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
              {
                label: "潮の遺物",
                modifiers: { hp: 1.06, def: 1.04 },
                hiddenModifiers: { dropChanceBonus: 5, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "stormcaller",
            label: "嵐導",
            tagLabels: ["嵐導", "雷導", "嵐帝"],
            rankLabels: ["嵐導の徒", "嵐導の導師", "嵐導の帝"],
            description: "嵐を呼び、命中と攻撃を高める。",
            weight: 1,
            minFloor: 46,
            baseModifiers: { accuracy: 1.12, atk: 1.12, spd: 1.04, def: 0.96 },
            abilities: [
              {
                label: "風雷",
                modifiers: { atk: 1.08, magAtk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "稲妻連鎖",
                modifiers: { attackCountBonus: 1, accuracy: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "嵐の宝",
                modifiers: { accuracy: 1.06, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "trickster",
            label: "戯欺",
            tagLabels: ["戯欺", "幻戯", "戯王"],
            rankLabels: ["戯欺の徒", "戯欺の幻戯", "戯欺の王"],
            description: "搦め手に長け、回避と命中を併せ持つ。",
            weight: 2,
            minFloor: 8,
            baseModifiers: {
              evade: 1.14,
              accuracy: 1.06,
              atk: 1.02,
              def: 0.96,
            },
            abilities: [
              {
                label: "悪戯",
                modifiers: { spd: 1.06, debuffResist: 1.06 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 4 },
              },
              {
                label: "奇術",
                modifiers: { attackCountBonus: 1, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 4 },
              },
              {
                label: "盗賊の儲け",
                modifiers: { evade: 1.05, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 8, rarityBonus: 4 },
              },
            ],
          },
          {
            key: "blightbloom",
            label: "腐華",
            tagLabels: ["腐華", "腐樹", "腐帝"],
            rankLabels: ["腐華の徒", "腐華の根", "腐華の帝"],
            description: "腐敗の花粉で蝕み、毒と再生を操る。",
            weight: 1,
            minFloor: 38,
            baseModifiers: {
              resist: { dot: 1.14 },
              hp: 1.12,
              atk: 1.06,
              def: 1.02,
            },
            abilities: [
              {
                label: "腐蝕",
                modifiers: { atk: 1.06, magAtk: 1.04 } ,
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "胞子拡散",
                modifiers: { attackCountBonus: 1, resist: { debuff: 1.08 } },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
              {
                label: "腐華の遺宝",
                modifiers: { hp: 1.06, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "ironclaw",
            label: "鉄爪",
            tagLabels: ["鉄爪", "鋼爪", "鋼帝"],
            rankLabels: ["鉄爪の徒", "鉄爪の猛者", "鉄爪の帝"],
            description: "鋭い鉤爪で装甲を裂く。",
            weight: 2,
            minFloor: 29,
            baseModifiers: {
              atk: 1.15,
              accuracy: 1.08,
              def: 0.96,
              physPen: 1.06,
            },
            abilities: [
              {
                label: "裂爪",
                modifiers: { atk: 1.08, critRate: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "鋼の連爪",
                modifiers: { attackCountBonus: 1, accuracy: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
              {
                label: "鋼爪の戦利",
                modifiers: { atk: 1.07, accuracy: 1.06 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 5 },
              },
            ],
          },
          {
            key: "runebound",
            label: "符鎖",
            tagLabels: ["符鎖", "符刻", "符王"],
            rankLabels: ["符鎖の徒", "符鎖の刻士", "符鎖の王"],
            description: "符術で力を増幅し、抵抗と魔力を得る。",
            weight: 1,
            minFloor: 44,
            baseModifiers: {
              magAtk: 1.12,
              resist: { control: 1.1, debuff: 1.08 },
              def: 1.02,
            },
            abilities: [
              {
                label: "符護",
                modifiers: { debuffResist: 1.08, def: 1.04 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "符束",
                modifiers: { attackCountBonus: 1, accuracy: 1.04 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "符刻の遺物",
                modifiers: { def: 1.05, resist: { control: 1.06 } },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "bloodmoon",
            label: "血月",
            tagLabels: ["血月", "紅月", "朱帝"],
            rankLabels: ["血月の徒", "血月の狂", "血月の帝"],
            description: "血の祝福で攻撃と吸収を高める。",
            weight: 1,
            minFloor: 50,
            baseModifiers: { atk: 1.16, lifeSteal: 1.08, def: 0.96, hp: 1.04 },
            abilities: [
              {
                label: "血宴",
                modifiers: { atk: 1.08, hp: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "朱の連牙",
                modifiers: { attackCountBonus: 1, lifeSteal: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
              {
                label: "血月の宝",
                modifiers: { hp: 1.06, atk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 6 },
              },
            ],
          },
          {
            key: "voidspawn",
            label: "虚形",
            tagLabels: ["虚形", "虚無", "虚王"],
            rankLabels: ["虚形の徒", "虚形の眷属", "虚形の王"],
            description: "虚無から現れ、抵抗と回避に優れる。",
            weight: 1,
            minFloor: 58,
            baseModifiers: {
              evade: 1.14,
              debuffResist: 1.12,
              accuracy: 1.04,
              def: 1.0,
            },
            abilities: [
              {
                label: "虚の殻",
                modifiers: { damageReduction: 1.06, def: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "虚空連撃",
                modifiers: { attackCountBonus: 1, magAtk: 1.05 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
              {
                label: "虚無の遺物",
                modifiers: { evade: 1.06, def: 1.04 },
                hiddenModifiers: { dropChanceBonus: 6, rarityBonus: 7 },
              },
            ],
          },
          {
            key: "thunderlord",
            label: "轟雷",
            tagLabels: ["轟雷", "雷槌", "雷王"],
            rankLabels: ["轟雷の徒", "轟雷の槌", "轟雷の王"],
            description: "轟く雷槌で圧倒し、攻撃と命中を高める。",
            weight: 1,
            minFloor: 62,
            baseModifiers: { atk: 1.2, accuracy: 1.08, def: 1.02, spd: 1.02 },
            abilities: [
              {
                label: "雷槌",
                modifiers: { atk: 1.1, physPen: 1.06 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
              {
                label: "雷連",
                modifiers: { attackCountBonus: 1, accuracy: 1.06 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
              {
                label: "雷帝の戦利",
                modifiers: { atk: 1.07, spd: 1.04 },
                hiddenModifiers: { dropChanceBonus: 7, rarityBonus: 7 },
              },
            ],
          },
        ];

        const ENEMY_NAME_POOLS = [
          {
            min: 1,
            max: 200,
            names: [
              "洞窟オオコウモリ",
              "朽ちた槍兵",
              "原野の狼",
              "石守のスライム",
              "巡回する鎧",
            ],
          },
          {
            min: 201,
            max: 600,
            names: [
              "深層トカゲ",
              "鉱脈のゴーレム",
              "闇走りの盗賊",
              "夜目の狩人",
              "結晶クラブ",
            ],
          },
          {
            min: 601,
            max: 1000,
            names: [
              "雷尾スコーピオン",
              "霧歩きの影獣",
              "虚ろの魔騎兵",
              "灰燼の獣王",
              "空隙ワーム",
            ],
          },
        ];
        const ENEMY_MONSTER_DEFINITIONS = {
          洞窟オオコウモリ: {
            flavor: "音もなく舞う素早い翼獣。",
            modifiers: { spd: 1.18, evade: 1.12, hp: 0.9, def: 0.9 },
          },
          朽ちた槍兵: {
            flavor: "錆びた槍でも狙いは正確。",
            modifiers: { atk: 1.08, accuracy: 1.12, def: 1.05, spd: 0.96 },
          },
          原野の狼: {
            flavor: "牙で食らいつく俊敏な群れ狼。",
            modifiers: { atk: 1.16, spd: 1.1, evade: 1.05, hp: 0.95 },
          },
          石守のスライム: {
            flavor: "岩肌をまとい鈍重だが固い。",
            modifiers: { hp: 1.18, def: 1.24, spd: 0.82, accuracy: 0.95 },
          },
          巡回する鎧: {
            flavor: "空の鎧が淡々と巡回する。",
            modifiers: {
              def: 1.12,
              hp: 1.06,
              accuracy: 1.04,
              spd: 0.94,
              resist: { control: 1.1, debuff: 1.08 },
            },
          },
          深層トカゲ: {
            flavor: "長い尾で素早く間合いを詰める。",
            modifiers: { spd: 1.12, evade: 1.08, hp: 1.05 },
          },
          鉱脈のゴーレム: {
            flavor: "鉱石で組まれた巨体は揺るがない。",
            modifiers: { hp: 1.26, def: 1.32, spd: 0.78, evade: 0.9 },
          },
          闇走りの盗賊: {
            flavor: "闇に紛れて刃を走らせる。",
            modifiers: {
              spd: 1.2,
              evade: 1.18,
              accuracy: 1.12,
              def: 0.88,
              hp: 0.94,
            },
          },
          夜目の狩人: {
            flavor: "暗闇でも獲物を逃さない射手。",
            modifiers: { accuracy: 1.18, atk: 1.12, spd: 1.04, evade: 1.02 },
          },
          結晶クラブ: {
            flavor: "結晶殻で打撃を弾く甲殻種。",
            modifiers: { def: 1.22, hp: 1.12, spd: 0.9, resist: { dot: 1.16 } },
          },
          雷尾スコーピオン: {
            flavor: "雷尾で素早く二度刺す。",
            modifiers: {
              spd: 1.2,
              atk: 1.12,
              accuracy: 1.08,
              attackCountBonus: 1,
            },
          },
          霧歩きの影獣: {
            flavor: "霧の中で姿を晦まし斬り込む。",
            modifiers: { evade: 1.26, spd: 1.14, hp: 0.95 },
          },
          虚ろの魔騎兵: {
            flavor: "虚ろな瞳の騎兵が淡々と突撃する。",
            modifiers: {
              atk: 1.1,
              def: 1.12,
              accuracy: 1.06,
              resist: { control: 1.14 },
            },
          },
          灰燼の獣王: {
            flavor: "灰の匂いを纏い豪腕で殴りかかる。",
            modifiers: { atk: 1.22, hp: 1.18, def: 0.92, spd: 1.05 },
          },
          空隙ワーム: {
            flavor: "空隙を漂いしぶとく噛み付く。",
            modifiers: {
              hp: 1.28,
              def: 1.08,
              spd: 0.9,
              accuracy: 0.96,
              resist: { dot: 1.2, debuff: 1.1 },
            },
          },
        };
        const FLOOR_DROP_TABLE = [
          { min: 1, max: 4, slots: ["weapon", "head", "body", "hands"] },
          {
            min: 5,
            max: 9,
            slots: ["weapon", "subWeapon", "body", "hands", "feet"],
          },
          {
            min: 10,
            max: 14,
            slots: ["weapon", "subWeapon", "hands", "feet", "body"],
          },
          {
            min: 15,
            max: 19,
            slots: [
              "weapon",
              "subWeapon",
              "hands",
              "feet",
              "body",
              "accessory",
            ],
          },
          { min: 20, max: 1000, slots: Object.keys(EQUIPMENT_SLOTS) },
        ];
        const BOSS_LEGENDARY_DROPS = {
          10: {
            slot: "body",
            legendaryKey: "aeroScoutMantle",
            legendaryKeys: [
              "aeroScoutMantle",
              "greywingHauberk",
              "toxinPlumeCoat",
              "windpiercerCuirass",
              "scoutCaptainCoat",
            ],
          },
          20: {
            slot: "weapon",
            legendaryKey: "celestiaFrostbrand",
            legendaryKeys: [
              "celestiaFrostbrand",
              "frostvineEdge",
              "crystalBloomSpear",
              "rimebindHalberd",
              "iceheartBlade",
            ],
          },
          30: {
            slot: "head",
            legendaryKey: "zharafSandmask",
            legendaryKeys: [
              "zharafSandmask",
              "duneTrackerHelm",
              "mirageSeekerHood",
              "sandstormVisor",
              "whisperingDuneCowl",
            ],
          },
          50: {
            slot: "hands",
            legendaryKey: "granphosAurumGauntlet",
            legendaryKeys: [
              "granphosAurumGauntlet",
              "hoardwardenGrips",
              "coinforgedFists",
              "gildedBulwarkClaw",
              "vaultbreakerTalons",
            ],
          },
          100: {
            slot: "subWeapon",
            legendaryKey: "ignisioCinderOrb",
            legendaryKeys: [
              "ignisioCinderOrb",
              "emberCenser",
              "pyreSigil",
              "ashbrandTotem",
              "blazeMirror",
            ],
          },
          200: {
            slot: "accessory",
            legendaryKey: "rivanTideGlyph",
            legendaryKeys: [
              "rivanTideGlyph",
              "wavecrestCharm",
              "abyssRhythmRing",
              "deepflowPendant",
              "sirenPulseAmulet",
            ],
          },
          500: {
            slot: "feet",
            legendaryKey: "ordoVoidstride",
            legendaryKeys: [
              "ordoVoidstride",
              "inquisitionTreads",
              "starlessGreaves",
              "nullwalkerBoots",
              "voidstepSabaton",
            ],
          },
          700: {
            slot: "body",
            legendaryKey: "garoldThunderplate",
            legendaryKeys: [
              "garoldThunderplate",
              "stormcoreArmor",
              "thunderousMail",
              "lightningWardCoat",
              "shockchainVest",
            ],
          },
          1000: {
            slot: "weapon",
            legendaryKey: "fenradiaDawnbreaker",
            legendaryKeys: [
              "fenradiaDawnbreaker",
              "auroraJudicator",
              "eclipseSovereign",
              "dawnsigilBlade",
              "finalPromise",
            ],
          },
        };
        const BOSS_LEGENDARY_BASE_CHANCE_POINTS = [
          // 低層はベース高め、高層ほど基礎は絞って「運」依存を強くする
          { floor: 10, chance: 18 },
          { floor: 50, chance: 14 },
          { floor: 100, chance: 9 },
          { floor: 200, chance: 5 },
          { floor: 500, chance: 2.5 },
          { floor: 700, chance: 1 },
          { floor: 1000, chance: 0.5 },
        ];

        const EQUIPMENT_TIER_BOUNDARIES = [
          { maxFloor: 99, key: "tier1", theme: "黎明の", scale: 1.15 },
          { maxFloor: 199, key: "tier2", theme: "蒼炎の", scale: 8 },
          { maxFloor: 299, key: "tier3", theme: "雷閃の", scale: 35 },
          { maxFloor: 399, key: "tier4", theme: "翠嵐の", scale: 120 },
          { maxFloor: 499, key: "tier5", theme: "白光の", scale: 420 },
          { maxFloor: 599, key: "tier6", theme: "影霧の", scale: 1400 },
          { maxFloor: 699, key: "tier7", theme: "紅蓮の", scale: 4200 },
          { maxFloor: 799, key: "tier8", theme: "星紋の", scale: 12000 },
          { maxFloor: 899, key: "tier9", theme: "黎冥の", scale: 32000 },
          { maxFloor: 1000, key: "tier10", theme: "天啓の", scale: 80000 },
        ];
        const EQUIPMENT_TIER_KEYS = EQUIPMENT_TIER_BOUNDARIES.map(
          (entry) => entry.key,
        );

        const TITLE_BASE_CHANCE = { prefix: 55, suffix: 45 };
        const TITLE_RANK_WEIGHTS = [
          { rank: 1, weight: 60 },
          { rank: 2, weight: 30 },
          { rank: 3, weight: 10 },
        ];

        const TITLE_PRIMARY_PER_LEVEL_EFFECTS = [
          { amount: 2, interval: 3 },
          { amount: 3, interval: 3 },
          { amount: 2, interval: 1 },
        ];
        const TITLE_PRIMARY_FIXED_EFFECTS = [75, 150, 300];
        const TITLE_ATTACK_COUNT_BONUS_EFFECTS = [2, 3, 5];

        const EQUIPMENT_STAT_POOL = [
          { key: "str", label: "力", type: "primary", range: [2, 6] },
          { key: "int", label: "知識", type: "primary", range: [2, 6] },
          { key: "vit", label: "体力", type: "primary", range: [2, 6] },
          { key: "agi", label: "敏捷", type: "primary", range: [2, 6] },
          { key: "luck", label: "運", type: "primary", range: [2, 6] },
          { key: "hp", label: "最大HP", type: "secondary", range: [18, 42] },
          { key: "mp", label: "最大MP", type: "secondary", range: [9, 27] },
          {
            key: "physAtk",
            label: "物理攻撃力",
            type: "secondary",
            range: [9, 21],
          },
          {
            key: "magAtk",
            label: "魔法攻撃力",
            type: "secondary",
            range: [9, 21],
          },
          {
            key: "physDef",
            label: "物理防御力",
            type: "secondary",
            range: [6, 15],
          },
          {
            key: "magDef",
            label: "魔法防御力",
            type: "secondary",
            range: [6, 15],
          },
          { key: "speed", label: "速度", type: "secondary", range: [2, 6] },
          {
            key: "critRate",
            label: "クリティカル率",
            type: "secondary",
            range: [3, 12],
            unit: "%",
          },
          {
            key: "critDamage",
            label: "クリティカルダメージ",
            type: "secondary",
            range: [6, 18],
            unit: "%",
          },
          {
            key: "evade",
            label: "回避率",
            type: "secondary",
            range: [3, 12],
            unit: "%",
          },
          {
            key: "physPen",
            label: "物理貫通",
            type: "secondary",
            range: [2, 8],
            unit: "%",
          },
          {
            key: "magPen",
            label: "魔法貫通",
            type: "secondary",
            range: [2, 8],
            unit: "%",
          },
          {
            key: "damageReduction",
            label: "被ダメージ軽減",
            type: "secondary",
            range: [2, 6],
            unit: "%",
          },
          {
            key: "block",
            label: "ブロック率",
            type: "secondary",
            range: [2, 8],
            unit: "%",
          },
          {
            key: "controlResist",
            label: "行動阻害抵抗",
            type: "secondary",
            range: [5, 15],
            unit: "%",
          },
          {
            key: "dotResist",
            label: "DoT抵抗",
            type: "secondary",
            range: [5, 15],
            unit: "%",
          },
          {
            key: "debuffResist",
            label: "弱体化抵抗",
            type: "secondary",
            range: [5, 15],
            unit: "%",
          },
          {
            key: "cooldown",
            label: "CT短縮",
            type: "secondary",
            range: [2, 9],
            unit: "%",
          },
          {
            key: "hpRegen",
            label: "HP再生",
            type: "secondary",
            range: [0.75, 3],
            precision: 1,
          },
          {
            key: "lifeSteal",
            label: "HP吸収",
            type: "secondary",
            range: [2, 5],
            unit: "%",
          },
          {
            key: "barrier",
            label: "バリア",
            type: "secondary",
            range: [12, 30],
          },
          {
            key: "dropRate",
            label: "ドロップ率",
            type: "secondary",
            range: [3, 12],
            unit: "%",
          },
          {
            key: "rarity",
            label: "レアリティUP",
            type: "secondary",
            range: [2, 6],
            unit: "%",
          },
          {
            key: "namedRate",
            label: "ネームド遭遇率",
            type: "secondary",
            range: [3, 9],
            unit: "%",
          },
          {
            key: "titleChance",
            label: "称号付与率UP",
            type: "secondary",
            range: [6, 15],
            unit: "%",
          },
          {
            key: "goldChance",
            label: "ゴールド確率",
            type: "secondary",
            range: [8, 27],
            unit: "%",
          },
        ];

        const EQUIPMENT_STAT_BY_KEY = Object.fromEntries(
          EQUIPMENT_STAT_POOL.map((s) => [s.key, s]),
        );

        const EQUIPMENT_BASE_TEMPLATE_LIBRARY = {
          weapon: [
            {
              key: "swordsmanBlade",
              name: "剣士の刃",
              base: [
                { key: "physAtk", range: [24, 33] },
                { key: "critRate", range: [6, 11], unit: "%" },
                { key: "str", range: [3, 6] },
              ],
            },
            {
              key: "mageFocus",
              name: "術導の杖",
              base: [
                { key: "magAtk", range: [27, 36] },
                { key: "mp", range: [24, 39] },
                { key: "cooldown", range: [5, 9], unit: "%" },
              ],
            },
            {
              key: "clericMace",
              name: "祈祷のメイス",
              base: [
                { key: "magAtk", range: [18, 27] },
                { key: "hpRegen", range: [1.8, 3.6], precision: 1 },
                { key: "vit", range: [3, 6] },
              ],
            },
            {
              key: "vampiricClaw",
              name: "血契の爪",
              base: [
                { key: "physAtk", range: [21, 30] },
                { key: "lifeSteal", range: [3, 6], unit: "%" },
                { key: "speed", range: [3, 6] },
              ],
            },
          ],
          subWeapon: [
            {
              key: "guardianWall",
              name: "守勢の盾",
              base: [
                { key: "physDef", range: [15, 24] },
                { key: "block", range: [5, 9], unit: "%" },
                { key: "vit", range: [5, 8] },
              ],
            },
            {
              key: "arcaneTome",
              name: "星読の書",
              base: [
                { key: "mp", range: [30, 45] },
                { key: "magAtk", range: [18, 27] },
                { key: "magPen", range: [3, 6], unit: "%" },
              ],
            },
            {
              key: "clericCodex",
              name: "聖律の手引",
              base: [
                { key: "magDef", range: [15, 24] },
                { key: "barrier", range: [18, 27] },
                { key: "debuffResist", range: [6, 12], unit: "%" },
              ],
            },
            {
              key: "shadowDirk",
              name: "影躍りの短刀",
              base: [
                { key: "physAtk", range: [15, 24] },
                { key: "critRate", range: [8, 12], unit: "%" },
                { key: "evade", range: [5, 9], unit: "%" },
              ],
            },
          ],
          head: [
            {
              key: "stalwartHelm",
              name: "堅陣の兜",
              base: [
                { key: "hp", range: [39, 51] },
                { key: "physDef", range: [12, 18] },
                { key: "str", range: [2, 5] },
              ],
            },
            {
              key: "sageHood",
              name: "星辰のフード",
              base: [
                { key: "mp", range: [27, 39] },
                { key: "magAtk", range: [15, 21] },
                { key: "cooldown", range: [3, 8], unit: "%" },
              ],
            },
            {
              key: "cantorVeil",
              name: "聖歌のヴェール",
              base: [
                { key: "hp", range: [36, 48] },
                { key: "debuffResist", range: [9, 15], unit: "%" },
                { key: "vit", range: [3, 6] },
              ],
            },
            {
              key: "duskMask",
              name: "宵闇の仮面",
              base: [
                { key: "speed", range: [5, 8] },
                { key: "critRate", range: [5, 9], unit: "%" },
                { key: "lifeSteal", range: [2, 5], unit: "%" },
              ],
            },
          ],
          body: [
            {
              key: "vanguardPlate",
              name: "盾軍の甲冑",
              base: [
                { key: "hp", range: [69, 87] },
                { key: "physDef", range: [18, 27] },
                { key: "block", range: [6, 11], unit: "%" },
              ],
            },
            {
              key: "astralRobe",
              name: "蒼星のローブ",
              base: [
                { key: "magDef", range: [18, 27] },
                { key: "mp", range: [36, 51] },
                { key: "magAtk", range: [18, 24] },
              ],
            },
            {
              key: "guardianMail",
              name: "祈守の法衣",
              base: [
                { key: "hp", range: [60, 78] },
                { key: "controlResist", range: [9, 15], unit: "%" },
                { key: "debuffResist", range: [9, 15], unit: "%" },
              ],
            },
            {
              key: "nightSilk",
              name: "夜霧の外套",
              base: [
                { key: "evade", range: [9, 15], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "magDef", range: [15, 21] },
              ],
            },
          ],
          hands: [
            {
              key: "strikeGauntlet",
              name: "斬烈の篭手",
              base: [
                { key: "physAtk", range: [15, 24] },
                { key: "critDamage", range: [12, 18], unit: "%" },
                { key: "str", range: [3, 6] },
              ],
            },
            {
              key: "mysticGrips",
              name: "魔導の手袋",
              base: [
                { key: "magAtk", range: [15, 24] },
                { key: "cooldown", range: [5, 9], unit: "%" },
                { key: "magPen", range: [3, 8], unit: "%" },
              ],
            },
            {
              key: "hymnGloves",
              name: "聖歌の手甲",
              base: [
                { key: "hpRegen", range: [1.8, 3.6], precision: 1 },
                { key: "magDef", range: [12, 18] },
                { key: "vit", range: [3, 6] },
              ],
            },
            {
              key: "bloodWeaveClaws",
              name: "血紋の手甲",
              base: [
                { key: "critRate", range: [8, 14], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "lifeSteal", range: [2.25, 5], unit: "%", precision: 1 },
              ],
            },
          ],
          feet: [
            {
              key: "battleGreaves",
              name: "戦踏の具足",
              base: [
                { key: "speed", range: [5, 9] },
                { key: "physDef", range: [12, 18] },
                { key: "hp", range: [30, 45] },
              ],
            },
            {
              key: "arcanistShoes",
              name: "魔導士の靴",
              base: [
                { key: "speed", range: [5, 9] },
                { key: "mp", range: [21, 33] },
                { key: "cooldown", range: [3, 8], unit: "%" },
              ],
            },
            {
              key: "pilgrimBoots",
              name: "巡礼の足甲",
              base: [
                { key: "hp", range: [33, 48] },
                { key: "controlResist", range: [8, 14], unit: "%" },
                { key: "speed", range: [3, 6] },
              ],
            },
            {
              key: "moonlitStride",
              name: "月影のブーツ",
              base: [
                { key: "evade", range: [9, 15], unit: "%" },
                { key: "speed", range: [6, 11] },
                { key: "luck", range: [3, 6] },
              ],
            },
          ],
          accessory: [
            {
              key: "warriorEmblem",
              name: "斬将の紋章",
              base: [
                { key: "physAtk", range: [12, 21] },
                { key: "critRate", range: [6, 12], unit: "%" },
                { key: "str", range: [3, 6] },
              ],
            },
            {
              key: "crystalFocus",
              name: "結晶の魔石",
              base: [
                { key: "magAtk", range: [12, 21] },
                { key: "magPen", range: [5, 9], unit: "%" },
                { key: "mp", range: [18, 30] },
              ],
            },
            {
              key: "sanctumRosary",
              name: "聖域の数珠",
              base: [
                { key: "hpRegen", range: [2.1, 4.2], precision: 1 },
                { key: "barrier", range: [15, 24] },
                { key: "vit", range: [3, 6] },
              ],
            },
            {
              key: "scarletCharm",
              name: "緋血の護符",
              base: [
                {
                  key: "lifeSteal",
                  range: [3.75, 6.75],
                  unit: "%",
                  precision: 1,
                },
                { key: "critDamage", range: [12, 18], unit: "%" },
                { key: "speed", range: [3, 6] },
              ],
            },
          ],
        };

        function scaleOptionRangeForTier(option, scale) {
          if (!option?.range) return option;
          const precision =
            option.precision ??
            EQUIPMENT_STAT_BY_KEY[option.key]?.precision ??
            0;
          const factor = 10 ** precision;
          return {
            ...option,
            range: option.range.map((value) =>
              Math.max(1, Math.round(value * scale * factor) / factor),
            ),
          };
        }

        function buildTieredEquipmentTemplates(baseLibrary) {
          return Object.fromEntries(
            Object.entries(baseLibrary).map(([slotKey, templates]) => [
              slotKey,
              EQUIPMENT_TIER_BOUNDARIES.flatMap((tier) => {
                const scale = tier.scale ?? 1;
                return templates.map((template) => ({
                  ...template,
                  tier: tier.key,
                  key: `${template.key}_${tier.key}`,
                  name: `${tier.theme}${template.name}`,
                  base: template.base.map((option) =>
                    scaleOptionRangeForTier(option, scale),
                  ),
                }));
              }),
            ]),
          );
        }

        const EQUIPMENT_TEMPLATE_LIBRARY = buildTieredEquipmentTemplates(
          EQUIPMENT_BASE_TEMPLATE_LIBRARY,
        );

        // レジェンド装備定義から、キー→テンプレートの逆引きインデックスを遅延生成する
        let LEGENDARY_TEMPLATE_INDEX = null;

        function buildLegendaryTemplateIndex() {
          // すでに作ってあればそれを返す
          if (LEGENDARY_TEMPLATE_INDEX) return LEGENDARY_TEMPLATE_INDEX;

          // ライブラリがまだ無ければ空のまま
          if (
            typeof LEGENDARY_EQUIPMENT_LIBRARY === "undefined" ||
            !LEGENDARY_EQUIPMENT_LIBRARY
          ) {
            LEGENDARY_TEMPLATE_INDEX = {};
            return LEGENDARY_TEMPLATE_INDEX;
          }

          LEGENDARY_TEMPLATE_INDEX = Object.entries(
            LEGENDARY_EQUIPMENT_LIBRARY,
          ).reduce((acc, [slotKey, list]) => {
            (list || []).forEach((entry) => {
              acc[entry.key] = { ...entry, slot: entry.slot || slotKey };
            });
            return acc;
          }, {});

          return LEGENDARY_TEMPLATE_INDEX;
        }

        function getLegendaryTemplateByKey(key) {
          if (!key) return null;
          const index = buildLegendaryTemplateIndex();
          return index[key] || null;
        }

        function inferLegendaryKeyFromItem(item) {
          if (!item?.equipment || item.equipment?.rarity !== "legendary")
            return "";
          if (item.equipment.legendaryKey) return item.equipment.legendaryKey;

          const index = buildLegendaryTemplateIndex();
          const match = Object.values(index).find((entry) => {
            const nameHit = item.name?.includes(entry.name);
            const uniqueName = entry.unique?.name;
            const hasUnique = uniqueName
              ? (item.equipment.uniqueOptions || []).some(
                  (opt) => opt?.name === uniqueName,
                )
              : false;
            return nameHit || hasUnique;
          });

          return match?.key || "";
        }

        const TITLE_PRIMARY_GROWTH_BLUEPRINTS = [
          {
            stat: "str",
            prefixRanks: [
              { rank: 3, name: "覇道の", options: ["hp", "critRate"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の覇気", options: ["critDamage", "speed"] },
            ],
          },
          {
            stat: "int",
            prefixRanks: [
              { rank: 3, name: "星読の", options: ["mp", "cooldown"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の慧眼", options: ["magPen", "hp"] },
            ],
          },
          {
            stat: "vit",
            prefixRanks: [
              {
                rank: 3,
                name: "鉄壁の",
                options: ["damageReduction", "block"],
              },
            ],
            suffixRanks: [
              { rank: 3, name: "の城塞", options: ["physDef", "magDef"] },
            ],
          },
          {
            stat: "agi",
            prefixRanks: [
              { rank: 3, name: "風走りの", options: ["evade", "critRate"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の旋舞", options: ["critRate", "physAtk"] },
            ],
          },
          {
            stat: "luck",
            prefixRanks: [
              { rank: 3, name: "天運の", options: ["rarity", "titleChance"] },
            ],
            suffixRanks: [
              {
                rank: 3,
                name: "の宿星",
                options: ["namedRate", "titleChance"],
              },
            ],
          },
        ];

        const TITLE_PRIMARY_FIXED_BLUEPRINTS = [
          {
            stat: "str",
            prefixRanks: [
              { rank: 3, name: "力の権能", options: ["critRate", "hp"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の覇道", options: ["critDamage", "speed"] },
            ],
          },
          {
            stat: "int",
            prefixRanks: [
              { rank: 3, name: "叡智の権能", options: ["mp", "cooldown"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の星詠", options: ["magPen", "hp"] },
            ],
          },
          {
            stat: "vit",
            prefixRanks: [
              {
                rank: 3,
                name: "守護の権能",
                options: ["damageReduction", "block"],
              },
            ],
            suffixRanks: [
              { rank: 3, name: "の巨砦", options: ["physDef", "magDef"] },
            ],
          },
          {
            stat: "agi",
            prefixRanks: [
              { rank: 3, name: "迅速の権能", options: ["evade", "critRate"] },
            ],
            suffixRanks: [
              { rank: 3, name: "の風華", options: ["critRate", "physAtk"] },
            ],
          },
          {
            stat: "luck",
            prefixRanks: [
              {
                rank: 3,
                name: "幸運の権能",
                options: ["rarity", "titleChance"],
              },
            ],
            suffixRanks: [
              {
                rank: 3,
                name: "の星宿",
                options: ["namedRate", "titleChance"],
              },
            ],
          },
        ];

        const TITLE_ATTACK_COUNT_BLUEPRINT = {
          prefixRanks: [
            { rank: 3, name: "迅雷の", options: ["critRate", "evade"] },
          ],
          suffixRanks: [
            { rank: 3, name: "の剣舞", options: ["cooldown", "critDamage"] },
          ],
        };

        const BASE_EQUIPMENT_TITLE_PREFIXES = [
          { key: "nimble", name: "軽やかな", rank: 1, options: ["agi"] },
          { key: "sharp", name: "鋭い", rank: 1, options: ["critRate"] },
          { key: "sturdy", name: "頑丈な", rank: 1, options: ["physDef"] },
          { key: "tranquil", name: "静かな", rank: 1, options: ["mp"] },
          { key: "spry", name: "俊敏な", rank: 1, options: ["speed"] },
          { key: "watchful", name: "警戒の", rank: 1, options: ["evade"] },
          { key: "tempered", name: "鍛えた", rank: 1, options: ["physAtk"] },
          { key: "sageborne", name: "叡智の", rank: 1, options: ["int"] },
          { key: "feral", name: "野生の", rank: 1, options: ["str"] },
          { key: "warded", name: "守護の", rank: 1, options: ["vit"] },
          { key: "dusklit", name: "夕闇の", rank: 1, options: ["magDef"] },
          { key: "dawnlit", name: "黎明の", rank: 1, options: ["luck"] },
          { key: "swiftstep", name: "疾駆の", rank: 1, options: ["physAtk"] },
          { key: "restful", name: "安息の", rank: 1, options: ["hpRegen"] },
          { key: "blooded", name: "吸血の", rank: 1, options: ["lifeSteal"] },
          { key: "radiant", name: "光輝の", rank: 1, options: ["rarity"] },
          { key: "tracker", name: "探索者の", rank: 1, options: ["dropRate"] },
          { key: "shadowed", name: "影纏いの", rank: 1, options: ["speed"] },
          { key: "focused", name: "専心の", rank: 1, options: ["cooldown"] },
          { key: "calm", name: "静謐な", rank: 1, options: ["debuffResist"] },
          { key: "vigorous", name: "活力の", rank: 1, options: ["hp"] },
          { key: "hunterSpirit", name: "狩猟の", rank: 1, options: ["critRate"] },
          { key: "colossal", name: "巨大な", rank: 2, options: ["str", "vit"] },
          { key: "arcane", name: "魔導の", rank: 2, options: ["int", "mp"] },
          { key: "stalwart", name: "堅牢な", rank: 2, options: ["physDef", "vit"] },
          { key: "battlewise", name: "戦巧の", rank: 2, options: ["physAtk", "critRate"] },
          { key: "frostbound", name: "氷結の", rank: 2, options: ["magAtk", "dotResist"] },
          { key: "thundering", name: "雷鳴の", rank: 2, options: ["speed", "critRate"] },
          { key: "blazing", name: "紅蓮の", rank: 2, options: ["physAtk", "critDamage"] },
          { key: "windrunner", name: "風纏いの", rank: 2, options: ["evade", "speed"] },
          { key: "stoneguard", name: "石壁の", rank: 2, options: ["block", "damageReduction"] },
          { key: "tidecall", name: "潮騒の", rank: 2, options: ["hp", "magDef"] },
          { key: "moonlitCrest", name: "月下の", rank: 2, options: ["critRate", "magAtk"] },
          { key: "sunblessed", name: "陽光の", rank: 2, options: ["hp", "hpRegen"] },
          { key: "venomous", name: "毒牙の", rank: 2, options: ["physAtk", "dotResist"] },
          { key: "mindseye", name: "心眼の", rank: 2, options: ["magPen", "cooldown"] },
          { key: "artisan", name: "匠の", rank: 2, options: ["dropRate", "rarity"] },
          { key: "fortune", name: "幸運の", rank: 2, options: ["luck", "titleChance"] },
          { key: "spiral", name: "螺旋の", rank: 2, options: ["magAtk", "magPen"] },
          { key: "silentGuard", name: "静寂の", rank: 2, options: ["debuffResist", "magDef"] },
          { key: "zealous", name: "熱情の", rank: 2, options: ["str", "critDamage"] },
          { key: "daring", name: "果敢な", rank: 2, options: ["physAtk", "physPen"] },
          { key: "sentinel", name: "警邏の", rank: 2, options: ["controlResist", "hp"] },
          { key: "gale", name: "疾風の", rank: 2, options: ["speed", "cooldown"] },
          { key: "dawnguard", name: "暁光の", rank: 2, options: ["magDef", "hp"] },
          { key: "runic", name: "符術の", rank: 2, options: ["magAtk", "mp"] },
          { key: "shadowstalk", name: "闇走りの", rank: 2, options: ["evade", "speed"] },
          { key: "predator", name: "狩猟者の", rank: 2, options: ["critRate", "physAtk"] },
          { key: "stonegrip", name: "岩握りの", rank: 2, options: ["physDef", "block"] },
          { key: "warchant", name: "戦歌の", rank: 2, options: ["str", "critDamage"] },
          { key: "feywisdom", name: "妖智の", rank: 2, options: ["int", "rarity"] },
          { key: "tidewalker", name: "潮騎の", rank: 2, options: ["magDef", "evade"] },
          { key: "glacier", name: "氷河の", rank: 2, options: ["dotResist", "hp"] },
          { key: "blazeborn", name: "炎生の", rank: 2, options: ["magAtk", "critRate"] },
          { key: "sunder", name: "断罪の", rank: 2, options: ["physPen", "critDamage"] },
          { key: "skyborne", name: "天空の", rank: 2, options: ["speed", "evade"] },
          { key: "quicksilver", name: "水銀の", rank: 2, options: ["cooldown", "speed"] },
          { key: "lionheart", name: "獅子心の", rank: 2, options: ["hp", "damageReduction"] },
          { key: "evergreen", name: "常葉の", rank: 2, options: ["hpRegen", "hp"] },
          { key: "zephyr", name: "微風の", rank: 2, options: ["agi", "speed"] },
          { key: "echoing", name: "残響の", rank: 2, options: ["magAtk", "cooldown"] },
          { key: "starcaller", name: "星詠みの", rank: 2, options: ["magAtk", "titleChance"] },
          { key: "prospector", name: "探金の", rank: 2, options: ["goldChance", "dropRate"] },
          { key: "voidstep", name: "虚歩の", rank: 2, options: ["evade", "debuffResist"] },
          {
            key: "tempest",
            name: "迅雷の",
            rank: 3,
            options: ["speed", "evade", "critRate"],
          },
          {
            key: "mythic",
            name: "神獣の",
            rank: 3,
            options: ["str", "vit", "hp"],
          },
          {
            key: "immortal",
            name: "不朽の",
            rank: 3,
            options: ["hp", "damageReduction", "block"],
          },
          {
            key: "r3Celestial",
            name: "星護の",
            rank: 3,
            options: ["magAtk", "magPen", "cooldown"],
          },
          {
            key: "r3Berserker",
            name: "狂乱の",
            rank: 3,
            options: ["physAtk", "critDamage", "hp"],
          },
          {
            key: "r3Ironwall",
            name: "鋼壁の",
            rank: 3,
            options: ["hp", "physDef", "damageReduction"],
          },
          {
            key: "r3Phantom",
            name: "幻影の",
            rank: 3,
            options: ["evade", "speed", "critRate"],
          },
          {
            key: "r3Oracle",
            name: "神託の",
            rank: 3,
            options: ["mp", "magAtk", "rarity"],
          },
          {
            key: "r3Stormchaser",
            name: "雷追いの",
            rank: 3,
            options: ["speed", "critRate", "magAtk"],
          },
          {
            key: "r3Beastking",
            name: "獣王の",
            rank: 3,
            options: ["str", "physAtk", "hp"],
          },
          {
            key: "r3Sands",
            name: "砂漠の",
            rank: 3,
            options: ["evade", "dotResist", "hpRegen"],
          },
          {
            key: "r3Spiritbound",
            name: "霊縛の",
            rank: 3,
            options: ["controlResist", "magDef", "hp"],
          },
          {
            key: "r3Emberlord",
            name: "焔帝の",
            rank: 3,
            options: ["critDamage", "physPen", "speed"],
          },
          {
            key: "r3Frostbite",
            name: "氷牙の",
            rank: 3,
            options: ["magAtk", "magPen", "debuffResist"],
          },
          {
            key: "r3Seastrider",
            name: "海翔の",
            rank: 3,
            options: ["speed", "hp", "magDef"],
          },
          {
            key: "r3Skyguard",
            name: "蒼空の",
            rank: 3,
            options: ["evade", "block", "controlResist"],
          },
          {
            key: "r3Voidborne",
            name: "虚空の",
            rank: 3,
            options: ["magAtk", "dotResist", "magDef"],
          },
          {
            key: "r3Dawnbreaker",
            name: "破暁の",
            rank: 3,
            options: ["critRate", "physAtk", "cooldown"],
          },
          {
            key: "r3Lifebloom",
            name: "生命樹の",
            rank: 3,
            options: ["hpRegen", "hp", "barrier"],
          },
          {
            key: "r3Luminous",
            name: "燐光の",
            rank: 3,
            options: ["rarity", "dropRate", "titleChance"],
          },
          {
            key: "r3Gravewalker",
            name: "冥歩の",
            rank: 3,
            options: ["lifeSteal", "physAtk", "evade"],
          },
          {
            key: "r3Mountain",
            name: "峻厳の",
            rank: 3,
            options: ["vit", "damageReduction", "block"],
          },
          {
            key: "r3Aurora",
            name: "極光の",
            rank: 3,
            options: ["magAtk", "speed", "namedRate"],
          },
          {
            key: "twilight",
            name: "黄昏の",
            rank: 2,
            options: ["int", "magAtk"],
          },
          {
            key: "hunter",
            name: "狩人の",
            rank: 2,
            options: ["critRate", "speed"],
          },
          {
            key: "growing",
            name: "成長する",
            rank: 3,
            options: ["physAtk", "speed"],
            primaryPerLevelStats: ["str"],
          },
          {
            key: "unyielding",
            name: "不動の",
            rank: 3,
            options: ["hp", "damageReduction"],
            primaryFixedStats: ["vit"],
          },
          {
            key: "relentless",
            name: "連舞の",
            rank: 3,
            options: ["speed", "critRate"],
            attackCountBonus: true,
          },
          {
            key: "r3Cleaving",
            name: "掃討の",
            rank: 3,
            options: ["speed", "critRate"],
            attackTargetsBonus: 1,
          },
        ];

        const BASE_EQUIPMENT_TITLE_SUFFIXES = [
          { key: "apprentice", name: "の研鑽", rank: 1, options: ["hp"] },
          { key: "trailblazer", name: "の先駆者", rank: 1, options: ["speed"] },
          { key: "shelter", name: "の安寧", rank: 1, options: ["hp"] },
          { key: "focus", name: "の集中", rank: 1, options: ["mp"] },
          { key: "courage", name: "の勇気", rank: 1, options: ["str"] },
          { key: "wisdom", name: "の叡智", rank: 1, options: ["int"] },
          { key: "fleet", name: "の軽足", rank: 1, options: ["agi"] },
          { key: "shade", name: "の影", rank: 1, options: ["evade"] },
          { key: "spark", name: "の火花", rank: 1, options: ["critRate"] },
          { key: "stone", name: "の礫", rank: 1, options: ["physDef"] },
          { key: "wave", name: "の波音", rank: 1, options: ["magDef"] },
          { key: "bloom", name: "の芽吹き", rank: 1, options: ["dropRate"] },
          { key: "discovery", name: "の探索", rank: 1, options: ["namedRate"] },
          { key: "glow", name: "の余光", rank: 1, options: ["goldChance"] },
          { key: "learner", name: "の学び", rank: 1, options: ["mp"] },
          { key: "vigor", name: "の活気", rank: 1, options: ["hpRegen"] },
          {
            key: "resolve",
            name: "の決意",
            rank: 1,
            options: ["damageReduction"],
          },
          {
            key: "stillness",
            name: "の静謐",
            rank: 1,
            options: ["debuffResist"],
          },
          { key: "threads", name: "の糸口", rank: 1, options: ["critRate"] },
          { key: "lantern", name: "の灯火", rank: 1, options: ["titleChance"] },
          { key: "roaming", name: "の旅路", rank: 1, options: ["rarity"] },
          { key: "herbal", name: "の癒薬", rank: 1, options: ["barrier"] },
          {
            key: "onslaught",
            name: "の猛攻",
            rank: 2,
            options: ["physAtk", "critDamage"],
          },
          {
            key: "sorcery",
            name: "の叡智",
            rank: 2,
            options: ["magAtk", "cooldown"],
          },
          { key: "bulwark", name: "の壁陣", rank: 2, options: ["physDef", "damageReduction"] },
          { key: "arcana", name: "の秘儀", rank: 2, options: ["magAtk", "magPen"] },
          {
            key: "seeker",
            name: "の探究者",
            rank: 2,
            options: ["dropRate", "rarity"],
          },
          { key: "raider", name: "の急襲", rank: 2, options: ["speed", "critRate"] },
          { key: "moon", name: "の月輪", rank: 2, options: ["magDef", "cooldown"] },
          { key: "ember", name: "の焔", rank: 2, options: ["critDamage", "physAtk"] },
          { key: "frost", name: "の氷刃", rank: 2, options: ["magAtk", "dotResist"] },
          { key: "warden", name: "の番人", rank: 2, options: ["controlResist", "hp"] },
          { key: "trickster", name: "の幻影", rank: 2, options: ["evade", "critRate"] },
          { key: "savant", name: "の賢達", rank: 2, options: ["int", "cooldown"] },
          { key: "vanguard", name: "の前衛", rank: 2, options: ["physAtk", "hp"] },
          { key: "sustain", name: "の滋養", rank: 2, options: ["hpRegen", "hp"] },
          { key: "ritual", name: "の儀式", rank: 2, options: ["magAtk", "mp"] },
          { key: "tempestTrail", name: "の旋風", rank: 2, options: ["speed", "critDamage"] },
          { key: "prosperity", name: "の繁栄", rank: 2, options: ["goldChance", "luck"] },
          { key: "seashadow", name: "の潮影", rank: 2, options: ["magDef", "evade"] },
          { key: "duskveil", name: "の黄昏", rank: 2, options: ["magAtk", "rarity"] },
          { key: "howl", name: "の咆哮", rank: 2, options: ["physAtk", "physPen"] },
          { key: "omen", name: "の予兆", rank: 2, options: ["critRate", "magAtk"] },
          { key: "comet", name: "の彗星", rank: 2, options: ["speed", "namedRate"] },
          {
            key: "bulwark",
            name: "の壁陣",
            rank: 2,
            options: ["physDef", "block", "damageReduction"],
          },
          { key: "arcana", name: "の秘儀", rank: 2, options: ["magAtk", "magPen"] },
          {
            key: "seeker",
            name: "の探究者",
            rank: 2,
            options: ["dropRate", "rarity"],
          },
          {
            key: "raider",
            name: "の急襲",
            rank: 2,
            options: ["speed", "critRate", "physAtk"],
          },
          { key: "moon", name: "の月輪", rank: 2, options: ["magDef", "cooldown"] },
          { key: "ember", name: "の焔", rank: 2, options: ["critDamage", "physAtk"] },
          { key: "frost", name: "の氷刃", rank: 2, options: ["magAtk", "dotResist"] },
          { key: "warden", name: "の番人", rank: 2, options: ["controlResist", "hp"] },
          { key: "trickster", name: "の幻影", rank: 2, options: ["evade", "critRate"] },
          { key: "savant", name: "の賢達", rank: 2, options: ["int", "cooldown"] },
          { key: "vanguard", name: "の前衛", rank: 2, options: ["physAtk", "hp"] },
          { key: "sustain", name: "の滋養", rank: 2, options: ["hpRegen", "hp"] },
          { key: "ritual", name: "の儀式", rank: 2, options: ["magAtk", "mp"] },
          { key: "tempestTrail", name: "の旋風", rank: 2, options: ["speed", "critDamage"] },
          { key: "prosperity", name: "の繁栄", rank: 2, options: ["goldChance", "luck"] },
          { key: "seashadow", name: "の潮影", rank: 2, options: ["magDef", "evade"] },
          { key: "duskveil", name: "の黄昏", rank: 2, options: ["magAtk", "rarity"] },
          { key: "howl", name: "の咆哮", rank: 2, options: ["physAtk", "physPen"] },
          { key: "omen", name: "の予兆", rank: 2, options: ["critRate", "magAtk"] },
          { key: "comet", name: "の彗星", rank: 2, options: ["speed", "namedRate"] },
          {
            key: "conqueror",
            name: "の覇者",
            rank: 3,
            options: ["physAtk", "physPen", "critRate"],
          },
          {
            key: "eternal",
            name: "の終焉",
            rank: 3,
            options: ["magAtk", "magPen", "debuffResist"],
          },
          {
            key: "guardian",
            name: "の守護者",
            rank: 2,
            options: ["hp", "physDef", "magDef"],
          },
          {
            key: "storm",
            name: "の雷鳴",
            rank: 2,
            options: ["speed", "critRate"],
          },
          {
            key: "void",
            name: "の虚無",
            rank: 3,
            options: ["magAtk", "dotResist", "controlResist"],
          },
          {
            key: "study",
            name: "の研磨",
            rank: 3,
            options: ["magAtk", "mp"],
            primaryPerLevelStats: ["int"],
          },
          {
            key: "foundation",
            name: "の礎",
            rank: 3,
            options: ["rarity", "dropRate"],
            primaryFixedStats: ["luck"],
          },
          {
            key: "chain",
            name: "の連環",
            rank: 3,
            options: ["critDamage", "speed"],
            attackCountBonus: true,
          },
          {
            key: "r3Cascade",
            name: "の連鎖",
            rank: 3,
            options: ["cooldown", "magAtk"],
            attackTargetsBonus: 1,
          },
          {
            key: "r3Fervor",
            name: "の鼓舞",
            rank: 3,
            options: ["hp", "speed", "cooldown"],
          },
          {
            key: "r3Clarity",
            name: "の明晰",
            rank: 3,
            options: ["mp", "cooldown", "magAtk"],
          },
          {
            key: "r3Valor",
            name: "の勇猛",
            rank: 3,
            options: ["physAtk", "critDamage", "str"],
          },
          {
            key: "r3Aegis",
            name: "の堅守",
            rank: 3,
            options: ["hp", "physDef", "block"],
          },
          {
            key: "r3Eclipse",
            name: "の蝕",
            rank: 3,
            options: ["magAtk", "debuffResist", "dotResist"],
          },
          {
            key: "r3Tempest",
            name: "の暴風",
            rank: 3,
            options: ["speed", "critRate", "evade"],
          },
          {
            key: "r3Sear",
            name: "の灼熱",
            rank: 3,
            options: ["physPen", "physAtk", "hp"],
          },
          {
            key: "r3Glacier",
            name: "の氷河",
            rank: 3,
            options: ["magDef", "magPen", "hp"],
          },
          {
            key: "r3Insight",
            name: "の洞察",
            rank: 3,
            options: ["int", "mp", "rarity"],
          },
          {
            key: "r3Pilgrim",
            name: "の巡礼",
            rank: 3,
            options: ["hpRegen", "hp", "debuffResist"],
          },
          {
            key: "r3Tides",
            name: "の潮流",
            rank: 3,
            options: ["magDef", "dropRate", "luck"],
          },
          {
            key: "r3Moonshadow",
            name: "の月影",
            rank: 3,
            options: ["evade", "speed", "magAtk"],
          },
          {
            key: "r3Thorns",
            name: "の荊棘",
            rank: 3,
            options: ["damageReduction", "hp", "lifeSteal"],
          },
          {
            key: "r3Harmony",
            name: "の調律",
            rank: 3,
            options: ["cooldown", "controlResist", "magDef"],
          },
          {
            key: "r3Rampage",
            name: "の猛進",
            rank: 3,
            options: ["critRate", "physAtk", "speed"],
          },
          {
            key: "r3Sanctuary",
            name: "の聖域",
            rank: 3,
            options: ["barrier", "hp", "magDef"],
          },
          {
            key: "r3Revelation",
            name: "の啓示",
            rank: 3,
            options: ["titleChance", "namedRate", "rarity"],
          },
          {
            key: "r3Windlash",
            name: "の疾風",
            rank: 3,
            options: ["speed", "critDamage", "cooldown"],
          },
          {
            key: "r3Aether",
            name: "の霊気",
            rank: 3,
            options: ["magAtk", "mp", "magPen"],
          },
          {
            key: "r3Fortune",
            name: "の金環",
            rank: 3,
            options: ["goldChance", "dropRate", "luck"],
          },
        ];

        function buildPrimaryGrowthTitles(kind) {
          return TITLE_PRIMARY_GROWTH_BLUEPRINTS.flatMap((blueprint) =>
            (kind === "prefix"
              ? blueprint.prefixRanks
              : blueprint.suffixRanks
            ).map((rankDef) => ({
              key: `growth-${blueprint.stat}-${kind}-r${rankDef.rank}`,
              name: rankDef.name,
              rank: rankDef.rank,
              options: rankDef.options,
              primaryPerLevelStats: [blueprint.stat],
            })),
          );
        }

        function buildPrimaryFixedTitles(kind) {
          return TITLE_PRIMARY_FIXED_BLUEPRINTS.flatMap((blueprint) =>
            (kind === "prefix"
              ? blueprint.prefixRanks
              : blueprint.suffixRanks
            ).map((rankDef) => ({
              key: `fixed-${blueprint.stat}-${kind}-r${rankDef.rank}`,
              name: rankDef.name,
              rank: rankDef.rank,
              options: rankDef.options,
              primaryFixedStats: [blueprint.stat],
            })),
          );
        }

        function buildAttackCountTitles(kind) {
          const rankDefs =
            kind === "prefix"
              ? TITLE_ATTACK_COUNT_BLUEPRINT.prefixRanks
              : TITLE_ATTACK_COUNT_BLUEPRINT.suffixRanks;
          return rankDefs.map((rankDef) => ({
            key: `attack-${kind}-r${rankDef.rank}`,
            name: rankDef.name,
            rank: rankDef.rank,
            options: rankDef.options,
            attackCountBonus: true,
          }));
        }

        const EQUIPMENT_TITLE_PREFIXES = [
          ...BASE_EQUIPMENT_TITLE_PREFIXES,
          ...buildPrimaryGrowthTitles("prefix"),
          ...buildPrimaryFixedTitles("prefix"),
          ...buildAttackCountTitles("prefix"),
        ];

        const EQUIPMENT_TITLE_SUFFIXES = [
          ...BASE_EQUIPMENT_TITLE_SUFFIXES,
          ...buildPrimaryGrowthTitles("suffix"),
          ...buildPrimaryFixedTitles("suffix"),
          ...buildAttackCountTitles("suffix"),
        ];

        const LEGENDARY_EQUIPMENT_LIBRARY = {
          weapon: [
            {
              key: "celestiaFrostbrand",
              name: "氷蔦の凍刃",
              base: [
                { key: "physAtk", range: [33, 48] },
                { key: "magAtk", range: [18, 27] },
                { key: "speed", range: [5, 9] },
                { key: "accuracy", range: [12, 18], unit: "%" },
                { key: "cooldown", range: [6, 10], unit: "%" },
              ],
              unique: {
                key: "celestiaFrostbrand",
                name: "氷蔦の束縛",
                range: [32, 48],
                unit: "%",
                effect: "スキル命中時、{value}%で速度低下(2T)＋スタン(1T)",
                trigger: "skillHit",
                payload: {
                  type: "statusMulti",
                  list: [
                    {
                      key: "speedDown",
                      duration: 2,
                      potency: 0.28,
                      chanceFromValue: true,
                    },
                    { key: "stun", duration: 1, chanceFromValue: true },
                  ],
                },
              },
            },
            {
              key: "frostvineEdge",
              name: "氷蔦の刃",
              base: [
                { key: "physAtk", range: [30, 45] },
                { key: "magAtk", range: [18, 27] },
                { key: "cooldown", range: [6, 10], unit: "%" },
                { key: "magPen", range: [8, 14], unit: "%" },
                { key: "hp", range: [42, 69] },
              ],
              unique: {
                key: "frostvineEdge",
                name: "氷蔦の霧縛",
                range: [28, 45],
                unit: "%",
                effect: "攻撃命中時、{value}%で速度低下(2T)＋魔防低下(2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    {
                      key: "speedDown",
                      duration: 2,
                      potency: 0.25,
                      chanceFromValue: true,
                    },
                    {
                      key: "magDefenseDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
            {
              key: "crystalBloomSpear",
              name: "結晶花の槍",
              base: [
                { key: "physAtk", range: [33, 48] },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [36, 60] },
                { key: "cooldown", range: [6, 10], unit: "%" },
              ],
              unique: {
                key: "crystalBloomSpear",
                name: "結晶花の衝撃",
                range: [25, 40],
                unit: "%",
                effect: "クリティカル時、{value}%でスタン(1T)",
                trigger: "critical",
                payload: {
                  type: "status",
                  key: "stun",
                  duration: 1,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "rimebindHalberd",
              name: "霜縛の戦槍",
              base: [
                { key: "physAtk", range: [36, 54] },
                { key: "magAtk", range: [18, 27] },
                { key: "accuracy", range: [12, 18], unit: "%" },
                { key: "hp", range: [45, 75] },
                { key: "speed", range: [5, 9] },
              ],
              unique: {
                key: "rimebindHalberd",
                name: "霜縛の沈黙",
                range: [28, 42],
                unit: "%",
                effect: "攻撃命中時、{value}%で沈黙(2T)",
                trigger: "hit",
                payload: {
                  type: "status",
                  key: "silence",
                  duration: 2,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "iceheartBlade",
              name: "氷心の剣",
              base: [
                { key: "physAtk", range: [33, 48] },
                { key: "critDamage", range: [15, 24], unit: "%" },
                { key: "accuracy", range: [12, 18], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [42, 69] },
              ],
              unique: {
                key: "iceheartBlade",
                name: "氷心の追撃",
                range: [18, 30],
                unit: "%",
                effect: "速度低下中の敵への与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "targetStatus", key: "speedDown" },
                },
              },
            },
            {
              key: "fenradiaDawnbreaker",
              name: "黎明竜の天剣",
              base: [
                { key: "physAtk", range: [84, 114] },
                { key: "magAtk", range: [36, 54] },
                { key: "hp", range: [120, 180] },
                { key: "critRate", range: [15, 24], unit: "%" },
                { key: "damageReduction", range: [12, 18], unit: "%" },
              ],
              unique: {
                key: "fenradiaDawnbreaker",
                name: "黎明の審典",
                range: [20, 30],
                unit: "%",
                effect: "HP50%以上で被ダメ-{value}、50%未満で与ダメ+{value}",
                trigger: ["damageMultiplier", "damageTakenMultiplier"],
                payload: {
                  type: "multiTrigger",
                  byTrigger: {
                    damageMultiplier: {
                      type: "damageMultiplier",
                      condition: { type: "hpBelow", threshold: 0.5 },
                    },
                    damageTakenMultiplier: {
                      type: "damageTakenMultiplier",
                      condition: { type: "hpAbove", threshold: 0.5 },
                    },
                  },
                },
              },
            },
            {
              key: "auroraJudicator",
              name: "暁光の断罪剣",
              base: [
                { key: "physAtk", range: [78, 108] },
                { key: "magAtk", range: [33, 48] },
                { key: "hp", range: [108, 168] },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "speed", range: [6, 10] },
              ],
              unique: {
                key: "auroraJudicator",
                name: "暁光の結界",
                range: [18, 28],
                unit: "%",
                effect:
                  "戦闘開始時、既存バリア+最大HPの{value}%を上限にバリアを得る",
                trigger: "battleStart",
                payload: {
                  type: "barrier",
                  percentFromValue: true,
                  capWithBarrierMax: true,
                },
              },
            },
            {
              key: "eclipseSovereign",
              name: "終焉の王剣",
              base: [
                { key: "physAtk", range: [81, 111] },
                { key: "magAtk", range: [33, 48] },
                { key: "critDamage", range: [21, 33], unit: "%" },
                { key: "hp", range: [114, 174] },
                { key: "damageReduction", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "eclipseSovereign",
                name: "終星の裁き",
                range: [24, 38],
                unit: "%",
                effect: "クリティカル時、{value}%で火傷＋呪い＋沈黙(各2T)",
                trigger: "critical",
                payload: {
                  type: "statusMulti",
                  list: [
                    { key: "burn", duration: 2, chanceFromValue: true },
                    { key: "curse", duration: 2, chanceFromValue: true },
                    { key: "silence", duration: 2, chanceFromValue: true },
                  ],
                },
              },
            },
            {
              key: "dawnsigilBlade",
              name: "黎明の戒剣",
              base: [
                { key: "physAtk", range: [78, 108] },
                { key: "accuracy", range: [15, 24], unit: "%" },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "hp", range: [102, 156] },
                { key: "speed", range: [6, 10] },
              ],
              unique: {
                key: "dawnsigilBlade",
                name: "黎明の刻印",
                range: [22, 36],
                unit: "%",
                effect: "攻撃命中時、{value}%で物防低下＋魔防低下(2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    {
                      key: "physDefenseDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                    {
                      key: "magDefenseDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
            {
              key: "finalPromise",
              name: "終約の聖剣",
              base: [
                { key: "physAtk", range: [81, 111] },
                { key: "magAtk", range: [33, 48] },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "hp", range: [108, 168] },
                { key: "damageReduction", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "finalPromise",
                name: "終約の追撃",
                range: [18, 30],
                unit: "%",
                effect: "呪い中の敵への与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "targetStatus", key: "curse" },
                },
              },
            },
          ],
          subWeapon: [
            {
              key: "ignisioCinderOrb",
              name: "燼滅の火球珠",
              base: [
                { key: "magAtk", range: [42, 60] },
                { key: "mp", range: [66, 102] },
                { key: "burn", range: [12, 18] },
                { key: "cooldown", range: [7, 12], unit: "%" },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "ignisioCinderOrb",
                name: "燼滅の火脈",
                range: [35, 55],
                unit: "%",
                effect: "クリティカル時、{value}%で火傷(2T)を付与",
                trigger: "critical",
                payload: {
                  type: "status",
                  key: "burn",
                  duration: 2,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "emberCenser",
              name: "熾火の香炉",
              base: [
                { key: "magAtk", range: [39, 57] },
                { key: "mp", range: [66, 102] },
                { key: "burn", range: [12, 18] },
                { key: "cooldown", range: [7, 12], unit: "%" },
                { key: "magPen", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "emberCenser",
                name: "熾火の封印",
                range: [28, 45],
                unit: "%",
                effect: "攻撃命中時、{value}%で火傷(2T)＋魔防低下(2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    { key: "burn", duration: 2, chanceFromValue: true },
                    {
                      key: "magDefenseDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
            {
              key: "pyreSigil",
              name: "燼滅の紋章",
              base: [
                { key: "magAtk", range: [36, 54] },
                { key: "mp", range: [60, 96] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "hp", range: [60, 96] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "pyreSigil",
                name: "燼滅の昂揚",
                range: [35, 55],
                unit: "%",
                effect: "戦闘開始時、{value}%で集中(2T)",
                trigger: "battleStart",
                payload: { type: "buff", key: "focus", duration: 2, chanceFromValue: true },
              },
            },
            {
              key: "ashbrandTotem",
              name: "灰燼の祭具",
              base: [
                { key: "magAtk", range: [39, 57] },
                { key: "mp", range: [66, 102] },
                { key: "burn", range: [12, 18] },
                { key: "cooldown", range: [7, 12], unit: "%" },
                { key: "hp", range: [60, 96] },
              ],
              unique: {
                key: "ashbrandTotem",
                name: "灰燼の呪焔",
                range: [30, 48],
                unit: "%",
                effect: "スキル命中時、{value}%で火傷＋呪い(各2T)",
                trigger: "skillHit",
                payload: {
                  type: "statusMulti",
                  list: [
                    { key: "burn", duration: 2, chanceFromValue: true },
                    { key: "curse", duration: 2, chanceFromValue: true },
                  ],
                },
              },
            },
            {
              key: "blazeMirror",
              name: "炎鏡の護符",
              base: [
                { key: "magAtk", range: [36, 54] },
                { key: "mp", range: [60, 96] },
                { key: "magDef", range: [21, 33] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "blazeMirror",
                name: "炎鏡の共鳴",
                range: [18, 30],
                unit: "%",
                effect: "火傷中の敵への与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "targetStatus", key: "burn" },
                },
              },
            },
          ],
          head: [
            {
              key: "zharafSandmask",
              name: "砂紋の狩眼帽",
              base: [
                { key: "accuracy", range: [15, 24], unit: "%" },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "agi", range: [6, 10] },
                { key: "hp", range: [36, 60] },
                { key: "evade", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "zharafSandmask",
                name: "砂紋の狙眼",
                range: [30, 46],
                unit: "%",
                effect: "攻撃命中時、{value}%で命中低下(2T)＋出血(2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    {
                      key: "accuracyDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                    { key: "bleed", duration: 2, chanceFromValue: true },
                  ],
                },
              },
            },
            {
              key: "duneTrackerHelm",
              name: "砂紋の追跡兜",
              base: [
                { key: "accuracy", range: [12, 21], unit: "%" },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [36, 60] },
                { key: "evade", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "duneTrackerHelm",
                name: "砂紋の掠奪",
                range: [28, 45],
                unit: "%",
                effect: "クリティカル時、{value}%で出血＋回避低下(各2T)",
                trigger: "critical",
                payload: {
                  type: "statusMulti",
                  list: [
                    { key: "bleed", duration: 2, chanceFromValue: true },
                    {
                      key: "evasionDown",
                      duration: 2,
                      potency: 0.2,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
            {
              key: "mirageSeekerHood",
              name: "幻砂の頭巾",
              base: [
                { key: "agi", range: [6, 10] },
                { key: "evade", range: [15, 24], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [39, 63] },
                { key: "critRate", range: [9, 18], unit: "%" },
              ],
              unique: {
                key: "mirageSeekerHood",
                name: "幻砂の浄化",
                range: [32, 50],
                unit: "%",
                effect: "ターン開始時、{value}%で状態異常1つ解除＆HP4%回復",
                trigger: "turnStart",
                payload: {
                  type: "cleanse",
                  chanceFromValue: true,
                  healPercent: 4,
                },
              },
            },
            {
              key: "sandstormVisor",
              name: "砂嵐の仮面",
              base: [
                { key: "accuracy", range: [12, 21], unit: "%" },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [42, 69] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "sandstormVisor",
                name: "砂嵐の圧迫",
                range: [18, 30],
                unit: "%",
                effect: "弱体化中の敵への与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "targetDebuffed" },
                },
              },
            },
            {
              key: "whisperingDuneCowl",
              name: "囁き砂のフード",
              base: [
                { key: "accuracy", range: [12, 21], unit: "%" },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "hp", range: [39, 63] },
                { key: "critRate", range: [9, 18], unit: "%" },
              ],
              unique: {
                key: "whisperingDuneCowl",
                name: "砂音の攪乱",
                range: [25, 40],
                unit: "%",
                effect: "攻撃命中時、{value}%で混乱(1T)",
                trigger: "hit",
                payload: {
                  type: "status",
                  key: "confusion",
                  duration: 1,
                  chanceFromValue: true,
                },
              },
            },
          ],
          body: [
            {
              key: "aeroScoutMantle",
              name: "灰翼の遊撃衣",
              base: [
                { key: "physDef", range: [24, 36] },
                { key: "speed", range: [6, 10] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "hp", range: [60, 96] },
                { key: "agi", range: [6, 10] },
              ],
              unique: {
                key: "aeroScoutMantle",
                name: "灰翼の奇襲",
                range: [20, 32],
                unit: "%",
                effect:
                  "先制ターンの与ダメ+{value}、回避成功時に{value}%で次の通常攻撃が必中化",
                trigger: ["damageMultiplier", "evade"],
                payload: {
                  type: "multiTrigger",
                  byTrigger: {
                    damageMultiplier: {
                      type: "damageMultiplier",
                      condition: { type: "openingTurn" },
                    },
                    evade: {
                      type: "guaranteedHit",
                      chanceFromValue: true,
                    },
                  },
                },
              },
            },
            {
              key: "greywingHauberk",
              name: "灰翼の軽鎧",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "speed", range: [6, 10] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "hp", range: [54, 90] },
                { key: "agi", range: [6, 10] },
              ],
              unique: {
                key: "greywingHauberk",
                name: "灰翼の結界",
                range: [18, 28],
                unit: "%",
                effect: "戦闘開始時、最大HPの{value}%分バリアを得る",
                trigger: "battleStart",
                payload: { type: "barrier", percentFromValue: true },
              },
            },
            {
              key: "toxinPlumeCoat",
              name: "毒煙の外套",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "speed", range: [6, 10] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "hp", range: [54, 90] },
                { key: "accuracy", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "toxinPlumeCoat",
                name: "毒煙の追撃",
                range: [28, 45],
                unit: "%",
                effect: "攻撃命中時、{value}%で毒(2T)＋速度低下(2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    { key: "poison", duration: 2, chanceFromValue: true },
                    {
                      key: "speedDown",
                      duration: 2,
                      potency: 0.25,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
            {
              key: "windpiercerCuirass",
              name: "疾風貫きの胴衣",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "hp", range: [57, 93] },
                { key: "critRate", range: [9, 18], unit: "%" },
              ],
              unique: {
                key: "windpiercerCuirass",
                name: "追い風の鼓動",
                range: [25, 40],
                unit: "%",
                effect: "クリティカル時、{value}%で加速(2T)",
                trigger: "critical",
                payload: { type: "buff", key: "haste", duration: 2, chanceFromValue: true },
              },
            },
            {
              key: "scoutCaptainCoat",
              name: "斥候長の外衣",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "speed", range: [6, 10] },
                { key: "evade", range: [15, 24], unit: "%" },
                { key: "hp", range: [54, 90] },
                { key: "accuracy", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "scoutCaptainCoat",
                name: "斥候長の呼吸",
                range: [6, 12],
                unit: "%",
                effect: "回避成功時、最大HPの{value}%回復",
                trigger: "evade",
                payload: { type: "heal", percentFromValue: true, chance: 100 },
              },
            },
            {
              key: "garoldThunderplate",
              name: "雷礫の戦装",
              base: [
                { key: "physDef", range: [30, 45] },
                { key: "hp", range: [96, 150] },
                { key: "physAtk", range: [21, 33] },
                { key: "critDamage", range: [15, 24], unit: "%" },
                { key: "speed", range: [5, 9] },
              ],
              unique: {
                key: "garoldThunderplate",
                name: "雷礫の戦啓",
                range: [28, 45],
                unit: "%",
                effect: "クリティカル時、{value}%でこのターン攻撃回数+1",
                trigger: "critical",
                payload: { type: "extraAttack", amount: 1, chanceFromValue: true },
              },
            },
            {
              key: "stormcoreArmor",
              name: "雷核の重鎧",
              base: [
                { key: "physDef", range: [33, 48] },
                { key: "hp", range: [99, 156] },
                { key: "damageReduction", range: [9, 15], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "critRate", range: [9, 18], unit: "%" },
              ],
              unique: {
                key: "stormcoreArmor",
                name: "雷核の衝撃",
                range: [22, 36],
                unit: "%",
                effect: "攻撃命中時、{value}%でスタン(1T)",
                trigger: "hit",
                payload: { type: "status", key: "stun", duration: 1, chanceFromValue: true },
              },
            },
            {
              key: "thunderousMail",
              name: "轟雷の戦衣",
              base: [
                { key: "physDef", range: [30, 45] },
                { key: "hp", range: [96, 150] },
                { key: "physAtk", range: [21, 33] },
                { key: "speed", range: [5, 9] },
                { key: "critRate", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "thunderousMail",
                name: "雷戦の昂揚",
                range: [30, 48],
                unit: "%",
                effect: "スキル命中時、{value}%で集中(2T)",
                trigger: "skillHit",
                payload: { type: "buff", key: "focus", duration: 2, chanceFromValue: true },
              },
            },
            {
              key: "lightningWardCoat",
              name: "雷護の鎧衣",
              base: [
                { key: "physDef", range: [30, 45] },
                { key: "hp", range: [99, 156] },
                { key: "damageReduction", range: [9, 15], unit: "%" },
                { key: "speed", range: [5, 9] },
                { key: "block", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "lightningWardCoat",
                name: "雷護の耐久",
                range: [16, 26],
                unit: "%",
                effect: "HP50%未満で被ダメ-{value}%",
                trigger: "damageTakenMultiplier",
                payload: {
                  type: "damageTakenMultiplier",
                  condition: { type: "hpBelow", threshold: 0.5 },
                },
              },
            },
            {
              key: "shockchainVest",
              name: "雷鎖の戦衣",
              base: [
                { key: "physDef", range: [30, 45] },
                { key: "hp", range: [96, 150] },
                { key: "speed", range: [6, 10] },
                { key: "critRate", range: [9, 18], unit: "%" },
                { key: "accuracy", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "shockchainVest",
                name: "雷鎖の拘束",
                range: [24, 38],
                unit: "%",
                effect: "攻撃命中時、{value}%で速度低下＋命中低下(各2T)",
                trigger: "hit",
                payload: {
                  type: "statusMulti",
                  list: [
                    {
                      key: "speedDown",
                      duration: 2,
                      potency: 0.25,
                      chanceFromValue: true,
                    },
                    {
                      key: "accuracyDown",
                      duration: 2,
                      potency: 0.15,
                      chanceFromValue: true,
                    },
                  ],
                },
              },
            },
          ],
          hands: [
            {
              key: "granphosAurumGauntlet",
              name: "宝守の豪腕",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "hp", range: [48, 84] },
                { key: "block", range: [12, 21], unit: "%" },
                { key: "damageReduction", range: [6, 12], unit: "%" },
                { key: "str", range: [6, 10] },
              ],
              unique: {
                key: "granphosAurumGauntlet",
                name: "宝守の反撃",
                range: [12, 18],
                unit: "%",
                effect: "ブロック成功時、最大HPの{value}%分バリアを得る",
                trigger: "block",
                payload: { type: "barrier", percentFromValue: true },
              },
            },
            {
              key: "hoardwardenGrips",
              name: "宝庫守りの手袋",
              base: [
                { key: "physDef", range: [21, 33] },
                { key: "hp", range: [48, 84] },
                { key: "block", range: [12, 21], unit: "%" },
                { key: "damageReduction", range: [6, 12], unit: "%" },
                { key: "vit", range: [6, 10] },
              ],
              unique: {
                key: "hoardwardenGrips",
                name: "宝庫の守勢",
                range: [30, 48],
                unit: "%",
                effect: "ターン開始時、{value}%で防御(2T)",
                trigger: "turnStart",
                payload: { type: "buff", key: "guard", duration: 2, chanceFromValue: true },
              },
            },
            {
              key: "coinforgedFists",
              name: "金鋳の拳",
              base: [
                { key: "physAtk", range: [24, 36] },
                { key: "hp", range: [45, 78] },
                { key: "block", range: [9, 15], unit: "%" },
                { key: "damageReduction", range: [6, 12], unit: "%" },
                { key: "str", range: [6, 10] },
              ],
              unique: {
                key: "coinforgedFists",
                name: "金鋳の圧力",
                range: [28, 45],
                unit: "%",
                effect: "攻撃命中時、{value}%で物理攻撃ダウン(2T)",
                trigger: "hit",
                payload: {
                  type: "status",
                  key: "physAttackDown",
                  duration: 2,
                  potency: 0.2,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "gildedBulwarkClaw",
              name: "金壁の鉤爪",
              base: [
                { key: "physDef", range: [24, 36] },
                { key: "hp", range: [54, 90] },
                { key: "block", range: [12, 21], unit: "%" },
                { key: "damageReduction", range: [6, 12], unit: "%" },
                { key: "vit", range: [6, 10] },
              ],
              unique: {
                key: "gildedBulwarkClaw",
                name: "金壁の護り",
                range: [16, 26],
                unit: "%",
                effect: "HP50%以上で被ダメ-{value}%",
                trigger: "damageTakenMultiplier",
                payload: {
                  type: "damageTakenMultiplier",
                  condition: { type: "hpAbove", threshold: 0.5 },
                },
              },
            },
            {
              key: "vaultbreakerTalons",
              name: "宝殻砕きの爪",
              base: [
                { key: "physAtk", range: [27, 42] },
                { key: "hp", range: [48, 84] },
                { key: "critRate", range: [12, 21], unit: "%" },
                { key: "damageReduction", range: [6, 12], unit: "%" },
                { key: "str", range: [6, 10] },
              ],
              unique: {
                key: "vaultbreakerTalons",
                name: "宝殻の粉砕",
                range: [24, 39],
                unit: "%",
                effect: "クリティカル時、{value}%でスタン(1T)",
                trigger: "critical",
                payload: { type: "status", key: "stun", duration: 1, chanceFromValue: true },
              },
            },
          ],
          accessory: [
            {
              key: "rivanTideGlyph",
              name: "深渦の調律符",
              base: [
                { key: "mp", range: [72, 108] },
                { key: "magDef", range: [21, 33] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "controlResist", range: [15, 24], unit: "%" },
                { key: "speed", range: [4, 7] },
              ],
              unique: {
                key: "rivanTideGlyph",
                name: "深渦の律",
                range: [40, 60],
                unit: "%",
                effect: "ターン開始時、{value}%で状態異常1つ解除＆HP5%回復",
                trigger: "turnStart",
                payload: { type: "cleanse", chanceFromValue: true, healPercent: 5 },
              },
            },
            {
              key: "wavecrestCharm",
              name: "潮峰の護符",
              base: [
                { key: "mp", range: [66, 102] },
                { key: "magDef", range: [21, 33] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "speed", range: [4, 7] },
                { key: "controlResist", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "wavecrestCharm",
                name: "潮峰の遅滞",
                range: [28, 45],
                unit: "%",
                effect: "攻撃命中時、{value}%で速度低下(2T)",
                trigger: "hit",
                payload: {
                  type: "status",
                  key: "speedDown",
                  duration: 2,
                  potency: 0.25,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "abyssRhythmRing",
              name: "深渦の律環",
              base: [
                { key: "mp", range: [66, 102] },
                { key: "magAtk", range: [21, 33] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "controlResist", range: [12, 21], unit: "%" },
                { key: "speed", range: [4, 7] },
              ],
              unique: {
                key: "abyssRhythmRing",
                name: "深渦の律動",
                range: [24, 38],
                unit: "%",
                effect: "スキル命中時、{value}%でスキルCT-1",
                trigger: "skillHit",
                payload: { type: "cooldown", amount: 1, chanceFromValue: true },
              },
            },
            {
              key: "deepflowPendant",
              name: "深潮のペンダント",
              base: [
                { key: "mp", range: [72, 108] },
                { key: "magDef", range: [21, 33] },
                { key: "speed", range: [4, 7] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "controlResist", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "deepflowPendant",
                name: "深潮の循環",
                range: [8, 14],
                unit: "%",
                effect: "攻撃命中時、MPを最大値の{value}%回復",
                trigger: "hit",
                payload: { type: "mp", percentFromValue: true, chance: 100 },
              },
            },
            {
              key: "sirenPulseAmulet",
              name: "深渦の奏環",
              base: [
                { key: "mp", range: [66, 102] },
                { key: "magAtk", range: [21, 33] },
                { key: "cooldown", range: [6, 11], unit: "%" },
                { key: "speed", range: [4, 7] },
                { key: "controlResist", range: [12, 21], unit: "%" },
              ],
              unique: {
                key: "sirenPulseAmulet",
                name: "深渦の共鳴",
                range: [18, 30],
                unit: "%",
                effect: "集中中の与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "hasBuff", key: "focus" },
                },
              },
            },
          ],
          feet: [
            {
              key: "ordoVoidstride",
              name: "虚星の巡礼靴",
              base: [
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "damageReduction", range: [6, 11], unit: "%" },
                { key: "hp", range: [36, 60] },
                { key: "accuracy", range: [9, 15], unit: "%" },
              ],
              unique: {
                key: "ordoVoidstride",
                name: "虚星の追撃",
                range: [18, 30],
                unit: "%",
                effect: "弱体化中の敵への与ダメ+{value}%",
                trigger: "damageMultiplier",
                payload: {
                  type: "damageMultiplier",
                  condition: { type: "targetDebuffed" },
                },
              },
            },
            {
              key: "inquisitionTreads",
              name: "審問官の軍靴",
              base: [
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "accuracy", range: [9, 15], unit: "%" },
                { key: "hp", range: [36, 60] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "inquisitionTreads",
                name: "審問の静寂",
                range: [26, 40],
                unit: "%",
                effect: "攻撃命中時、{value}%で沈黙(2T)",
                trigger: "hit",
                payload: {
                  type: "status",
                  key: "silence",
                  duration: 2,
                  chanceFromValue: true,
                },
              },
            },
            {
              key: "starlessGreaves",
              name: "無星の足甲",
              base: [
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "accuracy", range: [9, 15], unit: "%" },
                { key: "hp", range: [36, 60] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "starlessGreaves",
                name: "無星の呪縛",
                range: [24, 38],
                unit: "%",
                effect: "クリティカル時、{value}%で呪い(2T)",
                trigger: "critical",
                payload: { type: "status", key: "curse", duration: 2, chanceFromValue: true },
              },
            },
            {
              key: "nullwalkerBoots",
              name: "虚無渡りの靴",
              base: [
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [15, 24], unit: "%" },
                { key: "accuracy", range: [9, 15], unit: "%" },
                { key: "hp", range: [36, 60] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "nullwalkerBoots",
                name: "虚無の回避",
                range: [6, 12],
                unit: "%",
                effect: "回避成功時、最大HPの{value}%回復",
                trigger: "evade",
                payload: { type: "heal", percentFromValue: true, chance: 100 },
              },
            },
            {
              key: "voidstepSabaton",
              name: "虚踏のサバトン",
              base: [
                { key: "speed", range: [7, 12] },
                { key: "evade", range: [12, 21], unit: "%" },
                { key: "accuracy", range: [9, 15], unit: "%" },
                { key: "hp", range: [36, 60] },
                { key: "damageReduction", range: [6, 11], unit: "%" },
              ],
              unique: {
                key: "voidstepSabaton",
                name: "虚踏の障壁",
                range: [16, 26],
                unit: "%",
                effect: "戦闘開始時、最大HPの{value}%分バリアを得る",
                trigger: "battleStart",
                payload: { type: "barrier", percentFromValue: true },
              },
            },
          ],
        };

        function createEmptyBonus() {
          return {
            hp: 0,
            mp: 0,
            physAtk: 0,
            magAtk: 0,
            physDef: 0,
            magDef: 0,
            speed: 0,
            critRate: 0,
            critDamage: 0,
            evade: 0,
            physPen: 0,
            magPen: 0,
            damageReduction: 0,
            block: 0,
            controlResist: 0,
            dotResist: 0,
            debuffResist: 0,
            cooldown: 0,
            hpRegen: 0,
            lifeSteal: 0,
            barrier: 0,
            dropRate: 0,
            rarity: 0,
            goldChance: 0,
            titleChance: 0,
            namedRate: 0,
          };
        }

        function createEmptyPrimaryBonus() {
          return { str: 0, int: 0, vit: 0, agi: 0, luck: 0 };
        }

        function createEmptyPrimaryFixedBonus(defaultValue = null) {
          return {
            str: defaultValue,
            int: defaultValue,
            vit: defaultValue,
            agi: defaultValue,
            luck: defaultValue,
          };
        }

        function createEmptyPrimaryPerLevelBonus() {
          return { str: [], int: [], vit: [], agi: [], luck: [] };
        }

        function clonePrimaryPerLevelBonus(source = {}) {
          const cloned = createEmptyPrimaryPerLevelBonus();
          Object.entries(source || {}).forEach(([key, effects]) => {
            if (!Array.isArray(effects)) return;
            cloned[key] = effects.map((effect) => ({ ...effect }));
          });
          return cloned;
        }

        function clonePrimaryFixedBonus(source = {}) {
          const cloned = createEmptyPrimaryFixedBonus();
          Object.entries(cloned).forEach(([key]) => {
            if (typeof source[key] === "number") cloned[key] = source[key];
          });
          return cloned;
        }

        function ensureAcquiredOrder(item) {
          if (!item) return item;
          if (typeof item.acquiredOrder !== "number") {
            item.acquiredOrder = inventoryAcquireSequence++;
          }
          if (typeof item.favorite !== "boolean") {
            item.favorite = false;
          }
          return item;
        }

        function ensureCodexState() {
          if (!game.codex) {
            game.codex = {
              enemyMonsters: {},
              enemyVariants: {},
              bosses: {},
              equipment: {},
              potions: {},
              titles: {},
            };
          }
          if (!game.codex.enemyMonsters) game.codex.enemyMonsters = {};
          return game.codex;
        }

        function markCodexEntry(type, key) {
          if (!key) return;
          const codex = ensureCodexState();
          if (!codex[type]) codex[type] = {};
          if (!codex[type][key]) {
            codex[type][key] = true;
          }
        }

        function registerCodexDiscovery(item) {
          if (!item) return;
          ensureCodexState();
          if (item.equipment) {
            const templateKey =
              item.equipment.templateKey ||
              item.equipment.legendaryKey ||
              item.slot ||
              item.equipment.slot;
            if (templateKey) markCodexEntry("equipment", templateKey);
            if (item.equipment.prefix?.key)
              markCodexEntry("titles", `prefix:${item.equipment.prefix.key}`);
            if (item.equipment.suffix?.key)
              markCodexEntry("titles", `suffix:${item.equipment.suffix.key}`);
          }
          if (item.potion) {
            const potionKey =
              item.potion.legendaryKey || item.potion.rarity === "legendary"
                ? `legendary:${item.potion.legendaryKey || item.potion.key || item.potion.variant}`
                : (() => {
                    const rawKey = item.potion.key || "";
                    const [rawTemplate, rawVariant] = rawKey.includes(":")
                      ? rawKey.split(":")
                      : [rawKey, ""];
                    const templateId =
                      item.potion.templateKey ||
                      item.potion.baseLabel ||
                      rawTemplate;
                    const variantId =
                      item.potion.variantKey ||
                      item.potion.variant ||
                      rawVariant;
                    return `potion:${templateId}:${variantId}`;
                  })();
            markCodexEntry("potions", potionKey);
          }
        }

        function hydrateCodexFromOwned() {
          ensureCodexState();
          (player.inventory?.items || []).forEach((entry) =>
            registerCodexDiscovery(entry),
          );
          (player.potions || []).forEach((potion) =>
            registerCodexDiscovery({ potion }),
          );
        }

        function getAcquiredOrder(item, fallback) {
          if (typeof item?.acquiredOrder === "number")
            return item.acquiredOrder;
          return fallback;
        }

        function randomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function pickRandom(list) {
          if (!list?.length) return null;
          return list[randomInt(0, list.length - 1)];
        }

        function weightedRandom(options, fallback = null) {
          if (!options?.length) return fallback;
          const total = options.reduce(
            (sum, opt) => sum + (opt.weight ?? 0),
            0,
          );
          if (total <= 0) return options[0] ?? fallback;
          let roll = Math.random() * total;
          for (const opt of options) {
            roll -= opt.weight ?? 0;
            if (roll <= 0) return opt;
          }
          return options[options.length - 1] ?? fallback;
        }

        function rollValueInRange(range, precision = 0) {
          const [min, max] = range;
          const raw = min + Math.random() * (max - min);
          if (precision > 0) {
            const base = 10 ** precision;
            return Math.round(raw * base) / base;
          }
          return Math.round(raw);
        }

        function getPotionRarity(key) {
          return POTION_RARITIES[key] || POTION_RARITIES.normal;
        }

        function rollPotionRarity() {
          const picked = weightedRandom(
            POTION_RARITY_WEIGHTS,
            POTION_RARITY_WEIGHTS[0],
          );
          return getPotionRarity(picked?.key);
        }

        function rollPotionAffixPool(potion, type) {
          const isRecovery = potion.category === "recovery";
          const isBuff = potion.category === "buff";
          const includeLegendary = potion.rarity === "legendary";
          const base = type === "prefix" ? POTION_PREFIXES : POTION_SUFFIXES;
          const pools = [base.general];
          if (isRecovery) pools.push(base.recovery);
          if (isBuff) pools.push(base.buff);
          if (includeLegendary) {
            pools.push(base.legendaryGeneral);
            if (isRecovery) pools.push(base.legendaryRecovery);
            if (isBuff) pools.push(base.legendaryBuff);
            pools.push(base.legendaryCost);
          }
          return pools.flat().filter(Boolean);
        }

        function rollPotionAffix(potion, type) {
          const pool = rollPotionAffixPool(potion, type);
          if (!pool.length) return null;
          return pool[randomInt(0, pool.length - 1)];
        }

        function buildPotionName(
          base,
          variant,
          rarity,
          prefix,
          suffix,
          { includeRarity = true } = {},
        ) {
          const rarityPrefix =
            includeRarity && rarity?.label ? `${rarity.label} ` : "";
          const prefixName = prefix?.name
            ? `${prefix.name}`
            : rarityPrefix.trim();
          const suffixName = suffix?.name || "";
          return `${prefixName ? `${prefixName} ` : ""}${base}${variant || ""}${suffixName}`.trim();
        }

        function rollPotionValues(
          variant,
          rarity,
          { useBaseValues = false } = {},
        ) {
          if (useBaseValues) {
            return {
              amount: variant.amount,
              useCost: variant.useCost,
              maxFullness: variant.maxFullness,
            };
          }

          const amount = Math.max(
            1,
            Math.round(
              variant.amount * rollValueInRange(rarity.amountRange, 2),
            ),
          );
          const useCost = Math.max(
            5,
            Math.round(
              variant.useCost * rollValueInRange(rarity.useCostRange, 2),
            ),
          );
          const maxFullness = Math.round(
            variant.maxFullness * rollValueInRange(rarity.fullnessRange, 2),
          );
          return { amount, useCost, maxFullness };
        }

        function describePotionEffect(potion) {
          if (potion.type === "hp") return `HPを${potion.amount}回復`;
          if (potion.type === "mp") return `MPを${potion.amount}回復`;
          return potion.effectText || potion.summary || "特殊効果";
        }

        function calculatePotionConsumption(potion) {
          if (!potion) return { useCost: 0, refund: 0 };

          const baseCost = potion.useCost ?? 25;
          let multiplier = 1;

          if (potion.prefix?.key === "thrifty") multiplier *= 0.75;
          if (potion.prefix?.key === "zeroTributePrefix") multiplier *= 0.3;
          if (potion.suffix?.key === "zeroTributeSuffix") multiplier *= 0.35;
          if (potion.suffix?.key === "efficiency") multiplier *= 0.9;

          const adjusted = Math.max(1, Math.round(baseCost * multiplier));
          const refund = potion.suffix?.key === "refill"
            ? Math.round(adjusted * 0.2)
            : 0;

          return { useCost: adjusted, refund };
        }

        function pickLegendaryPotion(preferredKey) {
          if (!LEGENDARY_POTIONS?.length) return null;
          if (preferredKey) {
            const found = LEGENDARY_POTIONS.find(
              (entry) => entry.key === preferredKey,
            );
            if (found) return found;
          }
          return LEGENDARY_POTIONS[randomInt(0, LEGENDARY_POTIONS.length - 1)];
        }

        function createLegendaryPotion(
          legendaryKey,
          { hideRarityInName = false } = {},
        ) {
          const def = pickLegendaryPotion(legendaryKey);
          const rarity = POTION_RARITIES.legendary;
          if (!def || !rarity) return null;

          const maxFullness = def.maxFullness ?? 100;
          const potion = {
            id: generateId(`potion-legendary-${def.key}`),
            legendaryKey: def.key,
            baseLabel: def.name,
            name: def.name,
            short: def.name,
            variant: def.variantLabel || "",
            type: def.type || "buff",
            category: def.category || "buff",
            amount: def.amount ?? 0,
            useCost: def.useCost ?? 55,
            maxFullness,
            fullness: maxFullness,
            rarity: rarity.key,
            rarityRank: rarity.rank,
            rarityLabel: rarity.label,
            icon: def.icon || (def.category === "recovery" ? "💧" : "✨"),
            summary: def.summary || def.tagline,
          };

          const prefix = rollPotionAffix(potion, "prefix");
          const suffix = rollPotionAffix(potion, "suffix");
          potion.prefix = prefix;
          potion.suffix = suffix;
          potion.name = buildPotionName(
            def.name,
            def.variantLabel || "",
            rarity,
            prefix,
            suffix,
            {
              includeRarity: !hideRarityInName,
            },
          );
          potion.effectText =
            def.summary || def.tagline || describePotionEffect(potion);
          if (prefix?.key)
            markCodexEntry("titles", `potion-prefix:${prefix.key}`);
          if (suffix?.key)
            markCodexEntry("titles", `potion-suffix:${suffix.key}`);
          return potion;
        }

        function createPotionFromTemplate(
          templateKey,
          variantKey,
          {
            rarityKey,
            useBaseValues = false,
            skipAffix = false,
            hideRarityInName = false,
          } = {},
        ) {
          const template = POTION_BASE_TEMPLATES[templateKey];
          const variant =
            template?.variants?.find((v) => v.key === variantKey) ||
            template?.variants?.[0];
          const rarity = rarityKey
            ? getPotionRarity(rarityKey)
            : rollPotionRarity();
          if (!template || !variant) return null;

          const { amount, useCost, maxFullness } = rollPotionValues(
            variant,
            rarity,
            { useBaseValues },
          );
          const effectText =
            typeof variant.buildEffectText === "function"
              ? variant.buildEffectText(
                  { amount, useCost, maxFullness },
                  { template, variant, rarity },
                )
              : variant.effectText;
          const potion = {
            id: generateId(`potion-${template.key}-${variant.key}`),
            templateKey: template.key,
            variantKey: variant.key,
            key: `${template.key}:${variant.key}`,
            baseLabel: template.label,
            name: template.label,
            short: variant.short,
            variant: variant.label,
            type: template.type,
            category: template.category,
            amount,
            useCost,
            maxFullness,
            fullness: maxFullness,
            rarity: rarity.key,
            rarityRank: rarity.rank,
            rarityLabel: rarity.label,
            icon: template.icon,
            summary:
              template.summary ||
              (template.type === "hp"
                ? "即時HPを取り戻す基本ポーション"
                : template.type === "mp"
                  ? "即時MPを補給する基本ポーション"
                  : "特殊な効果を持つポーション"),
          };

          const prefix = skipAffix ? null : rollPotionAffix(potion, "prefix");
          const suffix = skipAffix ? null : rollPotionAffix(potion, "suffix");
          potion.prefix = prefix;
          potion.suffix = suffix;
          potion.name = buildPotionName(
            template.label,
            variant.label,
            rarity,
            prefix,
            suffix,
            {
              includeRarity: !hideRarityInName,
            },
          );
          potion.effectText = effectText || describePotionEffect(potion);
          if (prefix?.key)
            markCodexEntry("titles", `potion-prefix:${prefix.key}`);
          if (suffix?.key)
            markCodexEntry("titles", `potion-suffix:${suffix.key}`);
          return potion;
        }

        function describePotionAffix(affix) {
          if (!affix) return "なし";
          return `${affix.name} (${affix.effect})`;
        }

        function createPotionInventoryItem(potion, { description } = {}) {
          const { useCost } = calculatePotionConsumption(potion);
          const desc =
            description ||
            `${describePotionEffect(potion)} / 消費${useCost}%`;
          return ensureAcquiredOrder({
            id: `inv-${potion.id}`,
            name: potion.name,
            desc,
            type: "potion",
            rarity:
              typeof potion.rarityRank === "number" ? potion.rarityRank : 0,
            potion: { ...potion },
          });
        }

        function rollStatValue(def, rarity) {
          const [min, max] = def.range;
          const rarityScale = 1 + (rarity?.rank ?? 0) * 0.2;
          const raw = min + Math.random() * (max - min);
          const scaled = raw * rarityScale;
          const precision = def.precision ?? (def.unit === "%" ? 1 : 0);
          if (precision > 0) {
            const base = 10 ** precision;
            return Math.round(scaled * base) / base;
          }
          return Math.round(scaled);
        }

        function computeStatRollBounds(def, rarity) {
          const [min, max] = def.range || [0, 0];
          const rarityScale = 1 + (rarity?.rank ?? 0) * 0.2;
          const precision = def.precision ?? (def.unit === "%" ? 1 : 0);
          const scaleAndRound = (value) => {
            const scaled = value * rarityScale;
            if (precision > 0) {
              const base = 10 ** precision;
              return Math.round(scaled * base) / base;
            }
            return Math.round(scaled);
          };
          return { min: scaleAndRound(min), max: scaleAndRound(max) };
        }

        function rollTemplateOptions(definitions, rarity) {
          const primaryBonus = createEmptyPrimaryBonus();
          const bonus = createEmptyBonus();
          const entries = (definitions || [])
            .map((def) => {
              const baseDef = EQUIPMENT_STAT_BY_KEY[def.key];
              if (!baseDef?.range) return null;
              const merged = {
                ...baseDef,
                ...def,
                range: def.range || baseDef.range,
                unit: def.unit ?? baseDef.unit,
                precision: def.precision ?? baseDef.precision,
              };
              const value = rollStatValue(merged, rarity);
              applyOptionToBonus(merged, value, primaryBonus, bonus);
              return {
                key: merged.key,
                label: merged.label,
                unit: merged.unit,
                type: merged.type,
                value,
              };
            })
            .filter(Boolean);

          return { entries, primaryBonus, bonus };
        }

        function pickStatOptions(count) {
          const pool = [...EQUIPMENT_STAT_POOL];
          const options = [];
          for (let i = pool.length - 1; i > 0; i -= 1) {
            const j = Math.floor(Math.random() * (i + 1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
          }
          for (let i = 0; i < count && i < pool.length; i += 1) {
            options.push(pool[i]);
          }
          return options;
        }

        function applyOptionToBonus(option, value, primaryBonus, bonus) {
          if (option.type === "primary") {
            primaryBonus[option.key] = (primaryBonus[option.key] ?? 0) + value;
          } else {
            bonus[option.key] = (bonus[option.key] ?? 0) + value;
          }
        }

        function generateEquipmentOptions(rarity, optionCount) {
          const primaryBonus = createEmptyPrimaryBonus();
          const bonus = createEmptyBonus();
          const entries = pickStatOptions(optionCount).map((option) => {
            const value = rollStatValue(option, rarity);
            applyOptionToBonus(option, value, primaryBonus, bonus);
            return {
              key: option.key,
              label: option.label,
              unit: option.unit,
              type: option.type,
              value,
            };
          });
          return { entries, primaryBonus, bonus };
        }

        function getEquipmentTierKeyForFloor(floor) {
          const boundary = EQUIPMENT_TIER_BOUNDARIES.find(
            (entry) => floor <= entry.maxFloor,
          );
          return (
            boundary?.key ||
            EQUIPMENT_TIER_KEYS[EQUIPMENT_TIER_KEYS.length - 1] ||
            "tier10"
          );
        }

        function pickEquipmentTemplate(slotKey) {
          const list = EQUIPMENT_TEMPLATE_LIBRARY[slotKey];
          if (!list?.length) return null;
          const tierOrder = EQUIPMENT_TIER_KEYS;
          const currentTier = getEquipmentTierKeyForFloor(game.floor || 1);
          const currentIndex = tierOrder.indexOf(currentTier);
          const effectiveIndex =
            currentIndex >= 0 ? currentIndex : tierOrder.length - 1;
          const candidates = list.filter((entry) => {
            if (!entry.tier) return true;
            const idx = tierOrder.indexOf(entry.tier);
            return idx === -1 ? true : idx <= effectiveIndex;
          });
          const preferredTier =
            tierOrder[Math.max(0, effectiveIndex)] || tierOrder[0];
          const prioritized = candidates.filter(
            (entry) => (entry.tier || tierOrder[0]) === preferredTier,
          );
          const pool = prioritized.length
            ? prioritized
            : candidates.length
              ? candidates
              : list;
          return pool[randomInt(0, pool.length - 1)];
        }

        function pickLegendaryEquipment(slotKey, preferredKey) {
          const list = LEGENDARY_EQUIPMENT_LIBRARY[slotKey];
          if (!list?.length) return null;
          const preferredKeys = Array.isArray(preferredKey)
            ? preferredKey
            : preferredKey
              ? [preferredKey]
              : [];
          const pool =
            preferredKeys.length > 0
              ? list.filter((entry) => preferredKeys.includes(entry.key))
              : list;
          if (pool.length) return pool[randomInt(0, pool.length - 1)];
          return list[randomInt(0, list.length - 1)];
        }

        function rollLegendaryUniqueOption(def) {
          if (!def?.unique) return null;
          const precision =
            def.unique.precision ?? (def.unique.unit === "%" ? 1 : 0);
          const value = def.unique.range
            ? rollValueInRange(def.unique.range, precision)
            : null;
          const replaced = def.unique.effect?.replace(
            "{value}",
            value != null ? `${value}${def.unique.unit || ""}` : "",
          );
          const uniqueKey = def.unique.key || def.key;
          return {
            itemName: def.name,
            option: {
              key: uniqueKey,
              name: def.unique.name,
              effect: replaced || def.unique.effect,
              value,
              unit: def.unique.unit || "",
              trigger: def.unique.trigger || "",
              payload: def.unique.payload || null,
            },
          };
        }

        function pickTitle(titles) {
          if (!titles?.length) return null;
          return titles[randomInt(0, titles.length - 1)];
        }

        function generateTitleOptions(title, rarity) {
          const primaryBonus = createEmptyPrimaryBonus();
          const bonus = createEmptyBonus();
          const primaryPerLevel = createEmptyPrimaryPerLevelBonus();
          const primaryFixed = createEmptyPrimaryFixedBonus();
          let attackCountBonus = 0;
          let attackTargetsBonus = 0;

          const entries = (title?.options || [])
            .map((key) => {
              const def = EQUIPMENT_STAT_BY_KEY[key];
              if (!def) return null;
              const value = rollStatValue(def, rarity);
              applyOptionToBonus(def, value, primaryBonus, bonus);
              return {
                key: def.key,
                label: def.label,
                unit: def.unit,
                type: def.type,
                value,
              };
            })
            .filter(Boolean);

          if (title?.primaryPerLevelStats?.length) {
            const effect =
              pickRandom(TITLE_PRIMARY_PER_LEVEL_EFFECTS) ||
              TITLE_PRIMARY_PER_LEVEL_EFFECTS[0];
            title.primaryPerLevelStats.forEach((statKey) => {
              if (!primaryPerLevel[statKey]) primaryPerLevel[statKey] = [];
              primaryPerLevel[statKey].push({
                amount: effect.amount,
                interval: effect.interval,
              });
            });
          }

          if (title?.primaryFixedStats?.length) {
            const fixedValue =
              pickRandom(TITLE_PRIMARY_FIXED_EFFECTS) ||
              TITLE_PRIMARY_FIXED_EFFECTS[0];
            title.primaryFixedStats.forEach((statKey) => {
              const current = primaryFixed[statKey];
              primaryFixed[statKey] =
                typeof current === "number"
                  ? Math.max(current, fixedValue)
                  : fixedValue;
            });
          }

          if (title?.attackCountBonus) {
            const extraAttacks =
              pickRandom(TITLE_ATTACK_COUNT_BONUS_EFFECTS) || 0;
            attackCountBonus += extraAttacks;
          }

          if (typeof title?.attackTargetsBonus === "number") {
            attackTargetsBonus += title.attackTargetsBonus;
          }

          return {
            entries,
            primaryBonus,
            bonus,
            primaryPerLevel,
            primaryFixed,
            attackCountBonus,
            attackTargetsBonus,
          };
        }

        function rollTitleRank(rarity, titleBonus) {
          const maxRank = Math.min(3, (rarity?.rank ?? 0) + 1);
          const baseWeights = TITLE_RANK_WEIGHTS.map((entry) => ({ ...entry }));
          const bonus = Math.max(0, titleBonus || 0);
          baseWeights.forEach((entry) => {
            if (entry.rank === 1)
              entry.weight = Math.max(5, entry.weight - bonus * 0.4);
            if (entry.rank === 2) entry.weight += bonus * 0.45;
            if (entry.rank === 3) entry.weight += bonus * 0.35;
          });
          const filtered = baseWeights.filter((entry) => entry.rank <= maxRank);
          return weightedRandom(filtered, { rank: 1 })?.rank ?? 1;
        }

        function rollEquipmentTitle(pool, rarity, titleBonus, baseChance) {
          const bonus = Math.max(0, titleBonus || 0);
          const chance = Math.min(95, baseChance + bonus);
          const defaultResult = {
            title: null,
            options: {
              entries: [],
              primaryBonus: createEmptyPrimaryBonus(),
              bonus: createEmptyBonus(),
              primaryPerLevel: createEmptyPrimaryPerLevelBonus(),
              primaryFixed: createEmptyPrimaryFixedBonus(),
              attackCountBonus: 0,
              attackTargetsBonus: 0,
            },
          };
          if (!pool?.length) return defaultResult;
          if (Math.random() * 100 >= chance) return defaultResult;
          const rank = rollTitleRank(rarity, bonus);
          const candidates = pool.filter((title) => title.rank <= rank);
          const fallbackRank = Math.min(3, (rarity?.rank ?? 0) + 1);
          const fallbackPool = pool.filter(
            (title) => title.rank <= fallbackRank,
          );
          const title = pickTitle(
            candidates.length
              ? candidates
              : fallbackPool.length
                ? fallbackPool
                : pool,
          );
          const options = generateTitleOptions(title, rarity);
          return { title, options };
        }

        function formatEquipmentValue(entry) {
          const sign = entry.value >= 0 ? "+" : "";
          const unit = entry.unit || "";
          return `${entry.label} ${sign}${entry.value}${unit}`;
        }

        function formatAffixEffects(effects) {
          if (!effects) return [];
          const lines = [];
          Object.entries(effects.primaryPerLevel || {}).forEach(
            ([key, list]) => {
              (list || []).forEach((effect) => {
                if (!effect) return;
                const label = EQUIPMENT_STAT_BY_KEY[key]?.label || key;
                const perText =
                  effect.interval === 1
                    ? `Lv毎に+${effect.amount}`
                    : `${effect.interval}Lv毎に+${effect.amount}`;
                const current =
                  calcPrimaryPerLevelBonus({ [key]: [effect] }, player.level)?.[
                    key
                  ] || 0;
                const currentText = current ? ` (現在+${current})` : "";
                lines.push(`${label}: ${perText}${currentText}`);
              });
            },
          );
          Object.entries(effects.primaryFixed || {}).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            const label = EQUIPMENT_STAT_BY_KEY[key]?.label || key;
            lines.push(`${label}: ${value}に固定`);
          });
          if (effects.attackCountBonus) {
            lines.push(`通常攻撃回数+${effects.attackCountBonus}回`);
          }
          if (effects.attackTargetsBonus) {
            lines.push(`攻撃対象+${effects.attackTargetsBonus}体`);
          }
          return lines;
        }

        function formatTitleStars(rank) {
          const clamped = Math.max(0, Math.round(rank || 0));
          return "★".repeat(clamped);
        }

        function formatTitleWithStars(title, kind) {
          if (!title?.name) return "";
          const stars = formatTitleStars(title.rank);
          return kind === "suffix"
            ? `${title.name}${stars}`
            : `${stars}${title.name}`;
        }

        function buildTitleLabel(label, affix, kind) {
          const name = formatTitleWithStars(affix, kind);
          return name ? `${label}: ${name}` : label;
        }

        function buildEquipmentName(
          slotKey,
          rarity,
          prefixTitle,
          suffixTitle,
          baseName,
        ) {
          const slotLabel = EQUIPMENT_SLOTS[slotKey]?.label || slotKey;
          const prefix = prefixTitle?.name
            ? `${formatTitleWithStars(prefixTitle, "prefix")} `
            : "";
          const suffix = suffixTitle?.name
            ? `・${formatTitleWithStars(suffixTitle, "suffix")}`
            : "";
          const base = baseName || slotLabel;
          return `${prefix}${base}${suffix}`;
        }

        function normalizeEquipmentItem(item) {
          if (!item || item.type !== "equipment") return item;
          if (typeof item.enhanceLevel !== "number") item.enhanceLevel = 0;
          item.enhanceBroken = !!item.enhanceBroken;
          if (!item.slot && item.equipment?.slot)
            item.slot = item.equipment.slot;
          if (
            item.equipment?.rarity === "legendary" &&
            !item.equipment.legendaryKey
          ) {
            const inferredKey = inferLegendaryKeyFromItem(item);
            if (inferredKey) item.equipment.legendaryKey = inferredKey;
          }
          return item;
        }

        function getWeaponEnhanceStep(level) {
          return (
            WEAPON_ENHANCE_PROGRESSION.find((step) => step.from === level) ||
            null
          );
        }

        function calculateWeaponEnhanceCost(level) {
          return Math.round(
            WEAPON_ENHANCE_BASE_COST *
              Math.pow(WEAPON_ENHANCE_COST_GROWTH, level),
          );
        }

        function getWeaponEnhanceMultiplier(item) {
          if (!item || item.type !== "equipment" || item.enhanceBroken)
            return 1;
          const level = Math.max(0, item?.enhanceLevel || 0);
          return 1 + level * WEAPON_ENHANCE_POWER_PER_LEVEL;
        }

        function getWeaponEnhanceColor(level) {
          const rule = WEAPON_ENHANCE_COLORS.find(
            (entry) => level >= entry.min,
          );
          return rule?.color || "";
        }

        function applyEnhanceScaling(primary, secondary, item) {
          const multiplier = getWeaponEnhanceMultiplier(item);
          if (multiplier === 1) return { primary, secondary };

          // ベースの空ボーナスに、渡された値をマージしてから倍率を掛ける
          const scaledPrimary = { ...createEmptyPrimaryBonus(), ...primary };
          const scaledSecondary = { ...createEmptyBonus(), ...secondary };

          Object.keys(scaledPrimary).forEach((key) => {
            if (typeof scaledPrimary[key] === "number") {
              scaledPrimary[key] = Number(
                (scaledPrimary[key] * multiplier).toFixed(2),
              );
            }
          });

          Object.keys(scaledSecondary).forEach((key) => {
            if (typeof scaledSecondary[key] === "number") {
              scaledSecondary[key] = Number(
                (scaledSecondary[key] * multiplier).toFixed(2),
              );
            }
          });

          return { primary: scaledPrimary, secondary: scaledSecondary };
        }

        function getEnhancedEntry(entry, item) {
          if (!entry || typeof entry.value !== "number") return entry;
          const multiplier = getWeaponEnhanceMultiplier(item);
          if (multiplier === 1) return entry;
          const precision = entry.precision ?? (entry.unit === "%" ? 1 : 0);
          const value = Number((entry.value * multiplier).toFixed(precision));
          return { ...entry, value };
        }

        function createEnhanceBadge(item, { includeZero = false } = {}) {
          if (!item || item.type !== "equipment") return null;
          const slot = item.slot || item.equipment?.slot;
          if (!slot && !item.enhanceBroken) return null;
          const level = Math.max(0, item.enhanceLevel || 0);
          if (level <= 0 && !includeZero && !item.enhanceBroken) return null;
          const badge = document.createElement("span");
          badge.className = "enhance-badge";
          const color = getWeaponEnhanceColor(level);
          if (color) badge.style.color = color;
          badge.textContent = item.enhanceBroken
            ? `+${level} (破損)`
            : `+${level}`;
          if (item.enhanceBroken) badge.classList.add("broken");
          return badge;
        }

        function formatEnhanceRate(rate) {
          if (rate >= 1) {
            return rate % 1 === 0 ? rate.toFixed(0) : rate.toFixed(1);
          }
          return rate.toFixed(2);
        }

        function describeEnhanceEffect(level) {
          const multiplier =
            1 + Math.max(0, level) * WEAPON_ENHANCE_POWER_PER_LEVEL;
          const bonusPercent = Math.round((multiplier - 1) * 1000) / 10;
          return { multiplier, bonusPercent };
        }

        function createEquipmentItem(arg1, arg2, arg3) {
          // ---------------------------
          // 引数の解釈
          // ---------------------------
          let slotKey;
          let rarityKey;
          let legendaryKey = "";
          let titleBonus = 0;
          let enhanceLevel = 0;
          let isDungeonDrop = false;
          let allowedLegendaryKeys = [];

          // 1) ドロップ用: createEquipmentItem({ floor, isBoss, rarityBonus, forceLegendaryKey })
          if (
            typeof arg1 === "object" &&
            arg1 !== null &&
            !Array.isArray(arg1)
          ) {
            const {
              floor = game.floor || 1,
              isBoss = false,
              rarityBonus = 0,
              forceLegendaryKey = "",
              slotKey: slotOverride,
              rarityKey: rarityOverride,
              legendaryKey: legendaryOverride,
              allowedLegendaryKeys: allowedLegendaryOverride,
            } = arg1;

            isDungeonDrop = true;

            // この階層・ボスかどうかに応じてドロップ部位を決定
            slotKey = slotOverride || resolveDropSlotForFloor(floor, isBoss);

            if (rarityOverride) {
              rarityKey = rarityOverride;
              legendaryKey = legendaryOverride || "";
            } else if (forceLegendaryKey) {
              // ボス用デバッグ「レジェ確定」など
              rarityKey = "legendary";
              legendaryKey = forceLegendaryKey;
            } else {
              // 通常ドロップ：ベースのレア度＋レア度ボーナスでアップ判定
              const baseKey = rollBaseDropRarity(isBoss);
              rarityKey = upgradeRarityWithBonus(baseKey, rarityBonus);
            }
            allowedLegendaryKeys = allowedLegendaryOverride || [];
          } else {
            // 2) デバッグ生成用: createEquipmentItem(slotKey, rarityKey, { legendaryKey, titleBonus, enhanceLevel })
            slotKey = arg1;
            rarityKey = arg2 || "normal";
            const opts = arg3 || {};
            legendaryKey = opts.legendaryKey || "";
            titleBonus = opts.titleBonus || 0;
            enhanceLevel = opts.enhanceLevel || 0;
          }

          // ---------------------------
          // ここから元の生成ロジック
          // ---------------------------
          const slot = EQUIPMENT_SLOTS[slotKey] ? slotKey : "weapon";
          const rarity =
            EQUIPMENT_RARITIES[rarityKey] || EQUIPMENT_RARITIES.normal;

          const template =
            rarityKey === "legendary"
              ? pickLegendaryEquipment(
                  slot,
                  legendaryKey || allowedLegendaryKeys,
                )
              : pickEquipmentTemplate(slot);

          const base = template?.base?.length
            ? rollTemplateOptions(template.base, rarity)
            : generateEquipmentOptions(rarity, rarity.baseOptions);

          const random = generateEquipmentOptions(rarity, rarity.randomOptions);

          const prefixRoll = rollEquipmentTitle(
            EQUIPMENT_TITLE_PREFIXES,
            rarity,
            titleBonus,
            TITLE_BASE_CHANCE.prefix,
          );
          const suffixRoll = rollEquipmentTitle(
            EQUIPMENT_TITLE_SUFFIXES,
            rarity,
            titleBonus,
            TITLE_BASE_CHANCE.suffix,
          );

          const prefixTitle = prefixRoll.title;
          const suffixTitle = suffixRoll.title;

          const prefixOptions = prefixRoll.options || {
            entries: [],
            primaryBonus: createEmptyPrimaryBonus(),
            bonus: createEmptyBonus(),
            primaryPerLevel: createEmptyPrimaryPerLevelBonus(),
            primaryFixed: createEmptyPrimaryFixedBonus(),
            attackCountBonus: 0,
            attackTargetsBonus: 0,
          };
          const suffixOptions = suffixRoll.options || {
            entries: [],
            primaryBonus: createEmptyPrimaryBonus(),
            bonus: createEmptyBonus(),
            primaryPerLevel: createEmptyPrimaryPerLevelBonus(),
            primaryFixed: createEmptyPrimaryFixedBonus(),
            attackCountBonus: 0,
            attackTargetsBonus: 0,
          };

          const uniqueOption =
            rarityKey === "legendary"
              ? rollLegendaryUniqueOption(template)
              : null;

          const primaryBonus = createEmptyPrimaryBonus();
          const bonus = createEmptyBonus();
          const primaryPerLevelBonus = createEmptyPrimaryPerLevelBonus();
          const primaryFixedBonus = createEmptyPrimaryFixedBonus();
          let attackCountBonus = 0;
          let attackTargetsBonus = 0;

          [
            ...base.entries,
            ...random.entries,
            ...prefixOptions.entries,
            ...suffixOptions.entries,
          ].forEach((entry) => {
            applyOptionToBonus(entry, entry.value, primaryBonus, bonus);
          });

          const mergeTitleEffects = (options) => {
            if (!options) return;
            Object.entries(options.primaryPerLevel || {}).forEach(
              ([key, effects]) => {
                if (!Array.isArray(effects)) return;
                if (!primaryPerLevelBonus[key]) primaryPerLevelBonus[key] = [];
                effects.forEach((effect) => {
                  if (!effect) return;
                  primaryPerLevelBonus[key].push({ ...effect });
                });
              },
            );
            Object.entries(options.primaryFixed || {}).forEach(
              ([key, value]) => {
                if (typeof value !== "number") return;
                const current = primaryFixedBonus[key];
                primaryFixedBonus[key] =
                  typeof current === "number"
                    ? Math.max(current, value)
                    : value;
              },
            );
            if (typeof options.attackCountBonus === "number") {
              attackCountBonus += options.attackCountBonus;
            }
            if (typeof options.attackTargetsBonus === "number") {
              attackTargetsBonus += options.attackTargetsBonus;
            }
          };

          mergeTitleEffects(prefixOptions);
          mergeTitleEffects(suffixOptions);

          const name = buildEquipmentName(
            slot,
            rarity,
            prefixTitle,
            suffixTitle,
            template?.name || uniqueOption?.itemName,
          );

          const clampedEnhanceLevel = Math.max(
            0,
            Math.min(MAX_ENHANCE_LEVEL, Math.floor(enhanceLevel || 0)),
          );

          const buildAffix = (title, options) =>
            title
              ? {
                  ...title,
                  options: options.entries,
                  effects: {
                    primaryPerLevel: clonePrimaryPerLevelBonus(
                    options.primaryPerLevel,
                  ),
                  primaryFixed: clonePrimaryFixedBonus(options.primaryFixed),
                  attackCountBonus: options.attackCountBonus || 0,
                  attackTargetsBonus: options.attackTargetsBonus || 0,
                },
              }
            : null;

          const prefixAffix = buildAffix(prefixTitle, prefixOptions);
          const suffixAffix = buildAffix(suffixTitle, suffixOptions);

          const baseItem = ensureAcquiredOrder({
            id: generateId("eq"),
            type: "equipment",
            slot,
            name,
            desc: isDungeonDrop
              ? "ダンジョンで拾った装備品"
              : "デバッグで生成した装備品",
            rarity: rarity.rank,
            enhanceLevel: clampedEnhanceLevel,
            enhanceBroken: false,
            equipment: {
              slot,
              rarity: rarity.key,
              rarityLabel: rarity.label,
              color: rarity.color,
              templateKey: template?.key || "",
              legendaryKey:
                rarityKey === "legendary"
                  ? template?.key || legendaryKey || ""
                  : "",
              baseOptions: base.entries,
              randomOptions: random.entries,
              prefix: prefixAffix,
              suffix: suffixAffix,
              uniqueOptions: uniqueOption?.option ? [uniqueOption.option] : [],
            },
            primaryBonus,
            bonus,
            primaryPerLevelBonus,
            primaryFixedBonus,
            attackCountBonus,
            attackTargetsBonus,
          });

          return baseItem;
        }

        function applyItemRarityColor(element, item) {
          if (!element) return;
          const classNames = [
            "rarity-normal",
            "rarity-magic",
            "rarity-rare",
            "rarity-legendary",
          ];
          classNames.forEach((cls) => element.classList.remove(cls));
          element.classList.toggle("broken-text", !!item?.enhanceBroken);
          const rarityKey = item?.equipment?.rarity || item?.potion?.rarity;
          if (
            rarityKey &&
            (EQUIPMENT_RARITIES[rarityKey] || POTION_RARITIES[rarityKey])
          ) {
            element.classList.add(`rarity-${rarityKey}`);
          }
        }

        function getEquipmentBonuses(item) {
          normalizeEquipmentItem(item);
          const primary = createEmptyPrimaryBonus();
          const secondary = createEmptyBonus();
          const primaryPerLevel = createEmptyPrimaryPerLevelBonus();
          const primaryFixed = createEmptyPrimaryFixedBonus();
          let attackCountBonus = 0;
          let attackTargetsBonus = 0;
          const uniqueOptions = [];
          if (!item?.equipment)
            return {
              primary,
              secondary,
              primaryPerLevel,
              primaryFixed,
              attackCountBonus,
              attackTargetsBonus,
              uniqueOptions,
            };

          if (
            item.primaryBonus ||
            item.bonus ||
            item.primaryPerLevelBonus ||
            item.primaryFixedBonus ||
            item.attackCountBonus ||
            item.attackTargetsBonus
          ) {
            Object.assign(primary, item.primaryBonus || {});
            Object.assign(secondary, item.bonus || {});
            const scaled = applyEnhanceScaling(primary, secondary, item);
            return {
              primary: scaled.primary,
              secondary: scaled.secondary,
              primaryPerLevel: clonePrimaryPerLevelBonus(
                item.primaryPerLevelBonus || {},
              ),
              primaryFixed: clonePrimaryFixedBonus(
                item.primaryFixedBonus || {},
              ),
              attackCountBonus: item.attackCountBonus || 0,
              attackTargetsBonus: item.attackTargetsBonus || 0,
              uniqueOptions: cloneState(item.equipment?.uniqueOptions || []),
            };
          }

          const collect = (options) => {
            (options || []).forEach((opt) => {
              if (!opt) return;
              applyOptionToBonus(opt, opt.value, primary, secondary);
            });
          };

          const collectEffects = (affix) => {
            const effects = affix?.effects;
            if (!effects) return;
            Object.entries(effects.primaryPerLevel || {}).forEach(
              ([key, list]) => {
                if (!Array.isArray(list)) return;
                if (!primaryPerLevel[key]) primaryPerLevel[key] = [];
                list.forEach((effect) => {
                  if (!effect) return;
                  primaryPerLevel[key].push({ ...effect });
                });
              },
            );
            Object.entries(effects.primaryFixed || {}).forEach(
              ([key, value]) => {
                if (typeof value !== "number") return;
                const current = primaryFixed[key];
                primaryFixed[key] =
                  typeof current === "number"
                    ? Math.max(current, value)
                    : value;
              },
            );
            if (typeof effects.attackCountBonus === "number") {
              attackCountBonus += effects.attackCountBonus;
            }
            if (typeof effects.attackTargetsBonus === "number") {
              attackTargetsBonus += effects.attackTargetsBonus;
            }
          };

          collect(item.equipment.baseOptions);
          collect(item.equipment.randomOptions);
          collect(item.equipment.prefix?.options);
          collect(item.equipment.suffix?.options);
          collectEffects(item.equipment.prefix);
          collectEffects(item.equipment.suffix);
          (item.equipment.uniqueOptions || []).forEach((opt) => {
            if (!opt || typeof opt.effect !== "string") return;
            uniqueOptions.push(cloneState(opt));
          });
          const scaled = applyEnhanceScaling(primary, secondary, item);
          return {
            primary: scaled.primary,
            secondary: scaled.secondary,
            primaryPerLevel,
            primaryFixed,
            attackCountBonus,
            attackTargetsBonus,
            uniqueOptions,
          };
        }

        function diffEquipmentBonuses(newItem, equippedItem) {
          const next = getEquipmentBonuses(newItem);
          const current = getEquipmentBonuses(equippedItem);
          const diffs = [];

          const pushDiff = (key, delta) => {
            if (!delta) return;
            const def = EQUIPMENT_STAT_BY_KEY[key];
            const unit = def?.unit || "";
            const precision = def?.precision ?? (unit === "%" ? 1 : 0);
            const value = Math.abs(delta);
            const formatted = precision
              ? value.toFixed(precision)
              : Math.round(value).toString();
            const label = def?.label || key;
            diffs.push({
              key,
              label,
              unit,
              delta,
              text: `${label} ${delta > 0 ? "+" : "-"}${formatted}${unit}`,
            });
          };

          const aggregateKeys = (objA, objB) =>
            Array.from(new Set([...Object.keys(objA), ...Object.keys(objB)]));
          aggregateKeys(next.primary, current.primary).forEach((key) => {
            const delta =
              (next.primary?.[key] || 0) - (current.primary?.[key] || 0);
            pushDiff(key, delta);
          });
          aggregateKeys(next.secondary, current.secondary).forEach((key) => {
            const delta =
              (next.secondary?.[key] || 0) - (current.secondary?.[key] || 0);
            pushDiff(key, delta);
          });

          return diffs;
        }

        function getInventorySlotKey(item) {
          if (!item) return null;
          if (item.slot) return item.slot;
          if (item.equipmentSlot) return item.equipmentSlot;
          if (item.equipment?.slot) return item.equipment.slot;
          return null;
        }

        function getItemRarityKey(item) {
          if (!item) return null;
          return item.equipment?.rarity || item.potion?.rarity || null;
        }

        function isItemInventory(entry) {
          if (!entry?.item) return false;
          const slotKey = getInventorySlotKey(entry.item);
          return !slotKey;
        }

        function createPotionInventoryItem(potion, { description } = {}) {
          const { useCost } = calculatePotionConsumption(potion);
          const desc =
            description ||
            `${describePotionEffect(potion)} / 消費${useCost}%`;
          return ensureAcquiredOrder({
            id: `inv-${potion.id}`,
            name: potion.name,
            desc,
            type: "potion",
            rarity:
              typeof potion.rarityRank === "number" ? potion.rarityRank : 0,
            potion: { ...potion },
          });
        }

        // グローバル再評価時でも再宣言エラーを出さないよう、グローバルオブジェクト経由で初期化
        if (typeof globalThis.SKILL_MAX_LEVEL === "undefined") {
          globalThis.SKILL_MAX_LEVEL = 50;
        }
        if (typeof globalThis.ACTIVE_SKILL_SLOT_LIMIT === "undefined") {
          globalThis.ACTIVE_SKILL_SLOT_LIMIT = 4;
        }

        const SKILL_MAX_LEVEL = globalThis.SKILL_MAX_LEVEL;
        const ACTIVE_SKILL_SLOT_LIMIT = globalThis.ACTIVE_SKILL_SLOT_LIMIT;

        const ACTIVE_UNLOCK_SCHEDULE = [1, 10, 20, 30, 40];
        const PASSIVE_UNLOCK_SCHEDULE = [
          10, 10, 20, 20, 30, 30, 40, 40, 50, 50,
        ];
        const THRESHOLD_MULTIPLIERS = { 10: 4.2, 30: 6.4, 50: 8.8 };
        const THRESHOLD_FALLBACK_MULTIPLIER = 5.2;
        const SKILL_GROWTH_BASE = 2.36;
        const SKILL_GROWTH_CURVE = 2.1;

        function getSkillGrowthMultiplier(level) {
          if (!level || level <= 0) return 0;
          const curveLevel = Math.max(0, level - 1);
          const exponential = Math.pow(SKILL_GROWTH_BASE, curveLevel / 3);
          const curveBoost =
            1 +
            Math.pow(curveLevel + 1, SKILL_GROWTH_CURVE * 1.24) * 0.08;
          return Number((exponential * curveBoost).toFixed(4));
        }

        function applyUnlockPattern(definitions) {
          const tracker = {};
          definitions.forEach((skill) => {
            const state = tracker[skill.category] || { active: 0, passive: 0 };
            tracker[skill.category] = state;
            if (skill.type === "active") {
              const level =
                ACTIVE_UNLOCK_SCHEDULE[
                  Math.min(state.active, ACTIVE_UNLOCK_SCHEDULE.length - 1)
                ];
              skill.unlockLevel = level;
              state.active += 1;
            } else {
              const level =
                PASSIVE_UNLOCK_SCHEDULE[
                  Math.min(state.passive, PASSIVE_UNLOCK_SCHEDULE.length - 1)
                ];
              skill.unlockLevel = level;
              state.passive += 1;
            }
          });
        }

        function amplifyThresholdBonuses(thresholds = []) {
          return thresholds.map((threshold) => {
            const baseMultiplier =
              THRESHOLD_MULTIPLIERS[threshold.level] ||
              THRESHOLD_FALLBACK_MULTIPLIER;
            const dynamicBoost = 1 + Math.pow(threshold.level / 10, 1.12) * 0.12;
            const multiplier = Number(
              (baseMultiplier * dynamicBoost).toFixed(2),
            );
            const bonus = {};
            Object.entries(threshold.bonus || {}).forEach(([key, value]) => {
              if (typeof value !== "number") return;
              bonus[key] = Number((value * multiplier).toFixed(2));
            });
            return { ...threshold, bonus, effect: undefined };
          });
        }

        const player = {
          name: "プレイヤー",
          level: 1,
          exp: 0,
          expToLevel: 15,
          hp: 0,
          mp: 0,
          maxHp: 0,
          maxMp: 0,
          atk: 0,
          def: 0,
          spd: 0,
          accuracy: 0,
          evade: 0,
          damageReduction: 0,
          block: 0,
          hpRegen: 0,
          lifeSteal: 0,
          barrierMax: 0,
          barrierRemaining: 0,
          attackCount: 1,
          attackTargets: 1,
          attackTargetsBonus: 0,
          attacksRemaining: 1,
          base: {
            hp: 180,
            mp: 120,
            physAtk: 36,
            magAtk: 36,
            physDef: 14,
            magDef: 18,
            speed: 12,
          },
          primary: {
            str: { label: "力", base: 3, bonus: 0 },
            int: { label: "知識", base: 3, bonus: 0 },
            vit: { label: "体力", base: 3, bonus: 0 },
            agi: { label: "敏捷", base: 3, bonus: 0 },
            luck: { label: "運", base: 3, bonus: 0 },
          },
          allocations: {
            str: 0,
            int: 0,
            vit: 0,
            agi: 0,
            luck: 0,
          },
          bonus: createEmptyBonus(),
          baseBonus: createEmptyBonus(),
          equipmentBonus: createEmptyBonus(),
          equipmentPrimaryBonus: createEmptyPrimaryBonus(),
          legendaryState: {},
          equipment: {
            head: null,
            body: null,
            hands: null,
            feet: null,
            weapon: null,
            subWeapon: null,
            accessory1: null,
            accessory2: null,
          },
          gold: 0,
          statPoints: 0,
          skillPoints: 0,
          passivePoints: 0,
          passiveNodes: {},
          unlockedSkillKeys: [],
          buffs: { guard: 0, haste: 0, focus: 0 },
          resist: { control: 0, dot: 0, debuff: 0 },
          statuses: [],
          inventory: {
            items: [],
          },
          potions: [
            createPotionFromTemplate("hp", "small", {
              rarityKey: "normal",
              useBaseValues: true,
              skipAffix: true,
              hideRarityInName: true,
            }),
            createPotionFromTemplate("mp", "small", {
              rarityKey: "normal",
              useBaseValues: true,
              skipAffix: true,
              hideRarityInName: true,
            }),
          ],
          activeSkillSlots: Array.from(
            { length: ACTIVE_SKILL_SLOT_LIMIT },
            () => ({ skillKey: null, cooldownRemaining: 0 }),
          ),
        };

        const game = {
          floor: 1,
          highestFloor: 1,
          reachedBossFloors: {},
          enemies: [],
          turnQueue: [],
          awaitingInput: false,
          autoSkillEnabled: false,
          bossRetryEnabled: false,
          playerDefeatInProgress: false,
          defeatedBosses: 0,
          bossKillRecords: {},
          legendaryRecords: {},
          codex: {
            enemyMonsters: {},
            enemyVariants: {},
            bosses: {},
            equipment: {},
            potions: {},
            titles: {},
          },
        };

        let lastDerivedStats = null;
        let turnOrderPreview = [];
        let lastTurnOrderSignature = "";
        let currentActorEntry = null;
        let lastActedEntry = null;
        let activeTurnActor = null;
        let playerDownOverlayReadyTimer = null;
        let playerDefeatResolveTimer = null;

        const SKILL_CATEGORIES = ["剣士", "魔法", "聖職", "吸血"];

        const CATEGORY_KEY_MAP = {
          剱士: "sword",
          魔法: "mage",
          聖職: "cleric",
          吸血: "vampire",
        };

        const PASSIVE_TREE_BLUEPRINTS = {
          剱士: {
            upper: {
              label: "手数重視",
              routes: [
                { key: "swift", label: "疾風連撃", desc: "手数でリズムを刻み、連擊を入れる。" },
                { key: "cascade", label: "連携刃舞", desc: "連携で隙を突き、手数を重ねる。" },
                { key: "tempest", label: "刃風乱舞", desc: "素早い料が広範囲を削る。" },
              ],
            },
            lower: {
              label: "一撃重視",
              routes: [
                { key: "draw", label: "居合極断", desc: "一刀で決めるための拡挙。" },
                { key: "crusher", label: "粉破突き", desc: "装甲も穿つ重さを使う。" },
                { key: "dominion", label: "覇断", desc: "減多に様式化した一撃。" },
              ],
            },
          },
          魔法: {
            upper: {
              label: "範囲魔法",
              routes: [
                { key: "frostfield", label: "氷爆領域", desc: "広範囲を凍てつかせ、敵を少しずつ細らせる。" },
                { key: "inferno", label: "炎陵崩し", desc: "魔法陣を展開して範囲の敵を消す。" },
                { key: "storm", label: "雷霜乱射", desc: "電撃を幾重に拡散させる。" },
              ],
            },
            lower: {
              label: "自己補助／連鎖",
              routes: [
                {
                  key: "manaCycle",
                  label: "魔力循環",
                  desc: "自己を強化しながら魔力を循環させる。",
                  passiveKeyOverrides: ["arcaneFlow", null],
                },
                { key: "arcLink", label: "連鎖術式", desc: "術式を連ね、連鎖ように組み立てる。" },
                { key: "selfBoost", label: "自己強化", desc: "精神と体構を整え、長期戦に備える。" },
              ],
            },
          },
          聖職: {
            upper: {
              label: "防御／敥侵デバフ",
              routes: [
                { key: "bastion", label: "護壁祈祷", desc: "守りを固め、前線を守護する。" },
                { key: "edict", label: "断罪印", desc: "敵を弱体化し、行動を制約する。" },
                { key: "sanctum", label: "禁域封鎖", desc: "聖域で敵の動きを弱める。" },
              ],
            },
            lower: {
              label: "回復／光属性",
              routes: [
                { key: "healing", label: "癒しの輪", desc: "継続的な回復で味方を支える。" },
                { key: "lance", label: "光槍", desc: "聖光を凝縮して直線的に貴く。" },
                { key: "prayer", label: "祈願強化", desc: "光と祈りを展開し、戦線を安定させる。" },
              ],
            },
          },
          吸血: {
            upper: {
              label: "HP吸収",
              routes: [
                { key: "siphon", label: "吸血儀礼", desc: "血を吸い上げて感覚を研ぎ澄ます。" },
                { key: "feast", label: "血宴", desc: "絶え間ない吸収で高揚感を維持する。" },
                { key: "hunt", label: "狩猟衝動", desc: "敵を狙う狩猶本能を引き出す。" },
              ],
            },
            lower: {
              label: "HPコスト",
              routes: [
                { key: "bloodPact", label: "血契", desc: "自身の代償で力を引き出す。" },
                { key: "sacrifice", label: "代償強化", desc: "血を狭に力を割り振る。" },
                { key: "resolve", label: "紅の覚悟", desc: "倒れない意志で引きかわりにする。" },
              ],
            },
          },
        };

        const CLASS_SKILL_PRESETS = {
          剱士: {
            activeScaling: { physAtk: 1.15, speed: 0.35, critRate: 0.12 },
            passiveScaling: { physAtk: 0.6, speed: 0.35 },
            thresholds: {
              active: [
                { level: 10, bonus: { critRate: 2 } },
                { level: 30, bonus: { speed: 2 } },
                { level: 50, bonus: { physPen: 5 } },
              ],
              passive: [
                { level: 10, bonus: { speed: 1.5 } },
                { level: 30, bonus: { critDamage: 6 } },
                { level: 50, bonus: { cooldown: 2 } },
              ],
            },
            activation: { cooldown: 4, mpCost: 6 },
          },
          魔法: {
            activeScaling: { magAtk: 1.25, magPen: 0.35 },
            passiveScaling: { magAtk: 0.7, mp: 0.9 },
            thresholds: {
              active: [
                { level: 10, bonus: { magPen: 4 } },
                { level: 30, bonus: { critRate: 3 } },
                { level: 50, bonus: { cooldown: 2 } },
              ],
              passive: [
                { level: 10, bonus: { mp: 18 } },
                { level: 30, bonus: { magAtk: 12 } },
                { level: 50, bonus: { cooldown: 2 } },
              ],
            },
            activation: { cooldown: 5, mpCost: 8 },
          },
          聖職: {
            activeScaling: { magAtk: 0.95, barrier: 0.5, magDef: 0.4 },
            passiveScaling: { hp: 1.1, magDef: 0.6 },
            thresholds: {
              active: [
                { level: 10, bonus: { damageReduction: 3 } },
                { level: 30, bonus: { debuffResist: 4 } },
                { level: 50, bonus: { barrier: 18 } },
              ],
              passive: [
                { level: 10, bonus: { hpRegen: 0.35 } },
                { level: 30, bonus: { magDef: 10 } },
                { level: 50, bonus: { block: 4 } },
              ],
            },
            activation: { cooldown: 6, mpCost: 7 },
          },
          吸血: {
            activeScaling: { physAtk: 1.05, lifeSteal: 0.1, critRate: 0.1 },
            passiveScaling: { hp: 0.7, lifeSteal: 0.08 },
            thresholds: {
              active: [
                { level: 10, bonus: { lifeSteal: 3 } },
                { level: 30, bonus: { critRate: 3 } },
                { level: 50, bonus: { physPen: 4 } },
              ],
              passive: [
                { level: 10, bonus: { hp: 24 } },
                { level: 30, bonus: { lifeSteal: 2 } },
                { level: 50, bonus: { critDamage: 6 } },
              ],
            },
            activation: { cooldown: 5, mpCost: 4 },
          },
        };

        function buildSkillDefinitions() {
          const definitions = [];
          Object.entries(PASSIVE_TREE_BLUEPRINTS).forEach(
            ([category, sections]) => {
              const preset = CLASS_SKILL_PRESETS[category];
              if (!preset) return;
              Object.entries(sections).forEach(([sectionKey, section]) => {
                section.routes.forEach((route) => {
                  const baseKey =
                    CATEGORY_KEY_MAP[category] + "-" + route.key + "-";
                  const activeKey = route.activeKey || `${baseKey}active`;
                  const passiveKeys =
                    route.passiveKeyOverrides && route.passiveKeyOverrides[0]
                      ? [
                          route.passiveKeyOverrides[0],
                          route.passiveKeyOverrides[1] || `${baseKey}passive-2`,
                        ]
                      : [`${baseKey}passive-1`, `${baseKey}passive-2`];

                  definitions.push({
                    key: activeKey,
                    name: `${route.label}・奥義`,
                    desc: route.desc,
                    category,
                    type: "active",
                    scaling: { perLevel: { ...preset.activeScaling } },
                    thresholds: preset.thresholds.active.map((entry) => ({
                      ...entry,
                    })),
                    activation: {
                      ...preset.activation,
                      effect: `${route.label}: ${route.desc}`,
                      slotCost: 1,
                    },
                    group: `${category}-${sectionKey}`,
                  });

                  passiveKeys.forEach((key, index) => {
                    const label = index === 0 ? "鍊錬" : "精體";
                    definitions.push({
                      key,
                      name: `${route.label}の${label}`,
                      desc: `${route.label}系統を強化する。`,
                      category,
                      type: "passive",
                      scaling: { perLevel: { ...preset.passiveScaling } },
                      thresholds: preset.thresholds.passive.map((entry) => ({
                        ...entry,
                      })),
                      group: `${category}-${sectionKey}`,
                    });
                  });
                });
              });
            },
          );
          return definitions;
        }

        const SKILL_DEFINITIONS = buildSkillDefinitions();



        SKILL_DEFINITIONS.forEach((skill) => {
          skill.thresholds = amplifyThresholdBonuses(skill.thresholds);
        });

        const SKILL_DEFINITION_MAP = SKILL_DEFINITIONS.reduce((acc, skill) => {
          acc[skill.key] = skill;
          return acc;
        }, {});

        const skills = SKILL_DEFINITIONS.reduce((acc, skill) => {
          acc[skill.key] = { ...skill, level: 0, max: SKILL_MAX_LEVEL };
          return acc;
        }, {});

        const PASSIVE_TREE_LAYOUT = {
          coreCount: 8,
          innerRadius: 120,
          outerRadius: 260,
          routeLength: 1250,
          rootConfigs: [
            { coreIdx: 6, angle: Math.PI * 1.5 },
            { coreIdx: 5, angle: Math.PI * 1.3 },
            { coreIdx: 7, angle: Math.PI * 1.7 },
            { coreIdx: 2, angle: Math.PI * 0.5 },
            { coreIdx: 1, angle: Math.PI * 0.3 },
            { coreIdx: 3, angle: Math.PI * 0.7 },
          ],
        };

        const PASSIVE_TREE_STAT_PRESETS = {
          剣士: {
            upper: [
              {
                name: "迅脚鍛錬",
                primary: { agi: 1 },
                bonus: { speed: 1.6 },
              },
              { name: "連撃精度", bonus: { critRate: 2 } },
              {
                name: "鋭刃鍛錬",
                primary: { str: 1 },
                bonus: { physAtk: 10 },
              },
              { name: "素早い踏み込み", bonus: { cooldown: 2 } },
              { name: "連続斬り", bonus: { physPen: 3 } },
              { name: "残心", bonus: { evade: 3 } },
            ],
            lower: [
              {
                name: "剛腕鍛錬",
                primary: { str: 2 },
                bonus: { physAtk: 12 },
              },
              { name: "刃の重み", bonus: { critDamage: 7 } },
              { name: "貫き意識", bonus: { physPen: 4 } },
              { name: "揺るがぬ構え", bonus: { damageReduction: 2 } },
              { name: "集中の息", bonus: { critRate: 2 } },
              { name: "覇気", bonus: { speed: 1 } },
            ],
          },
          魔法: {
            upper: [
              {
                name: "集中詠唱",
                primary: { int: 1 },
                bonus: { magAtk: 10 },
              },
              { name: "魔力拡散", bonus: { magPen: 4 } },
              { name: "増幅魔力", bonus: { mp: 16 } },
              { name: "範囲制御", bonus: { cooldown: 2 } },
              { name: "術式加速", bonus: { speed: 1.5 } },
              { name: "元素精度", bonus: { critRate: 2 } },
            ],
            lower: [
              { name: "魔力循環", bonus: { mp: 18 } },
              {
                name: "自己強化理論",
                primary: { int: 1 },
                bonus: { magAtk: 8 },
              },
              { name: "再詠唱", bonus: { cooldown: 2 } },
              { name: "詠唱加速", bonus: { speed: 1.5 } },
              { name: "護符調整", bonus: { magDef: 6 } },
              { name: "魔力再生", bonus: { hpRegen: 0.2 } },
            ],
          },
          聖職: {
            upper: [
              {
                name: "守護意志",
                primary: { vit: 1 },
                bonus: { physDef: 8 },
              },
              { name: "守勢結界", bonus: { magDef: 8 } },
              { name: "神盾", bonus: { damageReduction: 2 } },
              { name: "聖域維持", bonus: { debuffResist: 3 } },
              { name: "堅牢", bonus: { block: 3 } },
              { name: "制裁準備", bonus: { critRate: 1.5 } },
            ],
            lower: [
              {
                name: "癒しの心得",
                primary: { int: 1 },
                bonus: { hp: 24 },
              },
              { name: "祝福持続", bonus: { hpRegen: 0.35 } },
              { name: "光刃集中", bonus: { magAtk: 9 } },
              { name: "守護光", bonus: { barrier: 14 } },
              { name: "奉仕の息", bonus: { cooldown: 2 } },
              { name: "神威集中", bonus: { magPen: 3 } },
            ],
          },
          吸血: {
            upper: [
              {
                name: "血の敏捷",
                primary: { agi: 1 },
                bonus: { speed: 1.5 },
              },
              { name: "吸血衝動", bonus: { lifeSteal: 2 } },
              { name: "狩人の腕", bonus: { physAtk: 9 } },
              { name: "血脈強化", bonus: { hp: 22 } },
              { name: "鮮血の感覚", bonus: { critRate: 2 } },
              { name: "追撃", bonus: { physPen: 3 } },
            ],
            lower: [
              {
                name: "紅の覚悟",
                primary: { str: 1 },
                bonus: { physAtk: 11 },
              },
              { name: "血の代償", bonus: { critDamage: 6 } },
              { name: "侵食", bonus: { physPen: 4 } },
              { name: "耐久血脈", bonus: { damageReduction: 2 } },
              { name: "血潮再生", bonus: { hpRegen: 0.25 } },
              { name: "闘争本能", bonus: { critRate: 2 } },
            ],
          },
        };

        const PASSIVE_TREE_KEYSTONE_PRESETS = {
          剣士: {
            upper: [
              {
                name: "疾風連携",
                desc: "攻撃回数+1 / 速度+6 / 物攻-8",
                bonus: { speed: 6, physAtk: -8 },
                special: { attackCountBonus: 1 },
              },
              {
                name: "連舞の負荷",
                desc: "クリ率+5 / CT短縮+6% / 最大HP-30",
                bonus: { critRate: 5, cooldown: 6, hp: -30 },
              },
              {
                name: "迅刃循環",
                desc: "攻撃対象+1 / 速度+4 / 被ダメ軽減-6%",
                bonus: { speed: 4, damageReduction: -6 },
                special: { attackTargetsBonus: 1 },
              },
            ],
            lower: [
              {
                name: "断罪一閃",
                desc: "物攻+20 / クリダメ+10% / 速度-4",
                bonus: { physAtk: 20, critDamage: 10, speed: -4 },
              },
              {
                name: "粉砕の代価",
                desc: "物理貫通+8% / ブロック-5%",
                bonus: { physPen: 8, block: -5 },
              },
              {
                name: "剛断",
                desc: "クリ率+4% / 物攻+15 / 回避-6%",
                bonus: { critRate: 4, physAtk: 15, evade: -6 },
              },
            ],
          },
          魔法: {
            upper: [
              {
                name: "広域魔陣",
                desc: "攻撃対象+1 / 魔攻+12 / CT短縮-6%",
                bonus: { magAtk: 12, cooldown: -6 },
                special: { attackTargetsBonus: 1 },
              },
              {
                name: "元素過負荷",
                desc: "魔法貫通+8% / クリダメ+6% / 最大MP-20",
                bonus: { magPen: 8, critDamage: 6, mp: -20 },
              },
              {
                name: "残響爆発",
                desc: "クリ率+5% / 魔攻+10 / 最大HP-25",
                bonus: { critRate: 5, magAtk: 10, hp: -25 },
              },
            ],
            lower: [
              {
                name: "詠唱連鎖",
                desc: "CT短縮+8% / 速度+4 / 魔防-6",
                bonus: { cooldown: 8, speed: 4, magDef: -6 },
              },
              {
                name: "魔力循環",
                desc: "最大MP+25 / HP再生+0.4 / 物防-6",
                bonus: { mp: 25, hpRegen: 0.4, physDef: -6 },
              },
              {
                name: "再構成",
                desc: "バリア+22 / 魔攻+8 / 被ダメ軽減-6%",
                bonus: { barrier: 22, magAtk: 8, damageReduction: -6 },
              },
            ],
          },
          聖職: {
            upper: [
              {
                name: "鉄壁祈祷",
                desc: "被ダメ軽減+8% / 物防+8 / 速度-3",
                bonus: { damageReduction: 8, physDef: 8, speed: -3 },
              },
              {
                name: "断罪法印",
                desc: "弱体耐性+8% / 魔攻+6 / HP再生-0.3",
                bonus: { debuffResist: 8, magAtk: 6, hpRegen: -0.3 },
              },
              {
                name: "封印領域",
                desc: "行動阻害耐性+8% / ブロック+6% / クリ率-4%",
                bonus: { controlResist: 8, block: 6, critRate: -4 },
              },
            ],
            lower: [
              {
                name: "慈光の輪",
                desc: "HP再生+0.6 / 最大HP+30 / 魔法貫通-4%",
                bonus: { hpRegen: 0.6, hp: 30, magPen: -4 },
              },
              {
                name: "聖光矢",
                desc: "魔攻+12 / クリ率+4% / 被ダメ軽減-4%",
                bonus: { magAtk: 12, critRate: 4, damageReduction: -4 },
              },
              {
                name: "祝福循環",
                desc: "バリア+24 / CT短縮+6% / 最大MP-18",
                bonus: { barrier: 24, cooldown: 6, mp: -18 },
              },
            ],
          },
          吸血: {
            upper: [
              {
                name: "血の宴",
                desc: "吸収+4% / 物攻+10 / 被ダメ軽減-5%",
                bonus: { lifeSteal: 4, physAtk: 10, damageReduction: -5 },
              },
              {
                name: "捕食衝動",
                desc: "クリ率+5% / 吸収+3% / HP再生-0.3",
                bonus: { critRate: 5, lifeSteal: 3, hpRegen: -0.3 },
              },
              {
                name: "吸血回廊",
                desc: "最大HP+30 / 吸収+4% / 速度-3",
                bonus: { hp: 30, lifeSteal: 4, speed: -3 },
              },
            ],
            lower: [
              {
                name: "血契の代価",
                desc: "物攻+14 / CT短縮+6% / 最大HP-35",
                bonus: { physAtk: 14, cooldown: 6, hp: -35 },
              },
              {
                name: "代償強化",
                desc: "クリダメ+10% / 物理貫通+5% / HP再生-0.4",
                bonus: { critDamage: 10, physPen: 5, hpRegen: -0.4 },
              },
              {
                name: "紅の覚悟",
                desc: "被ダメ軽減+6% / 吸収+2% / ブロック-6%",
                bonus: { damageReduction: 6, lifeSteal: 2, block: -6 },
              },
            ],
          },
        };

        function getRouteSkillKeys(category, route) {
          const baseKey = CATEGORY_KEY_MAP[category] + "-" + route.key + "-";
          const activeKey = route.activeKey || `${baseKey}active`;
          const passiveKeys =
            route.passiveKeyOverrides && route.passiveKeyOverrides[0]
              ? [
                  route.passiveKeyOverrides[0],
                  route.passiveKeyOverrides[1] || `${baseKey}passive-2`,
                ]
              : [`${baseKey}passive-1`, `${baseKey}passive-2`];
          return { activeKey, passiveKeys };
        }

        function buildPassiveTreeDefinitions() {
          const definitions = {};
          Object.entries(PASSIVE_TREE_BLUEPRINTS).forEach(
            ([category, sections]) => {
              const nodes = [];
              const links = [];
              const skillNodes = {};
              const adjacency = {};
              const activeSkills = [];

              nodes.push({
                id: "origin",
                x: 0,
                y: 0,
                kind: "start",
                name: "起点",
                active: true,
              });

              const { coreCount, innerRadius, outerRadius, routeLength } =
                PASSIVE_TREE_LAYOUT;
              for (let i = 0; i < coreCount; i++) {
                const angle = (Math.PI * 2 * i) / coreCount;
                nodes.push({
                  id: `inner-${i}`,
                  x: Math.cos(angle) * innerRadius,
                  y: Math.sin(angle) * innerRadius,
                  kind: "core",
                  name: "コア",
                });
                links.push({ s: "origin", t: `inner-${i}` });
                if (i > 0) links.push({ s: `inner-${i - 1}`, t: `inner-${i}` });
              }
              links.push({ s: `inner-${coreCount - 1}`, t: "inner-0" });

              for (let i = 0; i < coreCount; i++) {
                const angle = (Math.PI * 2 * i) / coreCount;
                nodes.push({
                  id: `outer-${i}`,
                  x: Math.cos(angle) * outerRadius,
                  y: Math.sin(angle) * outerRadius,
                  kind: "core",
                  name: "外縁",
                });
                links.push({ s: `inner-${i}`, t: `outer-${i}` });
                if (i > 0) links.push({ s: `outer-${i - 1}`, t: `outer-${i}` });
              }
              links.push({ s: `outer-${coreCount - 1}`, t: "outer-0" });

              const routeList = [
                ...sections.upper.routes.map((route) => ({
                  ...route,
                  section: "upper",
                })),
                ...sections.lower.routes.map((route) => ({
                  ...route,
                  section: "lower",
                })),
              ];

              PASSIVE_TREE_LAYOUT.rootConfigs.forEach((config, routeIndex) => {
                const route = routeList[routeIndex];
                if (!route) return;
                const sectionKey = route.section;
                const statNodes =
                  PASSIVE_TREE_STAT_PRESETS[category]?.[sectionKey] || [];
                const keystones =
                  PASSIVE_TREE_KEYSTONE_PRESETS[category]?.[sectionKey] || [];
                const { activeKey, passiveKeys } = getRouteSkillKeys(
                  category,
                  route,
                );

                const baseNodePlan = [
                  statNodes[0],
                  {
                    kind: "skill",
                    unlocks:
                      routeIndex % 3 === 1 ? passiveKeys : [passiveKeys[0]],
                    unlockType:
                      routeIndex % 3 === 1 ? "category" : "individual",
                    name:
                      routeIndex % 3 === 1
                        ? `${sections[sectionKey].label}系統解放`
                        : SKILL_DEFINITION_MAP[passiveKeys[0]]?.name ||
                          "パッシブ解放",
                    desc:
                      routeIndex % 3 === 1
                        ? `${sections[sectionKey].label}のパッシブをまとめて解放する。`
                        : SKILL_DEFINITION_MAP[passiveKeys[0]]?.desc || "",
                  },
                  statNodes[1],
                  statNodes[2],
                  {
                    kind: "skill",
                    unlocks: [activeKey],
                    unlockType: "individual",
                    name:
                      SKILL_DEFINITION_MAP[activeKey]?.name || "アクティブ解放",
                    desc: SKILL_DEFINITION_MAP[activeKey]?.desc || "",
                  },
                  statNodes[3],
                  statNodes[4],
                  {
                    kind: "skill",
                    unlocks: [passiveKeys[1]],
                    unlockType: "individual",
                    name:
                      SKILL_DEFINITION_MAP[passiveKeys[1]]?.name ||
                      "パッシブ解放",
                    desc: SKILL_DEFINITION_MAP[passiveKeys[1]]?.desc || "",
                  },
                  statNodes[5],
                ];

                const startId = `outer-${config.coreIdx}`;
                const aid = `${category}-${route.key}-exit`;
                const tx = Math.cos(config.angle) * routeLength;
                const ty = Math.sin(config.angle) * routeLength;
                const activeNode = {
                  id: aid,
                  x: tx,
                  y: ty,
                  kind: "exit",
                  name: `${route.label}出口`,
                  angle: config.angle,
                };
                nodes.push(activeNode);
                activeSkills.push(activeNode);
                links.push({ s: startId, t: aid });

                for (let c = 1; c <= 3; c++) {
                  const dist = 350 + c * 240;
                  const jx = Math.cos(config.angle) * dist;
                  const jy = Math.sin(config.angle) * dist;

                  const branchAngle =
                    config.angle +
                    (config.coreIdx === 6 || config.coreIdx === 2
                      ? Math.PI / 3
                      : config.coreIdx === 5 || config.coreIdx === 3
                        ? -Math.PI / 3
                        : Math.PI / 3);

                  for (let n = 1; n <= 4; n++) {
                    const nodeIndex = (c - 1) * 3 + (n - 1);
                    const bid = `${category}-${route.key}-C${c}-N${n}`;
                    const bx = jx + Math.cos(branchAngle) * (n * 75);
                    const by = jy + Math.sin(branchAngle) * (n * 75);

                    let nodeDef = null;
                    let kind = "stat";
                    let name = "ステータス";
                    let desc = "";
                    let bonus = {};
                    let primary = {};
                    let unlocks = [];
                    let unlockType = "";
                    let special = {};

                    if (n === 4) {
                      const key = keystones[c - 1] || {};
                      kind = "keystone";
                      name = key.name || "キーストーン";
                      desc = key.desc || "";
                      bonus = key.bonus || {};
                      special = key.special || {};
                    } else {
                      nodeDef = baseNodePlan[nodeIndex] || {};
                      kind = nodeDef.kind || "stat";
                      name = nodeDef.name || "ステータス";
                      desc = nodeDef.desc || "";
                      bonus = nodeDef.bonus || {};
                      primary = nodeDef.primary || {};
                      unlocks = nodeDef.unlocks || [];
                      unlockType = nodeDef.unlockType || "";
                    }

                    const node = {
                      id: bid,
                      x: bx,
                      y: by,
                      kind,
                      name,
                      desc,
                      bonus,
                      primary,
                      unlocks,
                      unlockType,
                      special,
                    };
                    nodes.push(node);
                    if (kind === "skill") {
                      skillNodes[bid] = node;
                    }
                    if (n === 1) {
                      links.push({ s: startId, t: bid, vSrc: { x: jx, y: jy } });
                    } else {
                      links.push({ s: `${category}-${route.key}-C${c}-N${n - 1}`, t: bid });
                    }
                  }
                }
              });

              activeSkills.sort((a, b) => a.angle - b.angle);
              for (let i = 0; i < activeSkills.length; i++) {
                const sNode = activeSkills[i];
                const tNode = activeSkills[(i + 1) % activeSkills.length];
                links.push({ s: sNode.id, t: tNode.id });

                const curveRadius = PASSIVE_TREE_LAYOUT.routeLength + 200;
                let sAng = sNode.angle;
                let tAng = tNode.angle;
                let diff = tAng - sAng;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;

                const p1Id = `outer-bridge-${category}-${i}-p1`;
                const p2Id = `outer-bridge-${category}-${i}-p2`;
                const ang1 = sAng + diff * 0.33;
                const ang2 = sAng + diff * 0.66;

                nodes.push({
                  id: p1Id,
                  x: Math.cos(ang1) * curveRadius,
                  y: Math.sin(ang1) * curveRadius,
                  kind: "stat",
                  name: "連絡",
                });
                nodes.push({
                  id: p2Id,
                  x: Math.cos(ang2) * curveRadius,
                  y: Math.sin(ang2) * curveRadius,
                  kind: "stat",
                  name: "連絡",
                });

                links.push({ s: sNode.id, t: p1Id });
                links.push({ s: p1Id, t: p2Id });
                links.push({ s: p2Id, t: tNode.id });
              }

              links.forEach((link) => {
                adjacency[link.s] = adjacency[link.s] || new Set();
                adjacency[link.t] = adjacency[link.t] || new Set();
                adjacency[link.s].add(link.t);
                adjacency[link.t].add(link.s);
              });

              definitions[category] = { nodes, links, skillNodes, adjacency };
            },
          );
          return definitions;
        }

        const PASSIVE_TREE_DEFINITIONS = buildPassiveTreeDefinitions();

        function getPassiveTreeState(category) {
          const definition = PASSIVE_TREE_DEFINITIONS[category];
          if (!definition) return { nodes: [], links: [], adjacency: {} };
          const acquired = new Set(player.passiveNodes?.[category] || []);
          const nodes = definition.nodes.map((node) => ({
            ...node,
            active:
              node.kind === "start" ||
              node.kind === "core" ||
              acquired.has(node.id),
          }));
          return {
            nodes,
            links: definition.links,
            adjacency: definition.adjacency,
            skillNodes: definition.skillNodes,
          };
        }

        function calculatePassiveTreeEffects() {
          const primary = createEmptyPrimaryBonus();
          const secondary = createEmptyBonus();
          let attackCountBonus = 0;
          let attackTargetsBonus = 0;
          const unlockedSkills = new Set();

          Object.entries(player.passiveNodes || {}).forEach(
            ([category, nodeIds]) => {
              const definition = PASSIVE_TREE_DEFINITIONS[category];
              if (!definition || !Array.isArray(nodeIds)) return;
              nodeIds.forEach((nodeId) => {
                const node = definition.nodes.find((entry) => entry.id === nodeId);
                if (!node) return;
                Object.entries(node.primary || {}).forEach(([key, value]) => {
                  primary[key] = (primary[key] ?? 0) + value;
                });
                Object.entries(node.bonus || {}).forEach(([key, value]) => {
                  secondary[key] = (secondary[key] ?? 0) + value;
                });
                if (node.special?.attackCountBonus) {
                  attackCountBonus += node.special.attackCountBonus;
                }
                if (node.special?.attackTargetsBonus) {
                  attackTargetsBonus += node.special.attackTargetsBonus;
                }
                (node.unlocks || []).forEach((skillKey) =>
                  unlockedSkills.add(skillKey),
                );
              });
            },
          );

          return {
            primary,
            secondary,
            attackCountBonus,
            attackTargetsBonus,
            unlockedSkills,
          };
        }

        function ensurePassiveTreeState() {
          if (!player.passiveNodes || typeof player.passiveNodes !== "object") {
            player.passiveNodes = {};
          }
          SKILL_CATEGORIES.forEach((category) => {
            if (!Array.isArray(player.passiveNodes[category])) {
              player.passiveNodes[category] = [];
            }
          });
        }

        function getPassiveTreeNode(category, nodeId) {
          const definition = PASSIVE_TREE_DEFINITIONS[category];
          if (!definition) return null;
          return definition.nodes.find((node) => node.id === nodeId) || null;
        }

        function canUnlockPassiveNode(category, nodeId) {
          const { nodes, adjacency } = getPassiveTreeState(category);
          const target = nodes.find((node) => node.id === nodeId);
          if (!target || target.active) return false;
          if (["core", "exit", "start"].includes(target.kind)) return false;
          if (player.passivePoints <= 0) return false;
          const neighbors = adjacency?.[nodeId];
          if (!neighbors) return false;
          return Array.from(neighbors).some((neighborId) =>
            nodes.find((node) => node.id === neighborId && node.active),
          );
        }

        function unlockPassiveNode(category, nodeId) {
          if (!canUnlockPassiveNode(category, nodeId)) return false;
          player.passivePoints -= 1;
          ensurePassiveTreeState();
          player.passiveNodes[category].push(nodeId);
          player.unlockedSkillKeys = [];
          syncLockedSkills({ silent: true });
          recalcDerivedStats();
          updateUI();
          return true;
        }

        function resetPassiveTree(category) {
          ensurePassiveTreeState();
          const spent = player.passiveNodes[category]?.length || 0;
          if (spent <= 0) return false;
          player.passiveNodes[category] = [];
          player.passivePoints += spent;
          player.unlockedSkillKeys = [];
          syncLockedSkills({ silent: true, refundUnlocked: true });
          recalcDerivedStats();
          updateUI();
          return true;
        }

        function syncLockedSkills({ silent = false, refundUnlocked = false } = {}) {
          let refunded = 0;
          Object.values(skills).forEach((skill) => {
            if (isSkillUnlocked(skill)) return;
            if (skill.level > 0) {
              refunded += skill.level;
              skill.level = 0;
            }
          });
          if (refunded > 0) {
            player.skillPoints += refunded;
            if (!silent) {
              log(`🔁 未解放スキルを整理しスキルP+${refunded}`, "info");
            }
          }
          player.activeSkillSlots.forEach((slot) => {
            if (!slot.skillKey) return;
            const skill = skills[slot.skillKey];
            if (!isSkillUnlocked(skill)) slot.skillKey = null;
          });
          if (refundUnlocked) {
            renderActiveSkillLoadout();
          }
        }

        function formatPassiveNodeEffect(node) {
          const parts = [];
          const primaryLabels = {
            str: "力",
            int: "知識",
            vit: "体力",
            agi: "敏捷",
            luck: "運",
          };
          Object.entries(node.primary || {}).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            const label = primaryLabels[key] || key;
            const sign = value >= 0 ? "+" : "";
            parts.push(`${label}${sign}${value}`);
          });
          const secondaryText = formatSkillBonusText(node.bonus || {});
          if (secondaryText) parts.push(secondaryText);
          if (node.special?.attackCountBonus) {
            parts.push(`攻撃回数+${node.special.attackCountBonus}`);
          }
          if (node.special?.attackTargetsBonus) {
            parts.push(`攻撃対象+${node.special.attackTargetsBonus}`);
          }
          return parts.length ? parts.join(" / ") : "効果なし";
        }

        ensurePassiveTreeState();

        function mergeSkillsFromSave(savedSkills = {}) {
          Object.values(skills).forEach((skill) => {
            const base = SKILL_DEFINITION_MAP[skill.key] || {};
            const saved = savedSkills[skill.key] || {};
            const level = saved.level ?? 0;
            const max = saved.max ?? SKILL_MAX_LEVEL;
            Object.assign(skill, base, { level, max });
          });
        }

        function computeSkillBonusAtLevel(skill, level = 0) {
          const target = {};
          const effectiveLevel = Math.max(0, level || 0);
          if (!skill || effectiveLevel <= 0) return target;
          if (skill.scaling?.perLevel) {
            const growthMultiplier = Math.max(
              1,
              getSkillGrowthMultiplier(effectiveLevel),
            );
            addBonus(
              target,
              skill.scaling.perLevel,
              effectiveLevel * growthMultiplier,
            );
          }
          (skill.thresholds || []).forEach((threshold) => {
            if (effectiveLevel >= threshold.level)
              addBonus(target, threshold.bonus);
          });
          return target;
        }

        function describeSkillBonusAtLevel(
          skill,
          level,
          { locked = false, label = "現在効果" } = {},
        ) {
          if (locked) return `${label}: ？？？`;
          if (!level || level <= 0) return `${label}: 未習得`;
          const summary = formatSkillBonusText(
            computeSkillBonusAtLevel(skill, level),
          );
          return `${label}: ${summary || "効果なし"}`;
        }

        function describeSkillNextBonus(skill, { locked = false } = {}) {
          if (locked) return "次Lv合計: ？？？";
          const maxLevel = skill.max ?? SKILL_MAX_LEVEL;
          if ((skill.level ?? 0) >= maxLevel) return "次Lv合計: 最大Lvに到達";
          const nextLevel = Math.min((skill.level ?? 0) + 1, maxLevel);
          const summary = formatSkillBonusText(
            computeSkillBonusAtLevel(skill, nextLevel),
          );
          return `次Lv合計: ${summary || "追加効果なし"}`;
        }

        function addBonus(target, bonus = {}, multiplier = 1) {
          if (!target || !bonus) return;
          Object.entries(bonus).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            target[key] = (target[key] ?? 0) + value * multiplier;
          });
        }

        function calculateSkillBonuses() {
          const aggregated = createEmptyBonus();
          Object.values(skills).forEach((skill) => {
            const level = skill.level ?? 0;
            const reached = [];
            if (level > 0 && isSkillUnlocked(skill)) {
              if (skill.scaling?.perLevel) {
                const growthMultiplier = Math.max(
                  1,
                  getSkillGrowthMultiplier(level),
                );
                addBonus(
                  aggregated,
                  skill.scaling.perLevel,
                  level * growthMultiplier,
                );
              }
              (skill.thresholds || []).forEach((threshold) => {
                if (level >= threshold.level) {
                  addBonus(aggregated, threshold.bonus);
                  reached.push(threshold);
                }
              });
            }
            skill.reachedThresholds = reached;
          });
          player.skillBonus = aggregated;
          return aggregated;
        }

        function formatSkillBonusText(bonus = {}) {
          const labels = {
            hp: "最大HP",
            mp: "最大MP",
            physAtk: "物理攻撃",
            magAtk: "魔法攻撃",
            physDef: "物理防御",
            magDef: "魔法防御",
            speed: "行動速度",
            critRate: "クリ率",
            critDamage: "クリダメ",
            physPen: "物理貫通",
            magPen: "魔法貫通",
            damageReduction: "被ダメ軽減",
            block: "ブロック",
            controlResist: "行動阻害耐性",
            dotResist: "DoT耐性",
            debuffResist: "弱体耐性",
            cooldown: "CT短縮",
            hpRegen: "HP再生",
            lifeSteal: "HP吸収",
            barrier: "バリア",
            dropRate: "ドロップ率",
            rarity: "レア率",
            goldChance: "ゴールド率",
            titleChance: "称号率",
            namedRate: "ネームド率",
          };
          const percentKeys = [
            "critRate",
            "critDamage",
            "physPen",
            "magPen",
            "damageReduction",
            "block",
            "controlResist",
            "dotResist",
            "debuffResist",
            "lifeSteal",
            "dropRate",
            "rarity",
            "goldChance",
            "titleChance",
            "namedRate",
            "cooldown",
          ];
          return Object.entries(bonus)
            .map(([key, value]) => {
              if (typeof value !== "number") return null;
              const label = labels[key] || key;
              const unit = percentKeys.includes(key) ? "%" : "";
              const formatted =
                Math.abs(value) >= 1
                  ? Math.abs(value).toFixed(0)
                  : Math.abs(value).toFixed(2);
              const sign = value >= 0 ? "+" : "-";
              return `${label}${sign}${formatted}${unit}`;
            })
            .filter(Boolean)
            .join(" / ");
        }

        function log(message, type = "info", options = {}) {
          const { asHtml = false } = options;
          const logBox = document.getElementById("log");
          const entry = document.createElement("div");
          entry.className = `entry ${type}`;
          entry.classList.add("log-enter");
          if (asHtml) {
            entry.innerHTML = message;
          } else {
            entry.textContent = message;
          }
          logBox.append(entry);
          logBox.scrollTop = logBox.scrollHeight;
        }

        const swipeTrack = document.getElementById("panel-track");
        const swipeSlides = swipeTrack
          ? Array.from(swipeTrack.querySelectorAll(".swipe-slide"))
          : [];
        const swipePrev = document.getElementById("panel-prev");
        const swipeNext = document.getElementById("panel-next");
        const swipeTitle = document.getElementById("panel-title");
        const swipeLabels = {
          enemies: "敵カード",
          log: "バトルログ",
        };
        let activeSwipeIndex = 0;
        let swipeStartX = null;
        let swipeDeltaX = 0;

        function setActivePanel(index) {
          if (!swipeTrack || swipeSlides.length === 0) return;
          const nextIndex = Math.min(
            swipeSlides.length - 1,
            Math.max(0, index),
          );
          activeSwipeIndex = nextIndex;
          swipeTrack.style.transition = "transform 0.24s ease";
          swipeTrack.style.transform = `translateX(-${nextIndex * 100}%)`;
          swipeSlides.forEach((slide, i) => {
            const isActive = i === nextIndex;
            slide.classList.toggle("active", isActive);
            slide.setAttribute("aria-hidden", isActive ? "false" : "true");
          });
          if (swipeTitle) {
            const key =
              swipeSlides[nextIndex]?.dataset.panel || `${nextIndex + 1}`;
            swipeTitle.textContent =
              swipeLabels[key] || `ビュー ${nextIndex + 1}`;
          }
          if (swipePrev) swipePrev.disabled = nextIndex === 0;
          if (swipeNext)
            swipeNext.disabled = nextIndex === swipeSlides.length - 1;
        }

        function handleSwipeStart(e) {
          if (!swipeTrack) return;
          swipeStartX = e.touches?.[0]?.clientX ?? e.clientX;
          swipeDeltaX = 0;
          swipeTrack.style.transition = "none";
        }

        function handleSwipeMove(e) {
          if (swipeStartX === null || !swipeTrack) return;
          const currentX = e.touches?.[0]?.clientX ?? e.clientX;
          swipeDeltaX = currentX - swipeStartX;
          swipeTrack.style.transform = `translateX(calc(-${activeSwipeIndex * 100}% + ${swipeDeltaX}px))`;
        }

        function handleSwipeEnd() {
          if (swipeStartX === null || !swipeTrack) return;
          const threshold = 45;
          if (swipeDeltaX > threshold) {
            setActivePanel(activeSwipeIndex - 1);
          } else if (swipeDeltaX < -threshold) {
            setActivePanel(activeSwipeIndex + 1);
          } else {
            setActivePanel(activeSwipeIndex);
          }
          swipeStartX = null;
          swipeDeltaX = 0;
        }

        if (swipeTrack) {
          swipeTrack.addEventListener("touchstart", handleSwipeStart, {
            passive: true,
          });
          swipeTrack.addEventListener("touchmove", handleSwipeMove, {
            passive: true,
          });
          swipeTrack.addEventListener("touchend", handleSwipeEnd);
          swipeTrack.addEventListener("touchcancel", handleSwipeEnd);
          swipeTrack.addEventListener("mousedown", handleSwipeStart);
          swipeTrack.addEventListener("mousemove", (e) => {
            if (swipeStartX !== null && e.buttons === 1) handleSwipeMove(e);
          });
          swipeTrack.addEventListener("mouseup", handleSwipeEnd);
          swipeTrack.addEventListener("mouseleave", handleSwipeEnd);
        }

        swipePrev?.addEventListener("click", () =>
          setActivePanel(activeSwipeIndex - 1),
        );
        swipeNext?.addEventListener("click", () =>
          setActivePanel(activeSwipeIndex + 1),
        );
        setActivePanel(0);

        const statusPopover = document.getElementById("status-popover");
        const statusPopoverName = document.getElementById(
          "status-popover-name",
        );
        const statusPopoverTurns = document.getElementById(
          "status-popover-turns",
        );
        const statusPopoverDesc = document.getElementById(
          "status-popover-desc",
        );
        const statusPopoverList = document.getElementById(
          "status-popover-list",
        );
        let statusPopoverTimer = null;

        const levelUpToast = document.getElementById("level-up-toast");
        const levelUpValue = document.getElementById("level-up-value");
        let levelUpToastTimer = null;

        const levelUpGuidance = document.getElementById("level-up-guidance");
        const levelUpGuidanceClose = document.getElementById(
          "level-up-guidance-close",
        );
        const menuSkillButton = document.getElementById("btn-skill-tree");
        const menuStatusButton = document.getElementById("btn-player-modal");
        const passiveTreeModal = document.getElementById("passive-tree-modal");
        const passiveTreeCloseButton =
          document.getElementById("passive-tree-close");
        const passiveTreeTabs = document.getElementById("passive-tree-tabs");
        const passiveTreePanel = document.getElementById("passive-tree-panel");
        const passiveTreePoints = document.getElementById("passive-points");
        const passiveTreeOpenSkillsButton = document.getElementById(
          "passive-tree-open-skills",
        );
        const passiveTreeResetButton =
          document.getElementById("passive-tree-reset");
        const treeCanvasContainer = document.getElementById("canvas-container");
        const treeViewport = document.getElementById("viewport");
        const treeNodesGroup = document.getElementById("nodes-group");
        const treeLinksGroup = document.getElementById("links-group");
        const enemyGuidance = document.getElementById("enemy-guidance");
        const enemyGuidanceClose = document.getElementById("enemy-guidance-close");

        const dropToastStack = document.getElementById("drop-toast-stack");
        const dropToastTemplate = document.getElementById("drop-toast-template");
        let enemyIntroShown = false;
        let enemyIntroActive = false;

        function fitDropItemName(target) {
          if (!target) return;
          target.style.fontSize = "";
          const computed = window.getComputedStyle(target);
          let size = Number.parseFloat(computed.fontSize) || 16;
          const minSize = 12;
          const maxTries = 8;
          let tries = 0;

          while (
            target.scrollWidth > target.clientWidth &&
            size > minSize &&
            tries < maxTries
          ) {
            size -= 1;
            target.style.fontSize = `${size}px`;
            tries += 1;
          }
        }

        const getStatus = (entity, key) =>
          (entity.statuses || []).find((s) => s.key === key);
        const hasStatus = (entity, key) => Boolean(getStatus(entity, key));

        function removeStatus(entity, key) {
          entity.statuses = (entity.statuses || []).filter(
            (s) => s.key !== key,
          );
        }

        function getResist(entity, category) {
          if (!entity.resist) return 0;
          return Math.max(0, Math.min(100, entity.resist[category] || 0));
        }

        function describeStatus(status) {
          const def = STATUS_DEFINITIONS[status.key];
          if (!def) return "";
          return `${def.description} / 残り${status.remaining}T`;
        }

        function describeBuff(key, remaining) {
          const def = BUFF_DEFINITIONS[key];
          if (!def) return "";
          return `${def.description} / 残り${remaining}T`;
        }

        function triggerLevelUpEffect(level) {
          if (!levelUpToast || !levelUpValue) return;
          levelUpValue.textContent = level;
          levelUpToast.setAttribute("aria-hidden", "false");
          levelUpToast.classList.remove("show");
          if (levelUpToastTimer) clearTimeout(levelUpToastTimer);
          void levelUpToast.offsetWidth;
          levelUpToast.classList.add("show");
          levelUpToastTimer = setTimeout(() => {
            levelUpToast?.classList.remove("show");
            levelUpToast?.setAttribute("aria-hidden", "true");
          }, 1900);
        }

        function setMenuHighlight(enabled) {
          [menuSkillButton, menuStatusButton].forEach((btn) => {
            if (!btn) return;
            btn.classList.toggle("menu-button-highlight", Boolean(enabled));
          });
        }

        function hideLevelUpGuidance() {
          levelUpGuidance?.classList.remove("show");
          levelUpGuidance?.setAttribute("aria-hidden", "true");
          setMenuHighlight(false);
        }

        function showLevelUpGuidance() {
          if (!levelUpGuidance) return;
          levelUpGuidance.classList.remove("show");
          void levelUpGuidance.offsetWidth;
          levelUpGuidance.setAttribute("aria-hidden", "false");
          levelUpGuidance.classList.add("show");
          setMenuHighlight(true);
        }

        levelUpGuidanceClose?.addEventListener("click", hideLevelUpGuidance);

        let activePassiveTreeCategory = SKILL_CATEGORIES[0];
        let passiveTreeNodes = [];
        let passiveTreeLinks = [];
        let passiveTreeAdjacency = {};
        let selectedPassiveNodeId = null;
        const passiveTreeView = {
          scale: 0.45,
          panX: window.innerWidth / 2,
          panY: window.innerHeight / 2,
        };
        const passiveTreePointers = new Map();
        let passiveTreePinchDistance = null;
        let passiveTreePinchScale = null;

        function updatePassiveTreeTransform() {
          if (!treeViewport) return;
          treeViewport.setAttribute(
            "transform",
            `translate(${passiveTreeView.panX}, ${passiveTreeView.panY}) scale(${passiveTreeView.scale})`,
          );
        }

        function refreshPassiveTreePoints() {
          if (passiveTreePoints) {
            passiveTreePoints.textContent = player.passivePoints;
          }
        }

        function setActivePassiveTreeCategory(category) {
          if (!SKILL_CATEGORIES.includes(category)) return;
          activePassiveTreeCategory = category;
          selectedPassiveNodeId = null;
          renderPassiveTreeTabs();
          renderPassiveTree();
        }

        function renderPassiveTreeTabs() {
          if (!passiveTreeTabs) return;
          passiveTreeTabs.innerHTML = "";
          SKILL_CATEGORIES.forEach((category) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = category;
            btn.classList.toggle("active", category === activePassiveTreeCategory);
            btn.onclick = () => {
              setActivePassiveTreeCategory(category);
            };
            passiveTreeTabs.appendChild(btn);
          });
        }

        function applyPassiveTreeBackground() {
          if (!treeCanvasContainer) return;
          treeCanvasContainer.classList.remove(
            "tree-bg-sword",
            "tree-bg-mage",
            "tree-bg-cleric",
            "tree-bg-vampire",
          );
          const map = {
            剣士: "tree-bg-sword",
            魔法: "tree-bg-mage",
            聖職: "tree-bg-cleric",
            吸血: "tree-bg-vampire",
          };
          const className = map[activePassiveTreeCategory];
          if (className) treeCanvasContainer.classList.add(className);
        }

        function getPassiveNodeTypeLabel(kind, unlockType) {
          if (kind === "start") return "起点";
          if (kind === "core") return "コア";
          if (kind === "exit") return "ルート出口";
          if (kind === "keystone") return "キーストーン";
          if (kind === "skill") {
            return unlockType === "category" ? "系統解放" : "スキル解放";
          }
          return "ステータス";
        }

        function renderPassiveTreePanel(node) {
          if (!passiveTreePanel) return;
          passiveTreePanel.innerHTML = "";
          if (!node) {
            const title = document.createElement("div");
            title.className = "node-title";
            title.textContent = "ノード未選択";
            const meta = document.createElement("div");
            meta.className = "node-meta";
            meta.textContent = "ツリー上のノードを選ぶと効果が表示されます。";
            passiveTreePanel.appendChild(title);
            passiveTreePanel.appendChild(meta);
            return;
          }

          const title = document.createElement("div");
          title.className = "node-title";
          title.textContent = node.name || "ノード";
          const type = document.createElement("div");
          type.className = "node-type";
          type.textContent = getPassiveNodeTypeLabel(node.kind, node.unlockType);

          const desc = document.createElement("div");
          desc.className = "node-effect";
          desc.textContent = node.desc || formatPassiveNodeEffect(node);

          const effect = document.createElement("div");
          effect.className = "node-effect";
          effect.textContent = `効果: ${formatPassiveNodeEffect(node)}`;

          const status = document.createElement("div");
          const unlockable = canUnlockPassiveNode(
            activePassiveTreeCategory,
            node.id,
          );
          if (node.active) {
            status.className = "node-success";
            status.textContent = "取得済み";
          } else if (unlockable) {
            status.className = "node-meta";
            status.textContent = "取得可能";
          } else {
            status.className = "node-warning";
            status.textContent = "未接続 / パッシブP不足";
          }

          passiveTreePanel.appendChild(title);
          passiveTreePanel.appendChild(type);
          passiveTreePanel.appendChild(desc);
          passiveTreePanel.appendChild(effect);

          if (node.kind === "skill" && node.unlocks?.length) {
            const unlockList = document.createElement("div");
            unlockList.className = "node-meta";
            const names = node.unlocks
              .map((key) => SKILL_DEFINITION_MAP[key]?.name || key)
              .join(" / ");
            unlockList.textContent = `解放: ${names}`;
            passiveTreePanel.appendChild(unlockList);
          }

          passiveTreePanel.appendChild(status);

          const actions = document.createElement("div");
          actions.className = "node-actions";
          if (!node.active) {
            const unlockButton = document.createElement("button");
            unlockButton.className = "mini-btn";
            unlockButton.textContent = "取得する";
            unlockButton.disabled = !unlockable;
            unlockButton.onclick = () => {
              if (unlockPassiveNode(activePassiveTreeCategory, node.id)) {
                renderPassiveTree();
              }
            };
            actions.appendChild(unlockButton);
          }
          passiveTreePanel.appendChild(actions);
        }

        function renderPassiveTree() {
          if (!treeNodesGroup || !treeLinksGroup) return;
          applyPassiveTreeBackground();
          const state = getPassiveTreeState(activePassiveTreeCategory);
          passiveTreeNodes = state.nodes;
          passiveTreeLinks = state.links;
          passiveTreeAdjacency = state.adjacency || {};

          treeNodesGroup.innerHTML = "";
          treeLinksGroup.innerHTML = "";

          passiveTreeLinks.forEach((link) => {
            const s = passiveTreeNodes.find((node) => node.id === link.s);
            const t = passiveTreeNodes.find((node) => node.id === link.t);
            if (!s || !t) return;
            const isActive = s.active && t.active;
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line",
            );
            const x1 = link.vSrc ? link.vSrc.x : s.x;
            const y1 = link.vSrc ? link.vSrc.y : s.y;
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", t.x);
            line.setAttribute("y2", t.y);
            line.setAttribute(
              "stroke",
              isActive ? "var(--accent-blue)" : "rgba(255,255,255,0.06)",
            );
            line.setAttribute("stroke-width", isActive ? "5" : "2.2");
            if (isActive) line.classList.add("active-path");
            treeLinksGroup.appendChild(line);
          });

          passiveTreeNodes.forEach((node) => {
            const circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle",
            );
            let r = 9;
            let fill = "#0f172a";
            let stroke = "rgba(255,255,255,0.2)";

            if (node.kind === "start") {
              r = 26;
              stroke = "#fff";
              fill = "#fff";
            } else if (node.kind === "keystone") {
              r = 18;
              stroke = "var(--keystone-gold)";
            } else if (node.kind === "exit") {
              r = 36;
              stroke = "var(--active-red)";
            } else if (node.kind === "core") {
              r = 13;
              stroke = "rgba(255,255,255,0.4)";
            } else if (node.kind === "skill") {
              r = 14;
              stroke = "var(--accent-blue)";
            }

            if (node.active) {
              if (node.kind === "start") fill = "#fff";
              else if (node.kind === "exit") fill = "var(--active-red)";
              else if (node.kind === "keystone")
                fill = "var(--keystone-gold)";
              else fill = "var(--accent-blue)";
              circle.style.filter = `drop-shadow(0 0 12px ${fill})`;
            }

            circle.setAttribute("cx", node.x);
            circle.setAttribute("cy", node.y);
            circle.setAttribute("r", r);
            circle.setAttribute("fill", fill);
            circle.setAttribute("stroke", stroke);
            circle.setAttribute("stroke-width", "3.5");
            circle.classList.add("node");
            circle.dataset.nodeId = node.id;
            if (!node.active) circle.classList.add("locked");
            if (canUnlockPassiveNode(activePassiveTreeCategory, node.id)) {
              circle.classList.add("unlockable");
            }
            treeNodesGroup.appendChild(circle);
          });

          refreshPassiveTreePoints();
          renderPassiveTreePanel(
            passiveTreeNodes.find((node) => node.id === selectedPassiveNodeId),
          );
          updatePassiveTreeTransform();
        }

        function selectPassiveTreeNode(nodeId) {
          selectedPassiveNodeId = nodeId;
          const node = passiveTreeNodes.find((entry) => entry.id === nodeId);
          renderPassiveTreePanel(node);
        }

        function openPassiveTreeModal() {
          if (!passiveTreeModal) return;
          ensurePassiveTreeState();
          recalcDerivedStats();
          if (treeCanvasContainer) {
            passiveTreeView.panX = treeCanvasContainer.clientWidth / 2;
            passiveTreeView.panY = treeCanvasContainer.clientHeight / 2;
          }
          applyPassiveTreeBackground();
          setActivePassiveTreeCategory(activePassiveTreeCategory);
          passiveTreeModal.classList.remove("hidden");
        }

        function closePassiveTreeModal() {
          passiveTreeModal?.classList.add("hidden");
        }

        function handlePassiveTreePointerDown(event) {
          if (!treeCanvasContainer) return;
          treeCanvasContainer.setPointerCapture(event.pointerId);
          passiveTreePointers.set(event.pointerId, {
            x: event.clientX,
            y: event.clientY,
          });
          if (passiveTreePointers.size === 2) {
            const points = Array.from(passiveTreePointers.values());
            const dx = points[0].x - points[1].x;
            const dy = points[0].y - points[1].y;
            passiveTreePinchDistance = Math.hypot(dx, dy);
            passiveTreePinchScale = passiveTreeView.scale;
          }
        }

        function handlePassiveTreePointerMove(event) {
          if (!passiveTreePointers.has(event.pointerId)) return;
          const prev = passiveTreePointers.get(event.pointerId);
          passiveTreePointers.set(event.pointerId, {
            x: event.clientX,
            y: event.clientY,
          });

          if (passiveTreePointers.size === 1 && prev) {
            const dx = event.clientX - prev.x;
            const dy = event.clientY - prev.y;
            passiveTreeView.panX += dx;
            passiveTreeView.panY += dy;
            updatePassiveTreeTransform();
            return;
          }

          if (passiveTreePointers.size === 2 && passiveTreePinchDistance) {
            const points = Array.from(passiveTreePointers.values());
            const dx = points[0].x - points[1].x;
            const dy = points[0].y - points[1].y;
            const distance = Math.hypot(dx, dy);
            const scale =
              (passiveTreePinchScale || passiveTreeView.scale) *
              (distance / passiveTreePinchDistance);
            passiveTreeView.scale = Math.min(1.2, Math.max(0.2, scale));
            updatePassiveTreeTransform();
          }
        }

        function handlePassiveTreePointerUp(event) {
          passiveTreePointers.delete(event.pointerId);
          if (passiveTreePointers.size < 2) {
            passiveTreePinchDistance = null;
            passiveTreePinchScale = null;
          }
        }

        function handlePassiveTreeWheel(event) {
          if (!passiveTreeModal || passiveTreeModal.classList.contains("hidden"))
            return;
          event.preventDefault();
          const delta = event.deltaY > 0 ? -0.05 : 0.05;
          passiveTreeView.scale = Math.min(
            1.2,
            Math.max(0.2, passiveTreeView.scale + delta),
          );
          updatePassiveTreeTransform();
        }

        function bindPassiveTreeEvents() {
          if (!treeNodesGroup || !treeCanvasContainer) return;
          treeNodesGroup.addEventListener("click", (event) => {
            const target = event.target;
            const nodeId = target?.dataset?.nodeId;
            if (!nodeId) return;
            selectPassiveTreeNode(nodeId);
          });
          treeCanvasContainer.addEventListener(
            "pointerdown",
            handlePassiveTreePointerDown,
          );
          treeCanvasContainer.addEventListener(
            "pointermove",
            handlePassiveTreePointerMove,
          );
          treeCanvasContainer.addEventListener(
            "pointerup",
            handlePassiveTreePointerUp,
          );
          treeCanvasContainer.addEventListener(
            "pointercancel",
            handlePassiveTreePointerUp,
          );
          treeCanvasContainer.addEventListener("wheel", handlePassiveTreeWheel, {
            passive: false,
          });
        }

        bindPassiveTreeEvents();

        window.addEventListener("resize", () => {
          if (!treeCanvasContainer) return;
          if (passiveTreeModal?.classList.contains("hidden")) return;
          passiveTreeView.panX = treeCanvasContainer.clientWidth / 2;
          passiveTreeView.panY = treeCanvasContainer.clientHeight / 2;
          updatePassiveTreeTransform();
        });

        function syncEnemyHighlight() {
          const cards = document.querySelectorAll("#enemies .enemy-card");
          cards.forEach((card) => {
            card.classList.toggle("enemy-highlight", enemyIntroActive);
            const archetypeTag = card.querySelector(".tag.clickable");
            archetypeTag?.classList.toggle("enemy-highlight", enemyIntroActive);
          });
        }

        function hideEnemyIntroGuidance() {
          enemyIntroActive = false;
          enemyGuidance?.classList.remove("show");
          enemyGuidance?.setAttribute("aria-hidden", "true");
          syncEnemyHighlight();
        }

        function showEnemyIntroGuidance() {
          if (enemyIntroShown || player.level !== 1 || !enemyGuidance) return;
          enemyIntroShown = true;
          enemyIntroActive = true;
          enemyGuidance.classList.remove("show");
          void enemyGuidance.offsetWidth;
          enemyGuidance.setAttribute("aria-hidden", "false");
          enemyGuidance.classList.add("show");
          syncEnemyHighlight();
        }

        enemyGuidanceClose?.addEventListener("click", hideEnemyIntroGuidance);
        enemyGuidance?.addEventListener("click", (event) => {
          if (event.target === enemyGuidanceClose) return;
          const targetEnemy = game.enemies?.find((e) => e);
          if (targetEnemy) openEnemyModal(targetEnemy);
        });

        function maybeShowEnemyIntroGuidance() {
          if (enemyIntroShown) return;
          if (player.level !== 1) return;
          if (!game.enemies || game.enemies.length === 0) return;
          showEnemyIntroGuidance();
        }

        function isDropToastEnabledForRarity(rarity) {
          if (!rarity) return true;
          if (!BULK_SELL_RARITY_ORDER.includes(rarity)) return true;
          return dropToastNotificationRarities.has(rarity);
        }

        function isAutoSellEnabledForRarity(rarity) {
          if (!rarity) return false;
          if (!BULK_SELL_RARITY_ORDER.includes(rarity)) return false;
          return autoSellRarities.has(rarity);
        }

        function triggerDropCelebration(item) {
          const rarityKey = getItemRarityKey(item) || "normal";
          if (!isDropToastEnabledForRarity(rarityKey)) return;
          if (!dropToastTemplate || !dropToastStack) return;
          const rarity = rarityKey;
          const isShowy = rarity === "rare" || rarity === "legendary";
          const label = rarity === "legendary" ? "LEGENDARY DROP" : "RARE DROP";
          const name = item?.name || item?.potion?.name || "???";

          const toast = dropToastTemplate.content.firstElementChild.cloneNode(true);
          const pill = toast.querySelector(".drop-pill");
          const nameEl = toast.querySelector(".drop-item-name");
          if (!pill || !nameEl) return;

          pill.textContent = label;
          pill.style.display = isShowy ? "" : "none";
          nameEl.textContent = name;

          toast.setAttribute("aria-hidden", "false");
          toast.classList.remove("show", "rare", "legendary", "simple");
          toast.classList.add("show", isShowy ? rarity : "simple");
          dropToastStack.appendChild(toast);

          requestAnimationFrame(() => fitDropItemName(nameEl));

          setTimeout(() => {
            toast?.classList.remove("show");
            toast?.setAttribute("aria-hidden", "true");
            setTimeout(() => toast?.remove(), 300);
          }, 2600);
        }

        function collectActiveEffects(entity) {
          const effects = [];
          (entity.statuses || []).forEach((status) => {
            const def = STATUS_DEFINITIONS[status.key];
            if (!def) return;
            effects.push({
              key: status.key,
              type: "status",
              def,
              remaining: status.remaining,
              description: def.description,
              category: def.category,
              status,
            });
          });
          Object.entries(entity.buffs || {}).forEach(([key, remaining]) => {
            if (remaining <= 0) return;
            const def = BUFF_DEFINITIONS[key];
            if (!def) return;
            effects.push({
              key,
              type: "buff",
              def,
              remaining,
              description: def.description,
              category: "buff",
            });
          });
          return effects;
        }

        function showStatusPopover(entity, focusKey = null) {
          if (
            !statusPopover ||
            !statusPopoverName ||
            !statusPopoverList ||
            !entity
          )
            return;
          const effects = collectActiveEffects(entity);
          statusPopoverName.textContent = effects.length
            ? "付与中の効果"
            : "効果なし";
          if (effects.length) {
            statusPopoverTurns.style.display = "";
            statusPopoverTurns.textContent = `${effects.length} 件`;
            statusPopoverDesc.textContent = "バフ・デバフと残りターン";
          } else {
            statusPopoverTurns.style.display = "none";
            statusPopoverDesc.textContent = "現在、付与中の効果はありません。";
          }
          statusPopoverList.innerHTML = "";
          effects.forEach((effect) => {
            const row = document.createElement("div");
            row.className = "effect-row";
            if (focusKey && effect.key === focusKey) {
              row.classList.add("highlight");
            }
            const pill = document.createElement("div");
            pill.className = `status-pill ${effect.category}`;
            pill.textContent = effect.def.short;

            const meta = document.createElement("div");
            meta.className = "effect-meta";
            const name = document.createElement("div");
            name.className = "effect-name";
            name.textContent = effect.def.name;
            const desc = document.createElement("div");
            desc.className = "effect-desc";
            desc.textContent = effect.description;
            meta.appendChild(name);
            meta.appendChild(desc);

            const turns = document.createElement("div");
            turns.className = "effect-turns";
            turns.textContent = `残り ${effect.remaining}T`;

            row.appendChild(pill);
            row.appendChild(meta);
            row.appendChild(turns);
            statusPopoverList.appendChild(row);
          });

          statusPopover.classList.remove("hidden");
          if (statusPopoverTimer) clearTimeout(statusPopoverTimer);
          statusPopoverTimer = setTimeout(
            () => statusPopover.classList.add("hidden"),
            3200,
          );
        }

        statusPopover.addEventListener("click", () =>
          statusPopover.classList.add("hidden"),
        );

        const primaryOrder = ["str", "int", "vit", "agi", "luck"];
        const stepOptions = [1, 10, 50];
        let currentStepIndex = 0;
        const skillStepOptions = [1, 10, 50];
        let currentSkillStepIndex = 0;
        let selectedSkillCategory = SKILL_CATEGORIES[0];
        let selectedSkillType = "active";
        let skillSummaryVisible = false;
        let pendingResetSpent = 0;
        let playerModalPage = "status";

        const displayNumber = (num, { isPercent = false } = {}) => {
          if (isPercent) {
            return (Math.round(num * 10) / 10).toFixed(1);
          }
          return Math.round(num);
        };

        function formatStatValue(value, unit = "") {
          const isPercent = unit === "%";
          const total = displayNumber(value, { isPercent });
          if (isPercent) {
            return `<span class="total">${total}${unit}</span>`;
          }
          return `<span class="total">${total}</span>`;
        }

        const formatPrimaryValue = (stat) => {
          const total = stat.base + stat.bonus;
          if (!stat.bonus) return `<span class="total">${total}</span>`;
          const bonusSign = stat.bonus > 0 ? "+" : "";
          return `<span class="total">${total}</span> (<span class="base">${stat.base}</span> <span class="bonus">${bonusSign}${stat.bonus}</span>)`;
        };

        const statTotal = (key) => {
          const stat = player.primary[key];
          return stat.base + stat.bonus;
        };

        const BASE_GROWTH_RATE = 1.012;
        const PLAYER_GROWTH_ADVANTAGE_PER_LEVEL = 0.0008;
        const PLAYER_GROWTH_ADVANTAGE_CAP = 0.08;
        const BOSS_GROWTH_MULTIPLIER = 1.1;
        const BOSS_SECONDARY_MULTIPLIER = 1.05;

        function playerGrowthMultiplier(level) {
          const effective = Math.max(1, Math.floor(level || 1));
          const baseGrowth = Math.pow(BASE_GROWTH_RATE, effective - 1);
          const advantage =
            1 +
            Math.min(
              PLAYER_GROWTH_ADVANTAGE_CAP,
              (effective - 1) * PLAYER_GROWTH_ADVANTAGE_PER_LEVEL,
            );
          return baseGrowth * advantage;
        }

        function calcSecondaryStats() {
          const str = statTotal("str");
          const int = statTotal("int");
          const vit = statTotal("vit");
          const agi = statTotal("agi");
          const luck = statTotal("luck");

          // ---- 基本ステータス系 ----
          const baseGrowth = playerGrowthMultiplier(player.level);

          const maxHpBase = (player.base.hp + vit * 16.0) * baseGrowth;
          const maxMpBase = (player.base.mp + int * 7.0) * baseGrowth;
          const physAtkBase = (player.base.physAtk + str * 2.8) * baseGrowth;
          const magAtkBase = (player.base.magAtk + int * 3.1) * baseGrowth;
          const physDefBase =
            (player.base.physDef + vit * 1.2 + str * 0.45) * baseGrowth;
          const magDefBase =
            (player.base.magDef + vit * 1.0 + int * 0.7) * baseGrowth;
          const speedBase = (player.base.speed + agi * 2.2) * baseGrowth;

          // 会心・命中・貫通など
          const critBase = Math.min(150, (agi + luck) * 1.3);
          const evadeBase = Math.min(118, (agi + luck) * 0.8);
          const accuracyBase = Math.min(200, 140 + agi * 0.26);
          const physPenBase = Math.min(64, str * 0.5);
          const magPenBase = Math.min(64, int * 0.5);
          const critDmgBase = Math.min(112, luck * 1.3);

          // ---- 防御まわり（方針：体力は関与せず、装備・スキル由来のみ） ----
          // ・被ダメ軽減：装備・スキルでのみ積む。ここでは0固定。
          // ・ブロック率：同上。
          // ・HP再生 / 吸収 / バリア：同上。
          const damageReductionBase = 0;
          const blockBase = 0;

          // 抵抗は体力/知識/運ベースのまま維持
          const controlResistBase = Math.min(120, (vit + luck) * 0.7);
          const dotResistBase = Math.min(120, vit * 0.9 + luck * 0.2);
          const debuffResistBase = Math.min(
            120,
            (vit + int) * 0.7 + luck * 0.2,
          );

          const cooldownBase = Math.min(40, (agi + int) * 0.28);

          // 体力には依存しないよう、ここはすべて 0 をベースとする
          const hpRegenBase = 0;
          const lifeStealBase = 0;
          const barrierBase = 0;

          // ---- トレハン系（運ベース）----
          // 方針：
          //  ・LUKが低くても「ごくわずかには」増える（5振って約1%）
          //  ・しきい値を超えたあたりからグッと伸びる二段階カーブ

          const baseSlope = 0.4; // 全トレハン共通の「低LUK帯のゆるい伸び」(LUK5→+2%)

          // しきい値を超えた分には、追加の傾きを足して「高LUK帯で伸びやすく」する
          // （数字は「LUK100での目安」がだいたい以前のバランスに近くなるように調整）

          // ドロップ数寄り（LUK30から本格的に効き始めるイメージ）
          const dropBaseline = 20; // 軽くベースを底上げして全体のドロップ体験を滑らかに
          const dropExtraSlope = 0.64;
          const dropThreshold = 60;

          // レアリティUP（LUK40からじわじわ）
          const rarityExtraSlope = 0.14;
          const rarityThreshold = 80;

          // 称号付与率（LUK40からそこそこ伸びる）
          const titleExtraSlope = 0.34;
          const titleThreshold = 80;

          // ネームド遭遇（他より少し効きやすい）
          const namedExtraSlope = 0.9;
          const namedThreshold = 40;

          // 実際の計算
          const dropRateBase =
            dropBaseline +
            luck * baseSlope +
            Math.max(0, luck - dropThreshold) * dropExtraSlope;

          const rarityBase =
            luck * baseSlope +
            Math.max(0, luck - rarityThreshold) * rarityExtraSlope;

          const titleChanceBase =
            luck * baseSlope +
            Math.max(0, luck - titleThreshold) * titleExtraSlope;

          const namedRateBase =
            luck * baseSlope +
            Math.max(0, luck - namedThreshold) * namedExtraSlope;

          // ゴールド率は「基礎100%」のまま
          const goldChanceBase = 200;

          return {
            // ---- 基礎系 ----
            maxHp: {
              base: maxHpBase,
              bonus: player.bonus.hp,
              total: maxHpBase + player.bonus.hp,
            },
            maxMp: {
              base: maxMpBase,
              bonus: player.bonus.mp,
              total: maxMpBase + player.bonus.mp,
            },
            physAtk: {
              base: physAtkBase,
              bonus: player.bonus.physAtk,
              total: physAtkBase + player.bonus.physAtk,
            },
            magAtk: {
              base: magAtkBase,
              bonus: player.bonus.magAtk,
              total: magAtkBase + player.bonus.magAtk,
            },
            physDef: {
              base: physDefBase,
              bonus: player.bonus.physDef,
              total: physDefBase + player.bonus.physDef,
            },
            magDef: {
              base: magDefBase,
              bonus: player.bonus.magDef,
              total: magDefBase + player.bonus.magDef,
            },
            speed: {
              base: speedBase,
              bonus: player.bonus.speed,
              total: speedBase + player.bonus.speed,
            },

            // ---- 行動・会心 ----
            critRate: {
              base: critBase,
              bonus: player.bonus.critRate,
              total: Math.min(140, critBase + player.bonus.critRate),
            },
            evade: {
              base: evadeBase,
              bonus: player.bonus.evade,
              total: Math.min(120, evadeBase + player.bonus.evade),
            },
            accuracy: { base: accuracyBase, bonus: 0, total: accuracyBase },
            physPen: {
              base: physPenBase,
              bonus: player.bonus.physPen,
              total: Math.min(60, physPenBase + player.bonus.physPen),
            },
            magPen: {
              base: magPenBase,
              bonus: player.bonus.magPen,
              total: Math.min(60, magPenBase + player.bonus.magPen),
            },
            critDamage: {
              base: critDmgBase,
              bonus: player.bonus.critDamage,
              total: Math.min(100, critDmgBase + player.bonus.critDamage),
            },

            // ---- 防御周り（体力非依存） ----
            damageReduction: {
              base: damageReductionBase,
              bonus: player.bonus.damageReduction,
              // 「最終ダメージ−X%」としての上限80%は維持
              total: Math.min(
                80,
                damageReductionBase + player.bonus.damageReduction,
              ),
            },
            block: {
              base: blockBase,
              bonus: player.bonus.block,
              total: Math.min(50, blockBase + player.bonus.block),
            },
            controlResist: {
              base: controlResistBase,
              bonus: player.bonus.controlResist,
              total: Math.min(
                120,
                controlResistBase + player.bonus.controlResist,
              ),
            },
            dotResist: {
              base: dotResistBase,
              bonus: player.bonus.dotResist,
              total: Math.min(120, dotResistBase + player.bonus.dotResist),
            },
            debuffResist: {
              base: debuffResistBase,
              bonus: player.bonus.debuffResist,
              total: Math.min(120, debuffResistBase + player.bonus.debuffResist),
            },
            cooldown: {
              base: cooldownBase,
              bonus: player.bonus.cooldown,
              total: Math.min(40, cooldownBase + player.bonus.cooldown),
            },

            // HP再生・吸収・バリアは 0 ＋ 装備／スキル由来のみ
            hpRegen: {
              base: hpRegenBase,
              bonus: player.bonus.hpRegen,
              total: hpRegenBase + player.bonus.hpRegen,
            },
            lifeSteal: {
              base: lifeStealBase,
              bonus: player.bonus.lifeSteal,
              total: Math.min(20, lifeStealBase + player.bonus.lifeSteal),
            },
            barrier: {
              base: barrierBase,
              bonus: player.bonus.barrier,
              total: barrierBase + player.bonus.barrier,
            },

            // ---- トレハン関連 ----
            // ステータスの total は下限0のみ。上限は「効果側」で解釈。
            dropRate: {
              base: dropRateBase,
              bonus: player.bonus.dropRate,
              total: Math.max(0, dropRateBase + player.bonus.dropRate),
            },
            rarity: {
              base: rarityBase,
              bonus: player.bonus.rarity,
              total: Math.max(0, rarityBase + player.bonus.rarity),
            },
            titleChance: {
              base: titleChanceBase,
              bonus: player.bonus.titleChance,
              total: Math.max(0, titleChanceBase + player.bonus.titleChance),
            },
            namedRate: {
              base: namedRateBase,
              bonus: player.bonus.namedRate,
              total: Math.max(0, namedRateBase + player.bonus.namedRate),
            },
            goldChance: {
              base: goldChanceBase,
              bonus: player.bonus.goldChance,
              total: Math.max(0, goldChanceBase + player.bonus.goldChance),
            },
          };
        }

        function collectEquipmentBonuses() {
          const secondary = createEmptyBonus();
          const primary = createEmptyPrimaryBonus();
          const primaryPerLevel = createEmptyPrimaryPerLevelBonus();
          const primaryFixed = createEmptyPrimaryFixedBonus();
          let attackCountBonus = 0;
          let attackTargetsBonus = 0;
          const uniqueOptions = [];
          Object.values(player.equipment || {}).forEach((item) => {
            if (!item?.equipment) return;
            const bonuses = getEquipmentBonuses(item);
            Object.entries(bonuses.primary || {}).forEach(([key, value]) => {
              if (typeof value !== "number") return;
              primary[key] = (primary[key] ?? 0) + value;
            });
            Object.entries(bonuses.secondary || {}).forEach(([key, value]) => {
              if (typeof value !== "number") return;
              secondary[key] = (secondary[key] ?? 0) + value;
            });
            Object.entries(bonuses.primaryPerLevel || {}).forEach(
              ([key, effects]) => {
                if (!Array.isArray(effects)) return;
                if (!primaryPerLevel[key]) primaryPerLevel[key] = [];
                effects.forEach((effect) => {
                  if (!effect) return;
                  primaryPerLevel[key].push({ ...effect });
                });
              },
            );
            Object.entries(bonuses.primaryFixed || {}).forEach(
              ([key, value]) => {
                if (typeof value !== "number") return;
                const current = primaryFixed[key];
                primaryFixed[key] =
                  typeof current === "number"
                    ? Math.max(current, value)
                    : value;
              },
            );
            if (typeof bonuses.attackCountBonus === "number") {
              attackCountBonus += bonuses.attackCountBonus;
            }
            if (typeof bonuses.attackTargetsBonus === "number") {
              attackTargetsBonus += bonuses.attackTargetsBonus;
            }
            (bonuses.uniqueOptions || []).forEach((opt) => {
              if (!opt || typeof opt.effect !== "string") return;
              uniqueOptions.push(opt);
            });
          });
          return {
            primary,
            secondary,
            primaryPerLevel,
            primaryFixed,
            attackCountBonus,
            attackTargetsBonus,
            uniqueOptions,
          };
        }

        function calcPrimaryPerLevelBonus(perLevelEffects, level) {
          const bonus = createEmptyPrimaryBonus();
          const effectiveLevel = Math.max(0, Math.floor(level || 0));
          Object.entries(perLevelEffects || {}).forEach(([key, effects]) => {
            if (!Array.isArray(effects)) return;
            effects.forEach((effect) => {
              if (!effect || typeof effect.amount !== "number") return;
              const interval = Math.max(1, Math.floor(effect.interval || 1));
              const stacks = Math.floor(effectiveLevel / interval);
              bonus[key] = (bonus[key] ?? 0) + stacks * effect.amount;
            });
          });
          return bonus;
        }

        function mergeBonuses(baseBonus, extraBonus) {
          const merged = createEmptyBonus();
          Object.keys(merged).forEach((key) => {
            merged[key] = (baseBonus?.[key] ?? 0) + (extraBonus?.[key] ?? 0);
          });
          return merged;
        }

        function calcExpRewardForEnemy({
          floor,
          enemyCount = 1,
          isBoss = false,
        } = {}) {
          const base = 20 + floor * 6 + (floor % 5 === 0 ? 20 : 0);
          const expMultiplier = 5;
          const bossMultiplier = 4.4;
          const boosted = base * expMultiplier;
          const adjusted = isBoss ? boosted * bossMultiplier : boosted;
          return Math.max(1, Math.round(adjusted / Math.max(1, enemyCount)));
        }

        function getGoldMultiplier() {
          const derived = recalcDerivedStats();
          const chance = derived.goldChance?.total ?? 100;
          return Math.max(0, chance) / 100;
        }

        function formatGold(amount) {
          return Math.trunc(amount || 0).toLocaleString("ja-JP");
        }

        function grantGold(baseAmount, { source = "" } = {}) {
          const multiplier = getGoldMultiplier();
          const gained = Math.max(0, Math.round(baseAmount * multiplier));
          if (gained <= 0) return 0;
          player.gold += gained;
          const prefix = source ? `${source}: ` : "";
          log(`💰 ${prefix}${formatGold(gained)}Gを獲得`, "good");
          return gained;
        }

        function grantExp(amount, { source = "" } = {}) {
          const gained = Math.max(0, Math.round(amount || 0));
          if (gained <= 0) return 0;
          player.exp += gained;
          const prefix = source ? `${source}: ` : "";
          log(`🎁 ${prefix}${gained} EXPを獲得`, "good");
          while (player.exp >= player.expToLevel) {
            player.exp -= player.expToLevel;
            levelUp();
          }
          return gained;
        }

        function calculateItemSellValue(item) {
          if (!item) return 0;
          if (item.type === "equipment" && item.equipment) {
            const base = SELL_VALUE_BY_RARITY[item.equipment.rarity] ?? 0;
            const prefixRank = item.equipment.prefix?.rank ?? 0;
            const suffixRank = item.equipment.suffix?.rank ?? 0;
            const starBonus = prefixRank + suffixRank;
            const price = base * (1 + starBonus * 0.2);
            return Math.max(1, Math.round(price));
          }
          if (item.type === "potion") return 1;
          return 0;
        }

        function maybeAutoSellItem(item) {
          if (!item) return false;
          const rarityKey = getItemRarityKey(item);
          if (!isAutoSellEnabledForRarity(rarityKey)) return false;
          const price = calculateItemSellValue(item);
          if (price <= 0) return false;
          grantGold(price, { source: "自動売却" });
          return true;
        }

        function resolveDropSlotForFloor(floor, isBoss) {
          if (isBoss && BOSS_LEGENDARY_DROPS[floor]?.slot)
            return BOSS_LEGENDARY_DROPS[floor].slot;
          const table = FLOOR_DROP_TABLE.find(
            (entry) => floor >= entry.min && floor <= entry.max,
          );
          const slots = table?.slots?.length
            ? table.slots
            : Object.keys(EQUIPMENT_SLOTS);
          if (!slots.length) return "weapon";
          return slots[randomInt(0, slots.length - 1)];
        }

        function rollBaseDropRarity(isBoss) {
          const weights = isBoss
            ? BOSS_DROP_RARITY_WEIGHTS
            : DROP_RARITY_WEIGHTS;
          return weightedRandom(weights, { key: "normal" })?.key || "normal";
        }

        function upgradeRarityWithBonus(baseKey, rarityBonus) {
          const ladder = ["normal", "magic", "rare"];
          let current = baseKey;
          let upgradeChance = Math.min(80, Math.max(0, rarityBonus || 0));
          while (upgradeChance > 0) {
            const index = ladder.indexOf(current);
            if (index < 0 || index >= ladder.length - 1) break;
            if (Math.random() * 100 < upgradeChance) {
              current = ladder[index + 1];
              upgradeChance *= 0.45;
            } else {
              break;
            }
          }
          return current;
        }

        function rollDropItemType(isBoss) {
          const weights = isBoss
            ? BOSS_DROP_ITEM_TYPE_WEIGHTS
            : DROP_ITEM_TYPE_WEIGHTS;
          return weightedRandom(weights, weights[0])?.key || "equipment";
        }

        function pickRandomPotionTemplateKey() {
          const templateKeys = Object.keys(POTION_BASE_TEMPLATES);
          if (!templateKeys.length) return "";
          return templateKeys[randomInt(0, templateKeys.length - 1)];
        }

        function pickRandomPotionVariantKey(templateKey) {
          const variants = POTION_BASE_TEMPLATES[templateKey]?.variants || [];
          if (!variants.length) return "";
          const picked = variants[randomInt(0, variants.length - 1)];
          return picked?.key || variants[0]?.key || "";
        }

        function createRandomPotionDrop({ isBoss } = {}) {
          if (isBoss) {
            const bossPotions = BOSS_LEGENDARY_POTIONS[game.floor];
            if (bossPotions?.length) {
              const legendaryKey =
                bossPotions[randomInt(0, bossPotions.length - 1)];
              const legendaryPotion = createLegendaryPotion(legendaryKey);
              if (legendaryPotion) {
                return createPotionInventoryItem(legendaryPotion, {
                  description: legendaryPotion.effectText,
                });
              }
            }
          }

          const templateKey = pickRandomPotionTemplateKey();
          const variantKey = pickRandomPotionVariantKey(templateKey);
          const potion = createPotionFromTemplate(templateKey, variantKey);
          if (!potion) return null;
          return createPotionInventoryItem(potion, {
            description: potion.effectText,
          });
        }

        function getBossLegendaryBaseChanceForFloor(floor) {
          if (!BOSS_LEGENDARY_BASE_CHANCE_POINTS.length) return 0;
          const points = BOSS_LEGENDARY_BASE_CHANCE_POINTS;
          if (floor <= points[0].floor) return points[0].chance;
          for (let i = 0; i < points.length - 1; i++) {
            const current = points[i];
            const next = points[i + 1];
            if (floor <= next.floor) {
              const rate = (floor - current.floor) / (next.floor - current.floor);
              return current.chance + (next.chance - current.chance) * rate;
            }
          }
          return points[points.length - 1].chance;
        }

        function formatPercent(value, digits = 1) {
          const factor = 10 ** digits;
          const rounded = Math.round(Math.max(0, value) * factor) / factor;
          return `${rounded}%`;
        }

        function getEquipmentDropShare(isBoss) {
          const weights = isBoss
            ? BOSS_DROP_ITEM_TYPE_WEIGHTS
            : DROP_ITEM_TYPE_WEIGHTS;
          const total = weights.reduce((sum, w) => sum + (w.weight || 0), 0);
          const equip = weights.find((w) => w.key === "equipment")?.weight || 0;
          return total > 0 ? equip / total : 0;
        }

        function computeBossLegendaryChance(floor) {
          const baseChance = getBossLegendaryBaseChanceForFloor(floor);
          const derived = recalcDerivedStats();
          const rarityBonus = Math.max(0, derived?.rarity?.total ?? 0);
          const rarityContribution = rarityBonus * 0.6;
          const finalChance = Math.min(60, baseChance + rarityContribution);

          const baseDropChance = Math.min(95, BASE_DROP_CHANCE + BOSS_DROP_BONUS);
          const equipmentShare = getEquipmentDropShare(true);
          const effectivePerRoll = (baseDropChance * equipmentShare * finalChance) / 100;

          return {
            baseChance,
            rarityBonus,
            rarityContribution,
            finalChance,
            baseDropChance,
            equipmentShare,
            effectivePerRoll,
          };
        }

        function formatBossLegendaryChanceDetail(floor) {
          const {
            baseChance,
            rarityBonus,
            rarityContribution,
            finalChance,
            baseDropChance,
            equipmentShare,
            effectivePerRoll,
          } = computeBossLegendaryChance(floor);
          const bonusText =
            rarityBonus > 0
              ? ` + レアリティUP${formatPercent(rarityBonus)}→+${formatPercent(rarityContribution)}`
              : "";
          const breakdown =
            `ドロップ成立${formatPercent(baseDropChance)} → 装備${formatPercent(
              equipmentShare * 100,
            )} → 伝説判定${formatPercent(finalChance)}`;
          return `${formatPercent(
            effectivePerRoll,
          )} / ロール (基礎${formatPercent(baseChance)}${bonusText}; ${breakdown})`;
        }

        function formatBossLegendaryChanceLabel(floor) {
          const { effectivePerRoll, finalChance } = computeBossLegendaryChance(floor);
          return `${formatPercent(effectivePerRoll)} / ロール (伝説判定${formatPercent(finalChance)})`;
        }

        function rollDropRarityForEnemy(enemy, rarityBonus, slot) {
          const legendaryCandidate = enemy.isBoss
            ? BOSS_LEGENDARY_DROPS[game.floor]
            : null;
          if (legendaryCandidate && legendaryCandidate.slot === slot) {
            const baseChance = getBossLegendaryBaseChanceForFloor(game.floor);
            const bonus = Math.max(0, rarityBonus || 0) * 0.6;
            const chance = Math.min(60, baseChance + bonus);
            if (Math.random() * 100 < chance) {
              const pool = legendaryCandidate.legendaryKeys || [];
              const pickedKey =
                pool.length > 0
                  ? pool[randomInt(0, pool.length - 1)]
                  : legendaryCandidate.legendaryKey;
              return {
                rarityKey: "legendary",
                legendaryKey: pickedKey || "",
                legendaryPool: pool,
              };
            }
          }

          const baseKey = rollBaseDropRarity(enemy.isBoss);
          const upgraded = upgradeRarityWithBonus(baseKey, rarityBonus);
          return { rarityKey: upgraded, legendaryKey: "", legendaryPool: [] };
        }

        function recordLegendaryDrop(item, enemy) {
          if (!item?.equipment || item.equipment.rarity !== "legendary") return;
          game.legendaryRecords = game.legendaryRecords || {};
          const legendaryKey =
            item.equipment.legendaryKey || inferLegendaryKeyFromItem(item);
          if (!legendaryKey) return;
          const record = game.legendaryRecords[legendaryKey] || {
            drops: 0,
            baseRanges: {},
            uniqueOptions: [],
          };
          record.drops += 1;

          (item.equipment.baseOptions || []).forEach((opt) => {
            if (!opt || typeof opt.value !== "number") return;
            const current = record.baseRanges[opt.key] || {
              min: opt.value,
              max: opt.value,
            };
            record.baseRanges[opt.key] = {
              min: Math.min(current.min, opt.value),
              max: Math.max(current.max, opt.value),
            };
          });

          if (item.equipment.uniqueOptions?.length) {
            record.uniqueOptions = item.equipment.uniqueOptions.map((opt) => ({
              name: opt.name,
              effect: opt.effect,
            }));
          }

          game.legendaryRecords[legendaryKey] = record;
          if (enemy?.isBoss) {
            maybeAutoSave("ボスレジェンダリー獲得");
          }
        }

        function attemptEnemyDrop(enemy) {
          const derived = recalcDerivedStats();

          // ステータス由来の「ドロップ力」
          // dropPower ＝ 100で「+1ロール」、200で「+2ロール」…というイメージ
          const dropPower = Math.max(0, derived.dropRate?.total ?? 0);

          // 敵側のボーナス（ボス・アーキタイプなど）
          const dropBonus =
            (enemy.isBoss ? BOSS_DROP_BONUS : 0) + (enemy.dropChanceBonus || 0);
          const rarityBonus =
            (derived.rarity?.total ?? 0) + (enemy.rarityBonus || 0);

          const forceLegendaryDrop =
            enemy.isBoss && debugForceBossLegendaryDrop;

          // 1ロールあたりの「当たり判定」の基本確率
          // ステータス由来の dropRate はここには足さず、
          // 「ロール回数」を増やす側に回す。
          const baseDropChance = Math.min(95, BASE_DROP_CHANCE + dropBonus);

          // ---- ロール回数の決定 ----
          // ・まずはベースで 1ロール
          // ・dropPower 100%ごとに +1ロール
          // ・余り分（0〜99）は追加ロールの抽選に使う
          let rolls = 1;

          if (!forceLegendaryDrop) {
            const guaranteedExtra = Math.floor(dropPower / 100);
            const extraChance = dropPower % 100;

            rolls += guaranteedExtra;
            if (Math.random() * 100 < extraChance) {
              rolls += 1;
            }
          } else {
            // デバッグ用ボスレジェ確定時は 1ロール固定
            rolls = 1;
          }

          let droppedCount = 0;

          for (let i = 0; i < rolls; i++) {
            // レジェ確定以外は、ロールごとに判定
            if (!forceLegendaryDrop) {
              const roll = Math.random() * 100;
              if (roll >= baseDropChance) {
                continue;
              }
            }

            const slotKey = resolveDropSlotForFloor(game.floor, enemy.isBoss);
            const rarityRoll = rollDropRarityForEnemy(
              enemy,
              rarityBonus,
              slotKey,
            );
            const dropType = forceLegendaryDrop
              ? "equipment"
              : rollDropItemType(enemy.isBoss);
            let item = null;

            if (dropType === "potion") {
              item = createRandomPotionDrop(enemy);
            } else {
              item = createEquipmentItem({
                floor: game.floor,
                isBoss: enemy.isBoss,
                slotKey,
                rarityKey: forceLegendaryDrop
                  ? "legendary"
                  : rarityRoll.rarityKey,
                legendaryKey: forceLegendaryDrop
                  ? enemy.bossLegendaryKey
                  : rarityRoll.legendaryKey,
                allowedLegendaryKeys: rarityRoll.legendaryPool,
              });
            }

            if (!item) continue;

            droppedCount += 1;
            recordLegendaryDrop(item, enemy);
            registerCodexDiscovery(item);
            if (!maybeAutoSellItem(item)) {
              player.inventory.items.push(item);
            }

            // ------------------------------
            // ログ（HTML対応）＋レア演出
            // ------------------------------
            if (item.type === "potion" && item.potion) {
              const label = item.potion?.short || item.name || "ポーション";
              const rarityKey = item.potion?.rarity || "normal";

              const coloredLabel = `<span class="rarity-${rarityKey}">${label}</span>`;

              log(`🧪 ${enemy.name} が ${coloredLabel} を落とした！`, "good", {
                asHtml: true,
              });

              triggerDropCelebration(item); // レア／レジェなら演出出る
            } else {
              const rarityKey = item.equipment?.rarity || "normal";

              const rarityLabel =
                rarityKey === "legendary"
                  ? "🌈レジェンダリー"
                  : rarityKey === "rare"
                    ? "💎レア"
                    : rarityKey === "magic"
                      ? "✨マジック"
                      : "ノーマル";

              const coloredName = `<span class="rarity-${rarityKey}">${item.name}</span>`;

              log(
                `🎁 ${enemy.name} が ${rarityLabel}装備「${coloredName}」を落とした！`,
                "good",
                { asHtml: true },
              );

              triggerDropCelebration(item); // レア／レジェなら演出出る
            }

            if (droppedCount > 0) {
              renderInventory();
            }
          }
        }

        function recalcDerivedStats() {
          const equipmentBonuses = collectEquipmentBonuses();
          const treeEffects = calculatePassiveTreeEffects();
          player.equipmentBonus = equipmentBonuses.secondary;
          player.equipmentPrimaryBonus = equipmentBonuses.primary;
          player.equipmentPrimaryPerLevel = equipmentBonuses.primaryPerLevel;
          player.equipmentPrimaryFixed = equipmentBonuses.primaryFixed;
          player.passiveTreeBonus = treeEffects.secondary;
          player.passiveTreePrimaryBonus = treeEffects.primary;
          player.passiveTreeAttackCountBonus = treeEffects.attackCountBonus;
          player.passiveTreeAttackTargetsBonus = treeEffects.attackTargetsBonus;
          player.unlockedSkillKeys = Array.from(treeEffects.unlockedSkills);
          player.attackCountBonus =
            (equipmentBonuses.attackCountBonus || 0) +
            treeEffects.attackCountBonus;
          player.attackTargetsBonus =
            (equipmentBonuses.attackTargetsBonus || 0) +
            treeEffects.attackTargetsBonus;
          player.legendaryUniqueOptions = equipmentBonuses.uniqueOptions || [];

          const perLevelPrimaryBonus = calcPrimaryPerLevelBonus(
            equipmentBonuses.primaryPerLevel,
            player.level,
          );
          const combinedPrimaryBonus = { ...equipmentBonuses.primary };
          Object.entries(treeEffects.primary || {}).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            combinedPrimaryBonus[key] =
              (combinedPrimaryBonus[key] ?? 0) + value;
          });

          Object.keys(player.primary).forEach((key) => {
            const baseValue = player.primary[key].base;
            const additive =
              (combinedPrimaryBonus[key] ?? 0) +
              (perLevelPrimaryBonus[key] ?? 0);
            const fixedValue =
              typeof equipmentBonuses.primaryFixed?.[key] === "number"
                ? equipmentBonuses.primaryFixed[key]
                : null;
            const total =
              fixedValue !== null ? fixedValue : baseValue + additive;
            player.primary[key].bonus = total - baseValue;
          });
          player.primaryPerLevelBonus = perLevelPrimaryBonus;
          player.primaryFixedBonus = equipmentBonuses.primaryFixed;
          const skillBonus = player.skillBonus || createEmptyBonus();
          player.baseBonus = mergeBonuses(skillBonus, treeEffects.secondary);
          const levelAttackBonus =
            player.level >= 28
              ? 1.8
              : player.level >= 18
                ? 1.2
                : player.level >= 10
                  ? 0.7
                  : player.level >= 5
                    ? 0.3
                    : 0;
          const levelTargetBonus =
            player.level >= 25 ? 0.8 : player.level >= 12 ? 0.4 : 0;
          player.attackCount = Math.max(
            1,
            Math.round(1 + player.attackCountBonus + levelAttackBonus),
          );
          player.attackTargets = Math.max(
            1,
            Math.round(1 + player.attackTargetsBonus + levelTargetBonus),
          );
          if (!game.awaitingInput) {
            player.attacksRemaining = Math.max(
              0,
              Math.floor(player.attackCount),
            );
          }
          player.bonus = mergeBonuses(player.baseBonus, player.equipmentBonus);
          const derived = calcSecondaryStats();
          const prevMaxHp = player.maxHp || derived.maxHp.total;
          const prevMaxMp = player.maxMp || derived.maxMp.total;

          if (player.maxHp === 0) {
            player.hp = derived.maxHp.total;
          } else {
            const hpDelta = derived.maxHp.total - prevMaxHp;
            if (hpDelta > 0) player.hp += hpDelta;
            if (player.hp > derived.maxHp.total)
              player.hp = derived.maxHp.total;
          }

          if (player.maxMp === 0) {
            player.mp = derived.maxMp.total;
          } else {
            const mpDelta = derived.maxMp.total - prevMaxMp;
            if (mpDelta > 0) player.mp += mpDelta;
            if (player.mp > derived.maxMp.total)
              player.mp = derived.maxMp.total;
          }

          player.maxHp = Math.round(derived.maxHp.total);
          player.maxMp = Math.round(derived.maxMp.total);
          player.atk = Math.round(derived.physAtk.total);
          player.def = Math.round(derived.physDef.total);
          player.spd = Math.round(derived.speed.total);
          player.accuracy = Math.round(derived.accuracy.total);
          player.evade = Math.round(derived.evade.total);
          player.damageReduction = Math.max(0, derived.damageReduction.total);
          player.block = Math.max(0, derived.block.total);
          player.hpRegen = Math.max(0, derived.hpRegen.total);
          player.resist.control = derived.controlResist.total;
          player.resist.dot = derived.dotResist.total;
          player.resist.debuff = derived.debuffResist.total;
          player.lifeSteal = Math.max(0, derived.lifeSteal.total);

          player.barrierMax = Math.max(0, derived.barrier.total);
          if (
            player.barrierRemaining === undefined ||
            player.barrierRemaining === null
          ) {
            player.barrierRemaining = player.barrierMax;
          } else {
            player.barrierRemaining = Math.max(0, player.barrierRemaining);
          }

          return derived;
        }

        function canEquipInSlot(itemSlot, targetSlot) {
          if (!itemSlot) return true;
          if (itemSlot === targetSlot) return true;
          if (
            itemSlot === "accessory" &&
            (targetSlot === "accessory1" || targetSlot === "accessory2")
          )
            return true;
          return false;
        }

        function unequipItemById(item) {
          if (!item?.id || !player.equipment) return false;
          let removed = false;
          Object.keys(player.equipment).forEach((slot) => {
            if (player.equipment[slot]?.id === item.id) {
              player.equipment[slot] = null;
              removed = true;
            }
          });
          return removed;
        }

        function equipItem(slot, item) {
          if (!player.equipment || !(slot in player.equipment)) return;
          if (item?.enhanceBroken) {
            log(`⚠️ ${item.name} は破損しているため装備できません`, "warning");
            return;
          }
          if (!canEquipInSlot(item?.equipment?.slot, slot)) return;
          player.equipment[slot] = item ?? null;
          const derived = recalcDerivedStats();
          updateUI(derived);
          if (item?.equipment?.uniqueOptions?.length) {
            const summary = item.equipment.uniqueOptions
              .filter((opt) => opt?.name && opt?.effect)
              .map((opt) => `${opt.name}: ${opt.effect}`)
              .join(" / ");
            if (summary) {
              log(`✨ 固有オプション適用: ${summary}`, "info");
            }
          }
          maybeAutoSave("装備変更");
        }

        function unequipItem(slot) {
          if (!player.equipment || !(slot in player.equipment)) return;
          player.equipment[slot] = null;
          const derived = recalcDerivedStats();
          updateUI(derived);
          maybeAutoSave("装備変更");
        }

        function isBossFloor(floor) {
          return BOSS_FLOORS.includes(floor);
        }

        function pickEnemyBaseName(floor) {
          const pool =
            ENEMY_NAME_POOLS.find((p) => floor >= p.min && floor <= p.max) ||
            ENEMY_NAME_POOLS[0];
          return pool.names[randomInt(0, pool.names.length - 1)];
        }

        let lastArchetypeKeys = [];

        function pickEnemyVariant(floor, { avoidKeys = [] } = {}) {
          const avoidList = Array.isArray(avoidKeys)
            ? avoidKeys
            : [avoidKeys].filter(Boolean);
          const avoidSet = new Set(avoidList.filter(Boolean));
          const basePool = ENEMY_VARIANTS.filter(
            (variant) => !variant.minFloor || floor >= variant.minFloor,
          );
          if (!basePool.length) return null;
          const pool =
            basePool.filter((variant) => !avoidSet.has(variant.key)) || basePool;
          const candidatePool = pool.length ? pool : basePool;
          const primary = weightedRandom(candidatePool, candidatePool[0]);
          return primary;
        }

        function rollArchetypes(floor, derived) {
          const baseChance = 24 + Math.min(18, Math.floor(floor / 120) * 3);
          const namedBonus = Math.max(0, derived?.namedRate?.total ?? 0);
          const effective = Math.min(90, baseChance + namedBonus);
          const avoidKeys = new Set(lastArchetypeKeys || []);
          if (Math.random() * 100 >= effective) return null;

          const rolls = [];
          const firstVariant = pickEnemyVariant(floor, {
            avoidKeys: Array.from(avoidKeys),
          });
          if (!firstVariant) return null;
          const firstRank =
            weightedRandom(ARCHETYPE_RANK_WEIGHTS, ARCHETYPE_RANK_WEIGHTS[0])
              ?.rank || 1;
          rolls.push({ variant: firstVariant, rank: firstRank });
          avoidKeys.add(firstVariant.key);

          const extraChances = [
            Math.min(78, 12 + namedBonus * 0.55),
            Math.min(64, 6 + namedBonus * 0.42),
          ];

          extraChances.forEach((chance) => {
            if (rolls.length >= 3) return;
            if (Math.random() * 100 >= chance) return;
            const variant = pickEnemyVariant(floor, {
              avoidKeys: Array.from(avoidKeys),
            });
            if (!variant) return;
            const rank =
              weightedRandom(ARCHETYPE_RANK_WEIGHTS, ARCHETYPE_RANK_WEIGHTS[0])
                ?.rank || 1;
            rolls.push({ variant, rank });
            avoidKeys.add(variant.key);
          });

          lastArchetypeKeys = rolls.map((roll) => roll.variant.key);
          return rolls;
        }

        function applyArchetypes(enemy, rolls) {
          if (!rolls?.length) return;
          const archetypes = [];
          const tagLabels = [];
          const traitLabels = [];
          let maxRank = 1;

          rolls.forEach((roll) => {
            const { variant, rank } = roll || {};
            if (!variant) return;
            const effectiveRank = Math.max(1, rank || 1);
            maxRank = Math.max(maxRank, effectiveRank);
            const rankLabel =
              variant.rankLabels?.[effectiveRank - 1] || variant.label;
            const tagLabel = (
              variant.tagLabels?.[effectiveRank - 1] ||
              variant.label ||
              ""
            ).slice(0, 2);

            applyEnemyModifiers(enemy, variant.baseModifiers);
            const appliedAbilities = [];
            (variant.abilities || [])
              .filter(Boolean)
              .slice(0, effectiveRank)
              .forEach((ability) => {
                applyEnemyModifiers(enemy, ability.modifiers);
                if (ability.hiddenModifiers) {
                  applyEnemyModifiers(enemy, ability.hiddenModifiers);
                }
                appliedAbilities.push({
                  label: ability.label,
                  modifiers: ability.modifiers,
                  hiddenModifiers: ability.hiddenModifiers,
                });
                if (ability.label) traitLabels.push(ability.label);
              });

            archetypes.push({
              key: variant.key,
              rank: effectiveRank,
              tagLabel,
              name: rankLabel,
              flavor: variant.description,
              baseModifiers: variant.baseModifiers,
              abilities: appliedAbilities,
            });
            tagLabels.push(tagLabel);
            enemy.rarityBonus = (enemy.rarityBonus || 0) + effectiveRank * 3;
            enemy.dropChanceBonus =
              (enemy.dropChanceBonus || 0) + effectiveRank * 4;
          });

          enemy.archetypes = archetypes;
          enemy.archetypeLabel = tagLabels.join(" / ");
          enemy.archetypeName = archetypes.map((a) => a.name).join(" / ");
          enemy.archetypeFlavor = archetypes
            .map((a) => a.flavor)
            .filter(Boolean)
            .join("｜");
          enemy.archetypeRank = maxRank;
          enemy.variant = archetypes[0]?.key || null;
          enemy.variantKeys = archetypes.map((a) => a.key);
          enemy.archetypeTraits = traitLabels;
          enemy.archetypeBaseModifiers = archetypes.map(
            (a) => a.baseModifiers || {},
          );
          enemy.archetypeAbilities = archetypes.flatMap(
            (a) => a.abilities || [],
          );
        }

        function tryApplyArchetypeStatusOnHit(enemy, target) {
          if (!enemy || !target || enemy.isBoss) return;
          const archetypes = enemy.archetypes || [];
          archetypes.forEach((entry) => {
            const config = ARCHETYPE_STATUS_ON_HIT[entry.key];
            if (!config) return;
            const rank = entry.rank || 1;
            if (rank < (config.minRank || 1)) return;
            const chance = Math.min(
              100,
              config.baseChance +
                (config.rankBonus || 0) * Math.max(0, rank - config.minRank),
            );
            const duration =
              typeof config.duration === "function"
                ? config.duration(rank)
                : (config.duration ?? 2);
            const applied = applyStatus(target, config.status, {
              duration,
              chance,
              potency: config.potency,
            });
            if (applied) {
              const statusName =
                STATUS_DEFINITIONS[config.status]?.name || config.status;
              const label =
                config.label || entry.name || enemy.name || "攻撃";
              log(
                `⚠️ ${enemy.name}の${label}で${statusName}を受けた！`,
                "warning",
              );
            }
          });
        }

        function applyEnemyModifiers(enemy, modifiers = {}) {
          const applyRate = (key, rate, { keepDecimal = false } = {}) => {
            if (!rate) return;
            const baseValue = typeof enemy[key] === "number" ? enemy[key] : 0;
            const value = baseValue * rate;
            enemy[key] = keepDecimal
              ? Math.round(value * 10) / 10
              : Math.round(value);
          };

          const applyFlat = (key, delta, { clampMin = null } = {}) => {
            if (!delta) return;
            const next = (enemy[key] ?? 0) + delta;
            enemy[key] = clampMin !== null ? Math.max(clampMin, next) : next;
          };

          applyRate("hp", modifiers.hp);
          applyRate("maxHp", modifiers.hp);
          applyRate("atk", modifiers.atk);
          applyRate("magAtk", modifiers.magAtk);
          applyRate("def", modifiers.def);
          applyRate("magDef", modifiers.magDef);
          applyRate("spd", modifiers.spd, { keepDecimal: true });
          applyRate("accuracy", modifiers.accuracy);
          applyRate("evade", modifiers.evade);
          applyRate("critRate", modifiers.critRate, { keepDecimal: true });
          applyRate("critDamage", modifiers.critDamage, { keepDecimal: true });
          applyRate("damageReduction", modifiers.damageReduction, {
            keepDecimal: true,
          });
          applyRate("hpRegen", modifiers.hpRegen, { keepDecimal: true });
          applyRate("lifeSteal", modifiers.lifeSteal, { keepDecimal: true });
          applyRate("magPen", modifiers.magPen, { keepDecimal: true });
          applyRate("physPen", modifiers.physPen, { keepDecimal: true });

          if (modifiers.resist) {
            enemy.resist.control = Math.min(
              100,
              Math.round(
                enemy.resist.control * (modifiers.resist.control || 1),
              ),
            );
            enemy.resist.dot = Math.min(
              100,
              Math.round(enemy.resist.dot * (modifiers.resist.dot || 1)),
            );
            enemy.resist.debuff = Math.min(
              100,
              Math.round(enemy.resist.debuff * (modifiers.resist.debuff || 1)),
            );
          }

          if (modifiers.attackCount) {
            enemy.attackCount = Math.max(1, Math.round(modifiers.attackCount));
          }
          if (modifiers.attackCountBonus) {
            enemy.attackCount = Math.max(
              1,
              Math.round(enemy.attackCount + modifiers.attackCountBonus),
            );
          }

          applyFlat("dropChanceBonus", modifiers.dropChanceBonus, {
            clampMin: 0,
          });
          applyFlat("rarityBonus", modifiers.rarityBonus, { clampMin: 0 });
        }

        function describeModifiers(modifiers = {}) {
          if (!modifiers) return "";
          const parts = [];
          const formatRate = (rate) => {
            const delta = Math.round((rate - 1) * 1000) / 10;
            if (delta === 0) return null;
            const sign = delta > 0 ? "+" : "";
            return `${sign}${delta}%`;
          };

          const addRate = (key, label) => {
            if (typeof modifiers[key] === "number") {
              const formatted = formatRate(modifiers[key]);
              if (formatted) parts.push(`${label}${formatted}`);
            }
          };

          addRate("hp", "HP/最大HP");
          addRate("atk", "攻撃力");
          addRate("def", "防御力");
          addRate("spd", "速度");
          addRate("accuracy", "命中");
          addRate("evade", "回避");

          if (modifiers.resist) {
            const resist = modifiers.resist;
            if (typeof resist.control === "number") {
              const formatted = formatRate(resist.control);
              if (formatted) parts.push(`行動阻害耐性${formatted}`);
            }
            if (typeof resist.dot === "number") {
              const formatted = formatRate(resist.dot);
              if (formatted) parts.push(`持続ダメ耐性${formatted}`);
            }
            if (typeof resist.debuff === "number") {
              const formatted = formatRate(resist.debuff);
              if (formatted) parts.push(`弱体耐性${formatted}`);
            }
          }

          if (modifiers.attackCount) {
            parts.push(
              `攻撃回数を${Math.max(1, Math.round(modifiers.attackCount))}回に固定`,
            );
          }
          if (modifiers.attackCountBonus) {
            parts.push(`攻撃回数+${Math.round(modifiers.attackCountBonus)}回`);
          }
          if (modifiers.dropChanceBonus) {
            parts.push(
              `ドロップ率ボーナス+${Math.round(modifiers.dropChanceBonus)}%`,
            );
          }
          if (modifiers.rarityBonus) {
            parts.push(
              `レアリティボーナス+${Math.round(modifiers.rarityBonus)}%`,
            );
          }

          return parts.join("、");
        }

        function keepDecimal(value, digits = 1) {
          const n = Number(value);
          if (!Number.isFinite(n)) return 0;
          const p = 10 ** digits;
          return Math.round(n * p) / p;
        }

        function describeArchetypeStatus(config, rank = 1) {
          if (!config) return "";
          const minRank = config.minRank || 1;
          if (rank < minRank) return "";
          const chance = Math.min(
            100,
            config.baseChance +
              (config.rankBonus || 0) * Math.max(0, rank - minRank),
          );
          const duration =
            typeof config.duration === "function"
              ? config.duration(rank)
              : (config.duration ?? 2);
          const statusName =
            STATUS_DEFINITIONS[config.status]?.name || config.status;
          const parts = [`${statusName}(${chance}% / ${duration}T)`];
          if (config.potency) {
            parts.push(`強度${Math.round((config.potency || 0) * 100)}%`);
          }
          return parts.join(" / ");
        }

        
        function createEnemy(isBoss = false, derivedStats = null) {
          const derived = derivedStats || recalcDerivedStats();
          const floorLevel = Math.max(1, game.floor);
          const baseGrowth = Math.pow(BASE_GROWTH_RATE, floorLevel - 1);
          const bossBoost = isBoss ? BOSS_GROWTH_MULTIPLIER : 1;
          const secondaryBoost = isBoss ? BOSS_SECONDARY_MULTIPLIER : 1;
          const baseName = isBoss
            ? `階層ボス ${game.floor}F`
            : pickEnemyBaseName(game.floor);
          const monsterProfile = !isBoss
            ? ENEMY_MONSTER_DEFINITIONS[baseName]
            : null;
          const archetypeRolls = !isBoss
            ? rollArchetypes(game.floor, derived)
            : null;
          const hpBase = 12;
          const atkBase = 7.5;
          const defBase = 3.2;
          const spdBase = 3.9;
          const statScale = baseGrowth * bossBoost;
          const enemy = {
            id: generateId("enemy"),
            name: baseName,
            hp: Math.round(hpBase * statScale),
            maxHp: Math.round(hpBase * statScale),
            atk: keepDecimal(atkBase * statScale, 1),
            def: keepDecimal(defBase * statScale, 2),
            spd:
              keepDecimal(spdBase * statScale, 2) +
              Math.random() * 1.2 +
              (isBoss ? 1.2 : 0),
            accuracy: Math.min(
              120,
              (80 + baseGrowth * 6) * secondaryBoost,
            ),
            evade: Math.min(35, (6 + baseGrowth * 2.2) * secondaryBoost),
            attackCount: 1,
            attacksRemaining: 1,
            resist: {
              control: Math.min(60, (10 + baseGrowth * 0.9) * secondaryBoost),
              dot: Math.min(60, (8 + baseGrowth * 0.8) * secondaryBoost),
              debuff: Math.min(60, (8 + baseGrowth * 0.7) * secondaryBoost),
            },
            isBoss,
            dropChanceBonus: 0,
            rarityBonus: 0,
            statuses: [],
          };

          if (!isBoss) {
            const baseFlavor =
              monsterProfile?.flavor || `${baseName}がうろついている。`;
            enemy.baseFlavor = baseFlavor;
            enemy.flavor = baseFlavor;
            if (monsterProfile?.modifiers) {
              applyEnemyModifiers(enemy, monsterProfile.modifiers);
            }
          }

          if (archetypeRolls?.length && !isBoss) {
            applyArchetypes(enemy, archetypeRolls);
          }

          if (isBoss) {
            const bossDef = BOSS_DEFINITIONS[game.floor];
            if (bossDef) {
              enemy.name = bossDef.name;
              enemy.baseFlavor = bossDef.flavor;
              enemy.flavor = enemy.baseFlavor;
              const dropInfo = BOSS_LEGENDARY_DROPS[game.floor];
              const pool = dropInfo?.legendaryKeys?.length
                ? dropInfo.legendaryKeys
                : bossDef.legendaryKey
                  ? [bossDef.legendaryKey]
                  : [];
              enemy.bossLegendaryKey =
                pool.length > 0
                  ? pool[randomInt(0, pool.length - 1)]
                  : bossDef.legendaryKey;
              enemy.bossLegendaryPool = pool;
              enemy.bossSkillKey = game.floor;
              enemy.bossSkillDef = BOSS_SKILLS[game.floor];
              enemy.bossSkillCooldown = 0;
              const { modifiers = {} } = bossDef;
              applyEnemyModifiers(enemy, modifiers);
            }
          }

          const hasAttackModifier = (modifiers = {}) => {
            return (
              typeof modifiers.attackCount === "number" ||
              typeof modifiers.attackCountBonus === "number"
            );
          };

          const hasArchetypeMultiAttack =
            !isBoss &&
            (enemy.archetypes || []).some(
              (entry) =>
                hasAttackModifier(entry.baseModifiers) ||
                (entry.abilities || []).some(
                  (ability) =>
                    hasAttackModifier(ability.modifiers) ||
                    hasAttackModifier(ability.hiddenModifiers),
                ),
            );

          if (!isBoss && !hasArchetypeMultiAttack) {
            enemy.attackCount = 1;
            enemy.attacksRemaining = 1;
          }

          ensureCodexState();
          if (enemy.name && !isBoss)
            markCodexEntry("enemyMonsters", enemy.name);
          if (enemy.variantKeys?.length) {
            enemy.variantKeys.forEach((key) =>
              markCodexEntry("enemyVariants", key),
            );
          } else if (enemy.variant) {
            markCodexEntry("enemyVariants", enemy.variant);
          }
          if (isBoss) markCodexEntry("bosses", String(game.floor));

          enemy.attacksRemaining = enemy.attackCount;

          return enemy;
        }

        function ensureBarrierBaseline(derived) {
          const baseline = Math.max(
            0,
            roundBattleValue(derived?.barrier?.total ?? player.barrierMax ?? 0),
          );
          const current = Math.max(0, roundBattleValue(player.barrierRemaining ?? 0));
          if (current < baseline) {
            player.barrierRemaining = baseline;
          }
        }

        function recordFloorProgress() {
          if (!Number.isFinite(game.floor)) return;
          const currentFloor = Math.max(1, Math.floor(game.floor));
          game.highestFloor = Math.max(game.highestFloor || 1, currentFloor);
          if (!game.reachedBossFloors) game.reachedBossFloors = {};
          if (isBossFloor(currentFloor)) {
            game.reachedBossFloors[currentFloor] = true;
          }
        }

        function spawnEnemies() {
          const boss = isBossFloor(game.floor);
          const count = boss ? 1 : 2 + Math.floor(Math.random() * 2);
          const derived = recalcDerivedStats();
          recordFloorProgress();
          ensureBarrierBaseline(derived);
          initializeLegendaryBattleState();
          applyLegendaryBattleStartEffects();
          const expReward = calcExpRewardForEnemy({
            floor: game.floor,
            enemyCount: count,
            isBoss: boss,
          });
          game.enemies = Array.from({ length: count }, () => {
            const enemy = createEnemy(boss, derived);
            enemy.expReward = expReward;
            return enemy;
          });
          log(`${game.floor}F 侵入。${count}体の敵が現れた！`);
          buildTurnQueue();
          game.awaitingInput = false;
          updateUI(derived);
          nextTurn();
        }

        function tryBossSkill(enemy) {
          if (!enemy?.isBoss) return false;
          const skill =
            enemy.bossSkillDef ||
            (enemy.bossSkillKey ? BOSS_SKILLS[enemy.bossSkillKey] : null);
          if (!skill) return false;
          enemy.bossSkillDef = skill;
          enemy.bossSkillCooldown = Math.max(0, enemy.bossSkillCooldown || 0);
          if (enemy.bossSkillCooldown > 0) return false;
          const result = skill.action ? skill.action(enemy) || {} : {};
          const effectText = result.message ? ` ${result.message}` : "";
          log(
            `💢 ${enemy.name} は「${skill.name}」を発動！${effectText}`,
            "enemy",
          );
          const enemyCard = getEnemyCardContainer(enemy);
          showSkillPopup(enemyCard, skill.name, "enemy");
          if (result.extraAttacks && result.extraAttacks > 0) {
            const baseAttacks = Math.max(
              0,
              Math.floor(enemy.attacksRemaining ?? enemy.attackCount ?? 1),
            );
            enemy.attacksRemaining = baseAttacks + result.extraAttacks;
          }
          enemy.bossSkillCooldown = skill.cooldown ?? 2;
          return true;
        }

        function getEffectiveSpeed(entity, type) {
          let speed = entity.spd || 0;
          if (
            type === "player" &&
            player.buffs.haste > 0 &&
            !hasStatus(entity, "seal")
          ) {
            speed += 2;
          }
          const speedDown = getStatus(entity, "speedDown");
          if (speedDown) {
            speed *=
              1 -
              (speedDown.potency ??
                STATUS_DEFINITIONS.speedDown.potency ??
                0.25);
          }
          if (hasStatus(entity, "knockdown")) {
            speed = Math.max(0.2, speed * 0.1);
          }
          return speed + Math.random() * 2;
        }

        function decayStatuses(entity) {
          entity.statuses = (entity.statuses || [])
            .map((s) => ({ ...s, remaining: s.remaining - 1 }))
            .filter((s) => s.remaining > 0);
        }

        function tickBuffs(entity) {
          if (!entity.buffs) return;
          Object.keys(entity.buffs).forEach((key) => {
            if (entity.buffs[key] > 0) entity.buffs[key] -= 1;
          });
        }

        function tickSkillCooldowns() {
          player.activeSkillSlots = player.activeSkillSlots || [];
          player.activeSkillSlots.forEach((slot) => {
            if (slot.cooldownRemaining > 0) {
              slot.cooldownRemaining = Math.max(0, slot.cooldownRemaining - 1);
            }
          });
        }

        function isSameTurnEntry(a, b) {
          if (!a || !b) return false;
          if (a.type !== b.type) return false;
          if (a.type === "player") return true;
          return (a.id ?? null) === (b.id ?? null);
        }

        function setCurrentActorEntry(actor) {
          currentActorEntry = actor
            ? { type: actor.type, id: actor.id ?? null }
            : null;
        }

        function getTurnBadgeLabel(entry) {
          if (!entry) return "?";
          if (entry.type === "player") return "P";
          const index = game.enemies.findIndex(
            (enemy) => enemy.id === entry.id,
          );
          return index >= 0 ? String(index + 1) : "?";
        }

        function normalizeTurnOrderPreview() {
          const aliveEnemyIds = new Set(
            game.enemies.filter((e) => e.hp > 0).map((e) => e.id),
          );
          turnOrderPreview = (turnOrderPreview || []).filter((entry) => {
            if (entry.type === "player") return player.hp > 0;
            return aliveEnemyIds.has(entry.id);
          });
        }

        function applyTurnOrderFromQueue(queue = game.turnQueue) {
          const source = Array.isArray(queue) ? queue : [];
          turnOrderPreview = source.map((entry) => ({
            type: entry.type,
            id: entry.id ?? null,
          }));
          lastActedEntry = null;
          activeTurnActor = null;
          setCurrentActorEntry(null);
          normalizeTurnOrderPreview();
          renderTurnOrder();
        }

        function clearTurnOrderPreview() {
          applyTurnOrderFromQueue([]);
        }

        function renderTurnOrder() {
          const list = document.getElementById("turn-order-list");
          if (!list) return;
          const isInitialRender = list.dataset.initialized !== "true";
          normalizeTurnOrderPreview();
          list.innerHTML = "";

          const signature = turnOrderPreview
            .map((entry) => `${entry.type}-${entry.id ?? "player"}`)
            .join(",");
          const changed = signature !== lastTurnOrderSignature;
          lastTurnOrderSignature = signature;

          if (!turnOrderPreview.length) {
            const empty = document.createElement("div");
            empty.className = "turn-order-empty";
            empty.textContent = "行動順を計算中…";
            list.appendChild(empty);
            return;
          }

          if (changed && !isInitialRender) {
            list.classList.remove("turn-order-refresh");
            void list.offsetWidth;
            list.classList.add("turn-order-refresh");
          }

          turnOrderPreview.forEach((entry, index) => {
            const badge = document.createElement("div");
            badge.className = `turn-badge ${entry.type === "player" ? "player" : "enemy"}`;
            if (!isInitialRender) {
              badge.classList.add("steady");
            }
            const label = getTurnBadgeLabel(entry);
            badge.textContent = label;
            badge.title =
              entry.type === "player" ? "プレイヤー" : `敵 ${label}`;
            badge.setAttribute("aria-label", badge.title);
            if (isInitialRender) {
              badge.style.animationDelay = `${index * 30}ms`;
            }
            if (index === 0) badge.classList.add("next");
            if (
              currentActorEntry &&
              isSameTurnEntry(entry, currentActorEntry) &&
              index === 0
            ) {
              badge.classList.add("acting");
            }
            if (
              lastActedEntry &&
              isSameTurnEntry(entry, lastActedEntry) &&
              index === turnOrderPreview.length - 1
            ) {
              badge.classList.add("acted");
            }
            list.appendChild(badge);
          });

          list.dataset.initialized = "true";
        }

        function advanceTurnOrderPreview(actor) {
          normalizeTurnOrderPreview();
          if (!actor) {
            lastActedEntry = null;
            renderTurnOrder();
            return;
          }
          const isActorAlive =
            actor.type === "player"
              ? player.hp > 0
              : game.enemies.some((e) => e.id === actor.id && e.hp > 0);
          const matchIndex = turnOrderPreview.findIndex((entry) =>
            isSameTurnEntry(entry, actor),
          );
          let moving =
            actor.type === "player"
              ? { type: "player", id: null }
              : { type: "enemy", id: actor.id };
          if (matchIndex >= 0) {
            [moving] = turnOrderPreview.splice(matchIndex, 1);
          }
          if (isActorAlive) {
            turnOrderPreview.push(moving);
            lastActedEntry = moving;
          } else {
            lastActedEntry = null;
          }
          setCurrentActorEntry(null);
          activeTurnActor = null;
          renderTurnOrder();
        }

        function buildTurnQueue() {
          const queue = [];
          if (player.hp > 0) {
            queue.push({
              type: "player",
              speed: getEffectiveSpeed(player, "player"),
            });
          }
          game.enemies
            .filter((e) => e.hp > 0)
            .forEach((e) => {
              queue.push({
                type: "enemy",
                id: e.id,
                speed: getEffectiveSpeed(e, "enemy"),
              });
            });
          queue.sort((a, b) => b.speed - a.speed);
          game.turnQueue = queue;
          applyTurnOrderFromQueue(queue);
        }

        function applyStatus(
          target,
          key,
          {
            duration = 2,
            chance = 100,
            potency,
            payload,
            ignoreResist = false,
          } = {},
        ) {
          const def = STATUS_DEFINITIONS[key];
          if (!def) return false;
          const resist = ignoreResist ? 0 : getResist(target, def.category);
          const effectiveChance = Math.max(0, Math.min(100, chance - resist));
          if (effectiveChance <= 0) return false;
          const roll = Math.random() * 100;
          if (roll > effectiveChance) return false;
          const existing = getStatus(target, key);
          if (existing) {
            existing.remaining = Math.max(existing.remaining, duration);
            if (potency !== undefined) existing.potency = potency;
            if (payload !== undefined) existing.payload = payload;
          } else {
            target.statuses = target.statuses || [];
            target.statuses.push({
              key,
              remaining: duration,
              potency: potency ?? def.potency ?? 0,
              payload,
            });
          }
          if (key === "seal" && target.buffs) {
            Object.keys(target.buffs).forEach(
              (buff) => (target.buffs[buff] = 0),
            );
          }
          return true;
        }

        function roundBattleValue(value) {
          return Math.round(value ?? 0);
        }

        function getLegendaryOptionsByTrigger(trigger) {
          return (player.legendaryUniqueOptions || []).filter((opt) => {
            if (!opt?.trigger) return false;
            if (Array.isArray(opt.trigger)) return opt.trigger.includes(trigger);
            return opt.trigger === trigger;
          });
        }

        function applyLegendaryBuff(target, key, duration) {
          if (!target?.buffs || !key) return;
          const next = Math.max(0, Math.floor(duration || 0));
          if (next <= 0) return;
          target.buffs[key] = Math.max(target.buffs[key] || 0, next);
        }

        function addLegendaryBarrier(percent, { capWithBarrierMax = false } = {}) {
          if (!player.maxHp || percent <= 0) return;
          const barrierGain = Math.max(1, Math.round(player.maxHp * (percent / 100)));
          const current = Math.max(0, player.barrierRemaining || 0);
          let next = current + barrierGain;
          if (capWithBarrierMax) {
            const baseBarrier = Math.max(0, roundBattleValue(player.barrierMax ?? 0));
            next = Math.min(next, baseBarrier + barrierGain);
          }
          const added = Math.max(0, next - current);
          player.barrierRemaining = next;
          if (added > 0) {
            log(`🛡️ バリア+${added}`, "good");
          }
        }

        function reduceSkillCooldowns(amount = 1) {
          const delta = Math.max(0, Math.floor(amount));
          if (!delta) return;
          player.activeSkillSlots = player.activeSkillSlots || [];
          player.activeSkillSlots.forEach((slot) => {
            slot.cooldownRemaining = Math.max(0, (slot.cooldownRemaining || 0) - delta);
          });
        }

        function restorePlayerMp(percent) {
          if (!player.maxMp || percent <= 0) return;
          const gain = Math.max(1, Math.round(player.maxMp * (percent / 100)));
          player.mp = Math.min(player.maxMp, player.mp + gain);
          log(`🔷 MPを${gain}回復`, "good");
        }

        function healPlayerByPercent(percent) {
          if (!player.maxHp || percent <= 0) return;
          const healAmount = Math.max(1, Math.round(player.maxHp * (percent / 100)));
          const healed = applyHealing(player, healAmount);
          if (healed > 0) {
            log(`✨ HPを${healed}回復`, "good");
          }
        }

        function hasLegendaryCondition(condition, target, value) {
          if (!condition) return false;
          switch (condition.type) {
            case "openingTurn":
              return !!player.legendaryState?.openingStrikeActive;
            case "targetDebuffed":
              return (target?.statuses || []).some((status) => {
                const category = STATUS_DEFINITIONS[status.key]?.category;
                return (
                  category === STATUS_CATEGORIES.debuff ||
                  category === STATUS_CATEGORIES.dot ||
                  category === STATUS_CATEGORIES.control
                );
              });
            case "targetStatus":
              return condition.key ? hasStatus(target, condition.key) : false;
            case "hpAbove":
              return player.maxHp > 0 && player.hp / player.maxHp >= (condition.threshold ?? 0);
            case "hpBelow":
              return player.maxHp > 0 && player.hp / player.maxHp < (condition.threshold ?? 0);
            case "hasBuff":
              return player.buffs?.[condition.key] > 0;
            default:
              return false;
          }
        }

        function executeLegendaryPayload(option, context = {}) {
          if (!option?.payload || hasStatus(player, "seal")) return 0;
          let payload = option.payload;
          if (payload?.type === "multiTrigger") {
            payload = payload.byTrigger?.[context.trigger] || null;
            if (!payload) return 0;
          }
          const target = context.target || player;
          const chance = payload.chanceFromValue ? option.value : payload.chance ?? 100;
          const roll = () => Math.random() * 100 < chance;
          let extraAttacks = 0;

          const applyStatusPayload = (entry) => {
            const statusChance = entry.chanceFromValue ? option.value : entry.chance ?? chance;
            applyStatus(target, entry.key, {
              duration: entry.duration ?? 2,
              chance: statusChance,
              potency: entry.potency,
            });
          };

          switch (payload.type) {
            case "status":
              applyStatusPayload(payload);
              break;
            case "statusMulti":
              (payload.list || []).forEach((entry) => applyStatusPayload(entry));
              break;
            case "buff":
              if (roll()) applyLegendaryBuff(player, payload.key, payload.duration ?? 2);
              break;
            case "barrier":
              addLegendaryBarrier(
                payload.percentFromValue ? option.value : payload.percent || 0,
                payload,
              );
              break;
            case "cleanse": {
              if (!roll()) break;
              if (!(player.statuses || []).length) break;
              const statuses = (player.statuses || []).filter(
                (status) => STATUS_DEFINITIONS[status.key],
              );
              if (!statuses.length) break;
              const picked = statuses[Math.floor(Math.random() * statuses.length)];
              removeStatus(player, picked.key);
              if (payload.healPercent) healPlayerByPercent(payload.healPercent);
              const statusName = STATUS_DEFINITIONS[picked.key]?.name || picked.key;
              log(`🌊 ${option.name}で${statusName}を解除`, "good");
              break;
            }
            case "cooldown":
              if (roll()) reduceSkillCooldowns(payload.amount ?? 1);
              break;
            case "mp":
              if (roll()) restorePlayerMp(payload.percentFromValue ? option.value : payload.percent || 0);
              break;
            case "extraAttack":
              if (roll()) {
                extraAttacks += payload.amount ?? 1;
                log("⚡ 追加攻撃を得た！", "good");
              }
              break;
            case "guaranteedHit":
              if (roll()) {
                player.legendaryState = player.legendaryState || {};
                player.legendaryState.nextGuaranteedHit = true;
              }
              break;
            case "heal":
              if (roll()) healPlayerByPercent(payload.percentFromValue ? option.value : payload.percent || 0);
              break;
            case "multi":
              (payload.actions || []).forEach((action) => {
                if (action.triggerMatch && action.triggerMatch !== context.trigger) return;
                extraAttacks += executeLegendaryPayload(
                  { ...option, payload: action },
                  context,
                );
              });
              break;
            default:
              break;
          }

          return extraAttacks;
        }

        function initializeLegendaryBattleState() {
          player.legendaryState = player.legendaryState || {};
          player.legendaryState.openingStrikeActive = getLegendaryOptionsByTrigger(
            "damageMultiplier",
          ).some((opt) => opt.payload?.condition?.type === "openingTurn");
          player.legendaryState.nextGuaranteedHit = false;
        }

        function finalizeLegendaryPlayerTurn() {
          if (player.legendaryState?.openingStrikeActive) {
            player.legendaryState.openingStrikeActive = false;
          }
        }

        function consumeLegendaryGuaranteedHit() {
          if (hasStatus(player, "seal")) return false;
          if (player.legendaryState?.nextGuaranteedHit) {
            player.legendaryState.nextGuaranteedHit = false;
            return true;
          }
          return false;
        }

        function applyLegendaryBattleStartEffects() {
          getLegendaryOptionsByTrigger("battleStart").forEach((option) => {
            executeLegendaryPayload(option, { target: player, trigger: "battleStart" });
          });
        }

        function applyLegendaryTurnStartEffects(entity) {
          if (entity !== player) return;
          getLegendaryOptionsByTrigger("turnStart").forEach((option) => {
            executeLegendaryPayload(option, { target: player, trigger: "turnStart" });
          });
        }

        function handleLegendaryEvadeTrigger() {
          getLegendaryOptionsByTrigger("evade").forEach((option) => {
            executeLegendaryPayload(option, { target: player, trigger: "evade" });
          });
        }

        function getPlayerLegendaryDamageMultiplier(target) {
          if (hasStatus(player, "seal")) return 1;
          let multiplier = 1;
          getLegendaryOptionsByTrigger("damageMultiplier").forEach((option) => {
            const payload =
              option.payload?.type === "multiTrigger"
                ? option.payload.byTrigger?.damageMultiplier
                : option.payload;
            if (!payload?.condition) return;
            if (hasLegendaryCondition(payload.condition, target, option.value)) {
              multiplier *= 1 + (option.value || 0) / 100;
            }
          });
          return multiplier;
        }

        function getPlayerLegendaryDamageTakenMultiplier() {
          if (hasStatus(player, "seal")) return 1;
          let multiplier = 1;
          getLegendaryOptionsByTrigger("damageTakenMultiplier").forEach((option) => {
            const payload =
              option.payload?.type === "multiTrigger"
                ? option.payload.byTrigger?.damageTakenMultiplier
                : option.payload;
            if (!payload?.condition) return;
            if (hasLegendaryCondition(payload.condition, player, option.value)) {
              multiplier *= 1 - (option.value || 0) / 100;
            }
          });
          return multiplier;
        }

        function applyLegendaryHitEffects(
          target,
          { isSkill = false, isCritical = false } = {},
        ) {
          if (!target || target.hp <= 0) return 0;
          let extraAttacks = 0;
          const triggers = [];
          triggers.push(isSkill ? "skillHit" : "hit");
          if (isCritical) triggers.push("critical");
          triggers.forEach((trigger) => {
            getLegendaryOptionsByTrigger(trigger).forEach((option) => {
              extraAttacks += executeLegendaryPayload(option, { target, trigger });
            });
          });
          return extraAttacks;
        }

        function calculateDotDamage(target, status) {
          switch (status.key) {
            case "bleed":
              return Math.max(
                1,
                Math.round(
                  (status.payload?.attack || target.maxHp * 0.05) * 0.4,
                ),
              );
            case "poison":
              return Math.max(1, Math.round(target.maxHp * 0.06 + 2));
            case "curse":
              return Math.max(1, Math.round(target.maxHp * 0.04 + 1));
            case "burn":
              return Math.max(1, Math.round(target.maxHp * 0.05 + 3));
            default:
              return 0;
          }
        }

        function applyDotEffects(entity) {
          (entity.statuses || []).forEach((status) => {
            const def = STATUS_DEFINITIONS[status.key];
            if (!def || def.category !== STATUS_CATEGORIES.dot) return;
            const dotDmg = calculateDotDamage(entity, status);
            if (dotDmg <= 0) return;
            const dealt = applyDamage(entity, dotDmg, {
              type: "dot",
              source: status.key,
              isDot: true,
            });
            if (dealt > 0) {
              log(
                `🩸 ${entity.name} は${def.name}で ${dealt} ダメージ`,
                "danger",
              );
            }
          });
        }

        function processTurnStart(entity) {
          const baseAttacks = Math.max(0, Math.floor(entity.attackCount || 0));
          entity.attacksRemaining = baseAttacks;
          applyDotEffects(entity);
          if (entity.hp <= 0) return { defeated: true, skipTurn: true };
          const regenPercent = Math.max(0, entity.hpRegen || 0);
          if (regenPercent > 0 && entity.hp > 0 && entity.maxHp > 0) {
            const healAmount = roundBattleValue(
              entity.maxHp * (regenPercent / 100),
            );
            if (healAmount > 0) {
              const healed = applyHealing(entity, healAmount);
              if (healed > 0 && entity === player) {
                log(`🌿 HP再生で ${healed} 回復`, "good");
              }
            }
          }
          if (entity === player) {
            tickSkillCooldowns();
          }
          applyLegendaryTurnStartEffects(entity);
          const skipTurn =
            hasStatus(entity, "stun") || hasStatus(entity, "sleep");
          if (skipTurn) {
            log(`${entity.name} は行動不能…`, "warning");
          }
          return { skipTurn, defeated: false };
        }

        function finalizeTurn(entity) {
          decayStatuses(entity);
          tickBuffs(entity);
        }

        function updateHpBar(currentHp, maxHp, barrierAmount) {
          const hpFill = document.getElementById("hp-bar");
          const barrierFill = document.getElementById("hp-barrier");
          const safeMax = Math.max(1, maxHp);
          const hpPercent = Math.max(0, Math.min(100, (currentHp / safeMax) * 100));
          if (hpFill) {
            hpFill.style.width = `${hpPercent}%`;
            hpFill.className = "hp";
          }
          if (barrierFill) {
            const barrierPercent = Math.max(
              0,
              Math.min(100, (Math.max(0, barrierAmount) / safeMax) * 100),
            );
            barrierFill.style.width = `${barrierPercent}%`;
            barrierFill.className = "barrier";
            barrierFill.style.opacity = barrierAmount > 0 ? "0.65" : "0";
          }
        }

        function updateBars(id, current, max, cls) {
          const bar = document.getElementById(id);
          const safeMax = Math.max(1, roundBattleValue(max));
          const safeCurrent = Math.max(0, roundBattleValue(current));
          const percent = Math.max(
            0,
            Math.min(100, (safeCurrent / safeMax) * 100),
          );
          bar.style.width = `${percent}%`;
          bar.className = cls;
        }

        function flashBar(spanId) {
          const fill = document.getElementById(spanId);
          const bar = fill?.parentElement;
          if (!bar) return;
          bar.classList.remove("flash");
          // 強制再計測でアニメーションを繰り返し適用
          void bar.offsetWidth;
          bar.classList.add("flash");
        }

function ensurePopupLayer() {
  let layer = document.getElementById("popup-layer");
  if (!layer) {
    layer = document.createElement("div");
    layer.id = "popup-layer";
    document.body.appendChild(layer);
  }
  return layer;
}

        
function showDamagePopup(
  container,
  amount,
  variant = "enemy",
  { isCritical = false, target = "enemy" } = {},
) {
  if (!container || !amount) return;

  const popup = document.createElement("div");
  popup.className = `damage-popup ${variant}${isCritical ? " critical" : ""}`;

  const numeric = Math.abs(amount);
  const valueText = amount >= 0 ? `-${numeric}` : `+${numeric}`;

  popup.innerHTML = isCritical
    ? `<span class="crit-badge"><span class="crit-star">✦</span>CRIT</span>${valueText}`
    : valueText;

  // ★プレイヤー側だけ：containerのtransform/overflowの影響を回避して画面固定で出す
  if (target === "player") {
    const layer = ensurePopupLayer();
    layer.appendChild(popup);

    const rect = container.getBoundingClientRect();
    popup.style.position = "fixed";
    popup.style.left = `${rect.left + rect.width / 2}px`;
    popup.style.top = `${rect.top + 6}px`;

    // 既存の .damage-popup が transform: translate(-50%, 0) を持ってるので
    // fixed配置でもそのまま同じ見た目になります（ここは追加で触らない）
  } else {
    // ★敵側は従来通り container に absolute で出す
    container.appendChild(popup);
  }

  popup.addEventListener("animationend", () => popup.remove());
}


        function showHealPopup(container, amount, variant = "heal") {
          if (!container || amount <= 0) return;
        
          const rounded = Math.round(amount);
        
          if (rounded <= 0) return;
        
          showDamagePopup(container, -rounded, variant, {
            isCritical: false,
          });
        }


        function showSkillPopup(container, label, variant = "player") {
          if (!container || !label) return;
          const popup = document.createElement("div");
          const classes = ["skill-popup"];
          if (variant) classes.push(variant);
          popup.className = classes.join(" ");
          popup.textContent = label;
          container.appendChild(popup);
          popup.addEventListener("animationend", () => popup.remove());
        }

        function getPlayerHpBarContainer() {
          return document.getElementById("hp-bar")?.parentElement;
        }

        function getEnemyCardContainer(enemy) {
          return (
            findEnemyCard(enemy) ||
            document.querySelector(".enemy-panel") ||
            null
          );
        }

        function consumeMp(cost) {
          if (!cost || cost <= 0) return;
          player.mp = Math.max(0, player.mp - cost);
          flashBar("mp-bar");
          const mpBar = document.getElementById("mp-bar")?.parentElement;
          showDamagePopup(mpBar, cost, "mp");
        }

        function findEnemyCard(enemy) {
          return document.querySelector(
            `.enemy-card[data-enemy-id="${enemy?.id}"]`,
          );
        }

        function triggerEnemyHit(
          enemy,
          amount = 0,
          { isCritical = false } = {},
        ) {
          const card = findEnemyCard(enemy);
          if (!card) return;
          const bar = card.querySelector(".enemy-bar");
          if (bar) {
            bar.classList.remove("pulse");
            void bar.offsetWidth;
            bar.classList.add("pulse");
          }
          showDamagePopup(card, amount, "enemy", { isCritical });
        }

        function updateEnemyCardHp(enemy) {
          const card = findEnemyCard(enemy);
          if (!card) return;
          const fill = card.querySelector(".enemy-bar .fill");
          const label = card.querySelector(".enemy-bar .label");
          const roundedHp = roundBattleValue(enemy.hp);
          const roundedMaxHp = Math.max(1, roundBattleValue(enemy.maxHp));
          const hpPct = Math.max(
            0,
            Math.floor((roundedHp / roundedMaxHp) * 100),
          );
          if (fill) fill.style.width = `${hpPct}%`;
          if (label)
            label.textContent = `${roundedHp} / ${roundedMaxHp} (${hpPct}%)`;
        }

        function showPlayerDownOverlay() {
          if (!playerDownOverlay) return;
          const alreadyVisible =
            playerDownOverlay.classList.contains("show");
          if (alreadyVisible) return;
          playerDownOverlay.classList.add("show");
          playerDownOverlay.classList.remove("interactive");
          clearTimeout(playerDownOverlayReadyTimer);
          playerDownOverlayReadyTimer = window.setTimeout(() => {
            playerDownOverlay?.classList.add("interactive");
          }, 900);
        }

        function hidePlayerDownOverlay() {
          if (!playerDownOverlay) return;
          clearTimeout(playerDownOverlayReadyTimer);
          playerDownOverlay.classList.remove("show", "interactive");
        }

        function syncPlayerDownOverlay() {
          if (player.hp <= 0) {
            showPlayerDownOverlay();
          } else {
            hidePlayerDownOverlay();
          }
        }

        function updateUI(derivedStats = null) {
          const derived = derivedStats || recalcDerivedStats();
          lastDerivedStats = derived;
          updateStepButton();
          document.getElementById("floor-inline").textContent = game.floor;
          const displayHp = roundBattleValue(player.hp);
          const displayBarrier = Math.max(
            0,
            roundBattleValue(player.barrierRemaining ?? 0),
          );
          const displayMaxHp = Math.max(
            1,
            roundBattleValue(derived.maxHp.total),
          );
          const barrierText =
            displayBarrier > 0 ? ` + バリア ${displayBarrier}` : "";
          document.getElementById("hp-label").textContent =
            `HP ${displayHp} / ${displayMaxHp}${barrierText}`;
          const displayMp = roundBattleValue(player.mp);
          const displayMaxMp = Math.max(1, roundBattleValue(derived.maxMp.total));
          const displayExp = roundBattleValue(player.exp);
          const displayExpToLevel = Math.max(1, roundBattleValue(player.expToLevel));
          document.getElementById("mp-label").textContent =
            `MP ${displayMp} / ${displayMaxMp}`;
          document.getElementById("exp-label").textContent =
            `EXP ${displayExp} / ${displayExpToLevel}`;
          document.getElementById("level").textContent = player.level;
          document.getElementById("gold").textContent = formatGold(player.gold);
          document.getElementById("stat-points").textContent =
            player.statPoints;
          document.getElementById("skill-points-skill").textContent =
            player.skillPoints;
          if (passiveTreePoints) {
            passiveTreePoints.textContent = player.passivePoints;
          }
          updateHpBar(displayHp, displayMaxHp, displayBarrier);
          updateBars("mp-bar", displayMp, displayMaxMp, "mp");
          updateBars("exp-bar", displayExp, displayExpToLevel, "exp");
          syncPlayerDownOverlay();

          renderEnemies();
          renderActions();
          renderSecondaryStats(derived);
          renderPrimaryStats();
          if (
            !playerModal.classList.contains("hidden") &&
            playerModalPage === "equipment"
          ) {
            renderEquipmentOverview();
          }
          renderSkills();
          renderStatusList(
            document.getElementById("player-status-list"),
            player,
          );
          renderWeaponEnhancePanel();
          renderTurnOrder();
          maybeShowEnemyIntroGuidance();
          if (passiveTreeModal && !passiveTreeModal.classList.contains("hidden")) {
            renderPassiveTree();
          }
        }

        function renderStatusList(container, entity) {
          if (!container) return;
          container.innerHTML = "";
          const effects = collectActiveEffects(entity);
          effects.forEach((effect) => {
            const pill = document.createElement("div");
            pill.className = `status-pill ${effect.category}`;
            pill.textContent = effect.def.short;
            pill.title =
              effect.type === "buff"
                ? describeBuff(effect.key, effect.remaining)
                : describeStatus(effect.status);
            pill.onclick = (e) => {
              e.stopPropagation();
              showStatusPopover(entity, effect.key);
            };
            container.appendChild(pill);
          });
        }

        function renderDebugStatusButtons() {
          const container = document.getElementById("debug-status-buttons");
          if (!container) return;
          container.innerHTML = "";
          const groups = { control: [], dot: [], debuff: [] };
          Object.entries(STATUS_DEFINITIONS).forEach(([key, def]) => {
            if (!groups[def.category]) return;
            groups[def.category].push({ key, def });
          });

          Object.entries(groups).forEach(([category, items]) => {
            const section = document.createElement("div");
            section.className = "debug-section";
            const title = document.createElement("h4");
            const label =
              category === STATUS_CATEGORIES.control
                ? "行動阻害"
                : category === STATUS_CATEGORIES.dot
                  ? "DoT"
                  : "弱体化";
            title.textContent = `${label} (${items.length})`;
            section.appendChild(title);

            const row = document.createElement("div");
            row.className = "debug-buttons";
            items.forEach(({ key, def }) => {
              const btn = document.createElement("button");
              btn.textContent = `${def.short} ${def.name}`;
              btn.onclick = () => {
                const target = getDebugTarget();
                if (!target) {
                  log("対象が存在しません", "warning");
                  return;
                }
                const applied = applyStatus(target, key, {
                  duration: 3,
                  chance: 100,
                  potency: def.potency,
                  ignoreResist: true,
                });
                if (applied) {
                  log(
                    `🐞 デバッグ: ${target.name} に${def.name}を付与`,
                    "info",
                  );
                  updateUI();
                } else {
                  log("付与に失敗しました", "warning");
                }
              };
              row.appendChild(btn);
            });
            section.appendChild(row);
            container.appendChild(section);
          });
        }

        function populateDebugEnemySelect() {
          const select = document.getElementById("debug-enemy");
          if (!select) return;
          select.innerHTML = "";
          if (!game.enemies.length) {
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "敵なし";
            select.appendChild(opt);
            return;
          }
          game.enemies.forEach((enemy, index) => {
            const opt = document.createElement("option");
            opt.value = String(enemy.id);
            opt.textContent = `#${index + 1} ${enemy.name}${enemy.hp <= 0 ? " (撃破)" : ""}`;
            select.appendChild(opt);
          });
        }

        function updateDebugTargetState() {
          const targetSelect = document.getElementById("debug-target");
          const enemySelect = document.getElementById("debug-enemy");
          if (!targetSelect || !enemySelect) return;
          const isPlayer = targetSelect.value === "player";
          enemySelect.disabled = isPlayer;
          if (
            !isPlayer &&
            enemySelect.options.length > 0 &&
            !enemySelect.value
          ) {
            enemySelect.value = enemySelect.options[0].value;
          }
        }

        function getDebugTarget() {
          const targetSelect = document.getElementById("debug-target");
          const enemySelect = document.getElementById("debug-enemy");
          if (!targetSelect) return null;
          if (targetSelect.value === "player") return player;
          const enemyId = enemySelect?.value;
          if (!enemyId) return game.enemies[0] || null;
          return (
            game.enemies.find((e) => String(e.id) === enemyId && e.hp > 0) ||
            game.enemies.find((e) => String(e.id) === enemyId) ||
            game.enemies[0] ||
            null
          );
        }

        function populateDebugGearSelects() {
          if (!debugGearSlotSelect || !debugGearRaritySelect) return;
          if (!debugGearSlotSelect.options.length) {
            Object.entries(EQUIPMENT_SLOTS).forEach(([key, def]) => {
              const opt = document.createElement("option");
              opt.value = key;
              opt.textContent = def.label;
              debugGearSlotSelect.appendChild(opt);
            });
          }
          if (!debugGearRaritySelect.options.length) {
            DEBUG_RARITY_OPTIONS.forEach((rarity) => {
              const opt = document.createElement("option");
              opt.value = rarity.key;
              opt.textContent = rarity.label;
              debugGearRaritySelect.appendChild(opt);
            });
          }
          if (!debugGearSlotSelect.value) debugGearSlotSelect.value = "weapon";
          if (!debugGearRaritySelect.value)
            debugGearRaritySelect.value = "random";
        }

        function populateLegendaryTemplateSelect() {
          if (!debugLegendarySelect) return;
          const slotKey = debugGearSlotSelect?.value || "weapon";
          const rarityKey = debugGearRaritySelect?.value;
          const isLegendary = rarityKey === "legendary";

          debugLegendaryWrapper?.classList.toggle("hidden", !isLegendary);
          debugLegendarySelect.innerHTML = "";
          if (!isLegendary) return;

          const list = LEGENDARY_EQUIPMENT_LIBRARY[slotKey] || [];
          const randomOpt = document.createElement("option");
          randomOpt.value = "";
          randomOpt.textContent = "おまかせ（ランダム）";
          debugLegendarySelect.appendChild(randomOpt);

          list.forEach((entry) => {
            const opt = document.createElement("option");
            opt.value = entry.key;
            opt.textContent = entry.name;
            debugLegendarySelect.appendChild(opt);
          });

          if (!debugLegendarySelect.value) debugLegendarySelect.value = "";
        }

        function populateLegendaryPotionSelect() {
          if (!debugPotionLegendarySelect) return;
          const rarityKey = debugPotionRaritySelect?.value;
          const isLegendary = rarityKey === "legendary";
          debugPotionLegendaryWrapper?.classList.toggle("hidden", !isLegendary);

          debugPotionLegendarySelect.innerHTML = "";
          if (!isLegendary) return;

          const randomOpt = document.createElement("option");
          randomOpt.value = "";
          randomOpt.textContent = "おまかせ（ランダム）";
          debugPotionLegendarySelect.appendChild(randomOpt);

          LEGENDARY_POTIONS.forEach((entry) => {
            const opt = document.createElement("option");
            opt.value = entry.key;
            opt.textContent = entry.name;
            debugPotionLegendarySelect.appendChild(opt);
          });

          if (!debugPotionLegendarySelect.value)
            debugPotionLegendarySelect.value = "";
        }

        function populateDebugPotionVariantSelect(templateKey) {
          if (!debugPotionVariantSelect) return;
          const key =
            templateKey ||
            debugPotionTemplateSelect?.value ||
            Object.keys(POTION_BASE_TEMPLATES)[0];
          const template = POTION_BASE_TEMPLATES[key];
          debugPotionVariantSelect.innerHTML = "";
          (template?.variants || []).forEach((variant, index) => {
            const opt = document.createElement("option");
            opt.value = variant.key;
            opt.textContent = variant.label;
            debugPotionVariantSelect.appendChild(opt);
            if (index === 0 && !debugPotionVariantSelect.value) {
              debugPotionVariantSelect.value = variant.key;
            }
          });
        }

        function populateDebugPotionSlotSelect() {
          if (!debugPotionSlotSelect) return;
          debugPotionSlotSelect.innerHTML = "";
          const none = document.createElement("option");
          none.value = "";
          none.textContent = "装備しない（インベントリ追加のみ）";
          debugPotionSlotSelect.appendChild(none);

          (player.potions || []).forEach((potion, index) => {
            const opt = document.createElement("option");
            opt.value = String(index);
            const label = potion?.name || `スロット${index + 1}`;
            opt.textContent = `スロット${index + 1}${potion ? `: ${label}` : ""}`;
            debugPotionSlotSelect.appendChild(opt);
          });

          if (!debugPotionSlotSelect.value) debugPotionSlotSelect.value = "";
        }

        function populateDebugPotionSelects() {
          if (!debugPotionTemplateSelect || !debugPotionRaritySelect) return;

          if (!debugPotionTemplateSelect.options.length) {
            Object.values(POTION_BASE_TEMPLATES).forEach((template, index) => {
              const opt = document.createElement("option");
              opt.value = template.key;
              opt.textContent = template.label;
              debugPotionTemplateSelect.appendChild(opt);
              if (index === 0 && !debugPotionTemplateSelect.value) {
                debugPotionTemplateSelect.value = template.key;
              }
            });
          }

          if (!debugPotionRaritySelect.options.length) {
            DEBUG_POTION_RARITY_OPTIONS.forEach((rarity) => {
              const opt = document.createElement("option");
              opt.value = rarity.key;
              opt.textContent = rarity.label;
              debugPotionRaritySelect.appendChild(opt);
            });
          }

          if (!debugPotionTemplateSelect.value) {
            debugPotionTemplateSelect.value = Object.keys(
              POTION_BASE_TEMPLATES,
            )[0];
          }

          populateDebugPotionVariantSelect(debugPotionTemplateSelect.value);
          if (!debugPotionRaritySelect.value)
            debugPotionRaritySelect.value = "random";
          populateDebugPotionSlotSelect();
          updateDebugPotionControlState();
        }

        function updateDebugPotionControlState() {
          const isLegendary = debugPotionRaritySelect?.value === "legendary";
          if (debugPotionTemplateSelect)
            debugPotionTemplateSelect.disabled = isLegendary;
          if (debugPotionVariantSelect)
            debugPotionVariantSelect.disabled = isLegendary;
          populateLegendaryPotionSelect();
        }

        function resolveDebugPotionRarity(
          selection,
          { randomRarity = false } = {},
        ) {
          let choice = selection;
          if (randomRarity) {
            const pick =
              DEBUG_POTION_RARITY_OPTIONS[
                randomInt(0, DEBUG_POTION_RARITY_OPTIONS.length - 1)
              ];
            choice = pick?.key;
          }
          if (choice === "random") {
            return NON_LEGENDARY_RARITIES[
              randomInt(0, NON_LEGENDARY_RARITIES.length - 1)
            ];
          }
          if (choice && POTION_RARITIES[choice]) return choice;
          return "normal";
        }

        function renderDebugPotionPreview(potion) {
          if (!debugPotionPreview) return;
          debugPotionPreview.innerHTML = "";
          if (!potion) {
            const empty = document.createElement("div");
            empty.className = "option-label";
            empty.textContent = "ポーションのプレビューがここに表示されます";
            debugPotionPreview.appendChild(empty);
            return;
          }

          const title = document.createElement("div");
          title.className = "option-value";
          title.textContent = `${potion.name} (${potion.rarityLabel || potion.rarity})`;
          applyItemRarityColor(title, { potion });
          debugPotionPreview.appendChild(title);

          const type = document.createElement("div");
          type.className = "option-label";
          const typeLabel =
            potion.category === "buff"
              ? "バフ"
              : potion.type === "hp"
                ? "HP回復"
                : potion.type === "mp"
                  ? "MP回復"
                  : "特殊";
          type.textContent = `種類: ${typeLabel}`;
          debugPotionPreview.appendChild(type);

          const effect = document.createElement("div");
          effect.className = "option-value";
          effect.textContent = describePotionEffect(potion);
          debugPotionPreview.appendChild(effect);

          const cost = document.createElement("div");
          cost.className = "option-label";
          const { useCost, refund } = calculatePotionConsumption(potion);
          const refundLabel = refund > 0 ? ` (還元${refund}%)` : "";
          cost.textContent = `消費: 1回 ${useCost}%${refundLabel} / 最大 ${potion.maxFullness}%`;
          debugPotionPreview.appendChild(cost);

          const prefix = document.createElement("div");
          prefix.className = "option-value";
          prefix.textContent = `前置詞: ${describePotionAffix(potion.prefix)}`;
          debugPotionPreview.appendChild(prefix);

          const suffix = document.createElement("div");
          suffix.className = "option-value";
          suffix.textContent = `後置詞: ${describePotionAffix(potion.suffix)}`;
          debugPotionPreview.appendChild(suffix);
        }

        function buildDebugPotionPreview() {
          const rarityKey = resolveDebugPotionRarity(
            debugPotionRaritySelect?.value || "normal",
          );
          const legendaryKey =
            rarityKey === "legendary"
              ? debugPotionLegendarySelect?.value || ""
              : "";
          if (rarityKey === "legendary") {
            return createLegendaryPotion(legendaryKey);
          }
          if (!debugPotionTemplateSelect || !debugPotionVariantSelect)
            return null;
          const templateKey =
            debugPotionTemplateSelect.value ||
            Object.keys(POTION_BASE_TEMPLATES)[0];
          const variantKey =
            debugPotionVariantSelect.value ||
            POTION_BASE_TEMPLATES[templateKey]?.variants?.[0]?.key ||
            "";
          if (!templateKey || !variantKey) return null;
          return createPotionFromTemplate(templateKey, variantKey, {
            rarityKey,
          });
        }

        function generateDebugPotion({ randomRarity = false } = {}) {
          const rarityKey = resolveDebugPotionRarity(
            debugPotionRaritySelect?.value || "normal",
            { randomRarity },
          );
          const legendaryKey =
            rarityKey === "legendary"
              ? debugPotionLegendarySelect?.value || ""
              : "";

          const potion =
            rarityKey === "legendary"
              ? createLegendaryPotion(legendaryKey)
              : (() => {
                  if (!debugPotionTemplateSelect || !debugPotionVariantSelect)
                    return null;
                  const templateKey =
                    debugPotionTemplateSelect.value ||
                    Object.keys(POTION_BASE_TEMPLATES)[0];
                  const variantKey =
                    debugPotionVariantSelect.value ||
                    POTION_BASE_TEMPLATES[templateKey]?.variants?.[0]?.key ||
                    "";
                  if (!templateKey || !variantKey) return null;
                  return createPotionFromTemplate(templateKey, variantKey, {
                    rarityKey,
                  });
                })();
          if (!potion) return null;

          const slotValue = debugPotionSlotSelect?.value ?? "";
          const slotIndex = slotValue === "" ? -1 : Number(slotValue);
          const item = createPotionInventoryItem(potion, {
            description: "デバッグで生成したポーション",
          });
          registerCodexDiscovery(item);
          player.inventory.items.push(item);

          if (Number.isInteger(slotIndex) && slotIndex >= 0) {
            const previous = player.potions?.[slotIndex];
            player.potions[slotIndex] = potion;
            if (previous) {
              const removed = ensureAcquiredOrder(
                createPotionInventoryItem(previous, {
                  description: "スロットから外したポーション",
                }),
              );
              player.inventory.items.push(removed);
              registerCodexDiscovery(removed);
            }
            log(
              `💧 ${potion.name} を生成しスロット${slotIndex + 1}に装備`,
              "info",
            );
          } else {
            log(`💧 ${potion.name} を生成しインベントリへ追加`, "info");
          }

          lastGeneratedPotion = potion;
          populateDebugPotionSlotSelect();
          renderDebugPotionPreview(potion);
          renderInventory();
          updateUI();
          return potion;
        }

        function rerollDebugPotionPreview() {
          const potion = buildDebugPotionPreview();
          lastGeneratedPotion = potion;
          renderDebugPotionPreview(potion);
        }

        function switchDebugTab(tabKey) {
          const panels = {
            status: debugTabStatus,
            equipment: debugTabEquipment,
            adjust: debugTabAdjust,
            save: debugTabSave,
          };
          Object.entries(panels).forEach(([key, panel]) => {
            panel?.classList.toggle("hidden", key !== tabKey);
          });
          debugTabButtons.forEach((btn) => {
            const active = btn.dataset.tab === tabKey;
            btn.classList.toggle("active", active);
          });
          if (tabKey === "equipment") {
            populateDebugGearSelects();
            populateLegendaryTemplateSelect();
            renderDebugGearPreview(lastGeneratedEquipment);
            populateDebugPotionSelects();
            renderDebugPotionPreview(
              lastGeneratedPotion || buildDebugPotionPreview(),
            );
          } else if (tabKey === "status") {
            populateDebugEnemySelect();
            renderDebugStatusButtons();
            updateDebugTargetState();
          } else if (tabKey === "adjust") {
            syncDebugAdjustInputs();
          } else if (tabKey === "save") {
            renderSaveSlots();
          }
        }

        function calcExpToNextLevel(targetLevel) {
          let req = 15;
          for (let level = 1; level < targetLevel; level += 1) {
            req = Math.round(req * 1.25);
          }
          return req;
        }

        function syncDebugAdjustInputs() {
          if (debugLevelInput) debugLevelInput.value = player.level;
          if (debugHpInput) debugHpInput.value = Math.round(player.hp);
          if (debugGoldInput)
            debugGoldInput.value = Math.max(0, Math.round(player.gold));
          if (debugFloorInput) debugFloorInput.value = game.floor;
          if (debugForceLegendaryCheckbox)
            debugForceLegendaryCheckbox.checked = !!debugForceBossLegendaryDrop;
          if (debugAutoAttackCheckbox)
            debugAutoAttackCheckbox.checked = !!debugAutoAttackEnabled;
          if (debugCodexUnlockCheckbox)
            debugCodexUnlockCheckbox.checked = !!debugCodexFullyUnlocked;
        }

        function runDebugAutoAttackTick() {
          if (!debugAutoAttackEnabled) return;
          if (player.hp <= 0) return;
          const enemiesAlive = game.enemies?.some((enemy) => enemy.hp > 0);
          if (!enemiesAlive) {
            if (isBossFloor(game.floor) && game.bossRetryEnabled) {
              retryBossFloor();
            } else {
              nextFloor();
            }
            return;
          }
          if (!game.awaitingInput) return;
          let attacks = Math.max(
            0,
            Math.floor(player.attacksRemaining ?? player.attackCount ?? 0),
          );
          if (attacks <= 0) return;
          playerAttack();
        }

        function setDebugAutoAttackEnabled(nextValue) {
          debugAutoAttackEnabled = nextValue;
          if (debugAutoAttackEnabled) {
            if (!debugAutoAttackTimer) {
              debugAutoAttackTimer = window.setInterval(
                runDebugAutoAttackTick,
                280,
              );
            }
            runDebugAutoAttackTick();
          } else if (debugAutoAttackTimer) {
            clearInterval(debugAutoAttackTimer);
            debugAutoAttackTimer = null;
          }
        }

        function applyDebugLevelChange() {
          if (!debugLevelInput) return;
          const requested = Number(debugLevelInput.value);
          if (Number.isNaN(requested)) return;
          const nextLevel = Math.max(1, Math.floor(requested));
          const delta = nextLevel - player.level;
          if (delta === 0) {
            log("レベルは既に指定値です", "info");
            return;
          }

          player.level = nextLevel;
          player.exp = 0;
          player.expToLevel = calcExpToNextLevel(nextLevel);
          player.statPoints = Math.max(0, player.statPoints + delta * 5);
          player.skillPoints = Math.max(0, player.skillPoints + delta);

          const derived = recalcDerivedStats();
          updateUI(derived);
          log(
            `🔧 Lv${nextLevel} に変更 (能力P${delta >= 0 ? "+" : ""}${delta * 5} / スキルP${delta >= 0 ? "+" : ""}${delta})`,
            "info",
          );
          maybeAutoSave("デバッグ:レベル変更");
        }

        function applyDebugHpChange() {
          if (!debugHpInput) return;
          const requested = Number(debugHpInput.value);
          if (Number.isNaN(requested)) return;
          const nextHp = Math.max(0, Math.floor(requested));
          player.hp = Math.min(nextHp, Math.round(player.maxHp));
          updateUI();
          log(`💚 HPを ${player.hp} に設定`, "info");
          maybeAutoSave("デバッグ:HP調整");
        }

        function applyDebugGoldChange() {
          if (!debugGoldInput) return;
          const requested = Number(debugGoldInput.value);
          if (Number.isNaN(requested)) return;
          const nextGold = Math.max(0, Math.floor(requested));
          player.gold = nextGold;
          updateUI();
          log(`💰 所持金を ${formatGold(nextGold)}G に設定`, "info");
          maybeAutoSave("デバッグ:所持金変更");
        }

        function applyDebugFloorChange(forcedFloor) {
          if (!debugFloorInput && forcedFloor === undefined) return;

          // まず「元の値」を一旦取り出す（数値でも文字列でもOK）
          const raw = forcedFloor ?? debugFloorInput.value;

          // ここで必ず Number(...) に通して数値化する
          const requested = Number(raw);

          // 数値に変換できなかったら何もしない（NaN汚染を防ぐ）
          if (!Number.isFinite(requested)) {
            log("⚠️ 階層の指定が数値として解釈できませんでした", "warn");
            return;
          }

          const nextFloor = Math.max(1, Math.floor(requested));

          // ボスジャンプボタンなどから呼ばれたときは、入力欄にも反映
          if (debugFloorInput && forcedFloor !== undefined) {
            debugFloorInput.value = nextFloor;
          }

          // 既に floor が変な値（NaNなど）だった場合の保険
          if (!Number.isFinite(game.floor) || game.floor <= 0) {
            game.floor = 1;
          }

          if (nextFloor !== game.floor) {
            game.floor = nextFloor;
            clearTurnOrderPreview();
            game.turnQueue = [];
            spawnEnemies();
            log(`🌀 ${nextFloor}F へジャンプ`, "info");
            maybeAutoSave("デバッグ:階層変更");
          } else {
            log("現在の階層と同じです", "info");
          }
        }

        const CURRENT_SAVE_VERSION = 1;
        const SAVE_SLOTS = [
          { id: "slot1", label: "スロット1" },
          { id: "slot2", label: "スロット2" },
          { id: "slot3", label: "スロット3" },
        ];
        const ACTIVE_SAVE_SLOT_KEY = "hakusura-active-slot";
        const AUTO_SAVE_COOLDOWN_MS = 3000;
        let lastAutoSaveAt = 0;
        let activeSaveSlotId = "slot1";

      // ★ buildSaveState / INITIAL_SAVE_STATE より前に置く
      let debugCodexSnapshot = null;
      let debugForceBossLegendaryDrop = false; // ボスのレジェンダリードロップ強制
      let debugAutoAttackEnabled = false;
      let debugAutoAttackTimer = null;
      let debugCodexFullyUnlocked = false;
      let debugCodexUnlockCheckbox = null; // 使ってるなら（null初期化でOK）
        
        const INITIAL_SAVE_STATE = buildSaveState();

        function maybeAutoSave(reason = "auto") {
          try {
            requestAutoSave(reason); // クールタイムも含めて中でやってもらう
          } catch (e) {
            console.error("auto save failed:", e);
          }
        }

        function cloneState(data) {
          if (typeof structuredClone === "function")
            return structuredClone(data);
          return JSON.parse(JSON.stringify(data));
        }

        function deepMerge(target, source) {
          if (!target || typeof target !== "object" || Array.isArray(target))
            return target;
          if (!source || typeof source !== "object") return target;
          Object.entries(source).forEach(([key, value]) => {
            if (Array.isArray(value)) {
              target[key] = cloneState(value);
            } else if (value && typeof value === "object") {
              const base = target[key];
              if (!base || typeof base !== "object" || Array.isArray(base))
                target[key] = {};
              deepMerge(target[key], value);
            } else {
              target[key] = value;
            }
          });
          return target;
        }

        function saveStorageKey(slotId, type = "primary") {
          return `hakusura-save-${slotId}-${type}`;
        }

        function normalizeSavePayload(data) {
          if (!data || typeof data !== "object") return null;
          const state = data.state && typeof data.state === "object"
            ? data.state
            : data;
          return { ...data, state };
        }

        function getSaveVersion(data) {
          const version = Number(data?.version);
          if (Number.isInteger(version) && version >= 0) return version;
          return 0;
        }

        function migrateFromV0ToV1(payload) {
          if (!payload.state || typeof payload.state !== "object") {
            payload.state = {};
          }
          if (!payload.state.ui || typeof payload.state.ui !== "object") {
            payload.state.ui = {};
          }
          payload.version = 1;
        }

        const SAVE_MIGRATIONS = {
          0: migrateFromV0ToV1,
        };

        function migrateSavePayload(rawPayload) {
          const normalized = normalizeSavePayload(rawPayload);
          if (!normalized?.state) return null;
          let version = getSaveVersion(rawPayload);
          const working = cloneState(normalized);

          while (version < CURRENT_SAVE_VERSION) {
            const migrator = SAVE_MIGRATIONS[version];
            if (typeof migrator !== "function") break;
            migrator(working);
            version += 1;
          }

          working.version = CURRENT_SAVE_VERSION;
          return { migratedFromVersion: getSaveVersion(rawPayload), ...working };
        }

        function prepareLoadedState(rawPayload) {
          const migrated = migrateSavePayload(rawPayload);
          if (!migrated?.state) return null;

          const base = cloneState(INITIAL_SAVE_STATE);
          const safeState =
            migrated.state && typeof migrated.state === "object"
              ? migrated.state
              : {};

          const mergedPlayer = deepMerge(base.player, safeState.player || {});
          const mergedGame = deepMerge(base.game, safeState.game || {});
          const mergedSkills = deepMerge(base.skills, safeState.skills || {});
          const mergedUi = deepMerge(base.ui, safeState.ui || {});

          if (!Array.isArray(mergedGame.enemies)) mergedGame.enemies = [];
          if (!Array.isArray(mergedGame.turnQueue)) mergedGame.turnQueue = [];
          if (!mergedGame.reachedBossFloors || typeof mergedGame.reachedBossFloors !== "object")
            mergedGame.reachedBossFloors = {};
          if (!mergedGame.bossKillRecords || typeof mergedGame.bossKillRecords !== "object")
            mergedGame.bossKillRecords = {};
          if (!mergedGame.legendaryRecords || typeof mergedGame.legendaryRecords !== "object")
            mergedGame.legendaryRecords = {};
          if (!mergedGame.codex || typeof mergedGame.codex !== "object")
            mergedGame.codex = cloneState(INITIAL_SAVE_STATE.game.codex);

          if (!Array.isArray(mergedPlayer.potions)) mergedPlayer.potions = [];
          if (!mergedPlayer.inventory || typeof mergedPlayer.inventory !== "object")
            mergedPlayer.inventory = cloneState(INITIAL_SAVE_STATE.player.inventory);
          if (!Array.isArray(mergedPlayer.inventory.items)) mergedPlayer.inventory.items = [];
          if (!Array.isArray(mergedPlayer.activeSkillSlots))
            mergedPlayer.activeSkillSlots = cloneState(
              INITIAL_SAVE_STATE.player.activeSkillSlots,
            );

          return {
            ...migrated,
            version: CURRENT_SAVE_VERSION,
            state: {
              player: mergedPlayer,
              game: mergedGame,
              skills: mergedSkills,
              ui: mergedUi,
            },
          };
        }

        function readSave(slotId, type = "primary") {
          try {
            const raw = localStorage.getItem(saveStorageKey(slotId, type));
            if (!raw) return null;
            const data = JSON.parse(raw);
            return normalizeSavePayload(data);
          } catch (err) {
            console.warn("save read failed", err);
            return null;
          }
        }

        function writeSave(
          slotId,
          state,
          { silent = false, reason = "手動保存" } = {},
        ) {
          try {
            const payload = {
              state,
              version: CURRENT_SAVE_VERSION,
              savedAt: Date.now(),
              reason,
            };
            const primaryKey = saveStorageKey(slotId, "primary");
            const backupKey = saveStorageKey(slotId, "backup");
            const currentPrimary = localStorage.getItem(primaryKey);
            if (currentPrimary) {
              localStorage.setItem(backupKey, currentPrimary);
            }
            localStorage.setItem(primaryKey, JSON.stringify(payload));
            if (!silent) {
              log(`💾 ${getSaveSlotLabel(slotId)} に保存しました`, "good");
            }
          } catch (err) {
            console.error("save failed", err);
            if (!silent)
              log("保存に失敗しました (ストレージ使用不可)", "danger");
          }
        }

        function deleteSave(slotId) {
          localStorage.removeItem(saveStorageKey(slotId, "primary"));
          localStorage.removeItem(saveStorageKey(slotId, "backup"));
          log(`🗑 ${getSaveSlotLabel(slotId)} を削除しました`, "info");
        }

        function buildUiSaveState() {
          const persistedRarities = Array.from(dropToastNotificationRarities).filter(
            (key) => BULK_SELL_RARITY_ORDER.includes(key),
          );
          const persistedAutoSell = Array.from(autoSellRarities).filter((key) =>
            BULK_SELL_RARITY_ORDER.includes(key),
          );

          return {
            inventorySortMode,
            dropToastNotificationRarities: persistedRarities,
            autoSellRarities: persistedAutoSell,
          };
        }
        
        function restoreUiState(uiState = {}) {
          const {
            inventorySortMode: savedSortMode,
            dropToastNotificationRarities: savedRarities,
            autoSellRarities: savedAutoSellRarities,
          } = uiState || {};
        
          inventorySortMode =
            savedSortMode === "rarity" || savedSortMode === "acquire"
              ? savedSortMode
              : "acquire";
        
          if (Array.isArray(savedRarities)) {
            const validRarities = savedRarities.filter((key) =>
              BULK_SELL_RARITY_ORDER.includes(key),
            );
            // ★ここは「グローバルの dropToastNotificationRarities」に代入
            dropToastNotificationRarities = new Set(validRarities);
          } else {
            dropToastNotificationRarities = new Set(BULK_SELL_RARITY_ORDER);
          }

          if (Array.isArray(savedAutoSellRarities)) {
            const validAutoSell = savedAutoSellRarities.filter((key) =>
              BULK_SELL_RARITY_ORDER.includes(key),
            );
            autoSellRarities = new Set(validAutoSell);
          } else {
            autoSellRarities = new Set();
          }
        }


        function buildSaveState() {
          const codexForSave =
            debugCodexFullyUnlocked && debugCodexSnapshot
              ? debugCodexSnapshot
              : game.codex;

          const gameForSave = {
            ...game,
            codex: codexForSave,
          };

          return cloneState({
            player,
            game: gameForSave,
            skills,
            ui: buildUiSaveState(),
          });
        }

        function replaceObject(target, source) {
          Object.keys(target).forEach((key) => delete target[key]);
          Object.entries(source).forEach(([key, value]) => {
            target[key] = cloneState(value);
          });
        }

        function normalizeOwnedEquipment() {
          Object.values(player.equipment || {}).forEach((item) =>
            normalizeEquipmentItem(item),
          );
          (player.inventory?.items || []).forEach((entry) =>
            normalizeEquipmentItem(entry),
          );
        }

        function restoreAttackCounts() {
          player.attacksRemaining = Math.max(
            0,
            Math.floor(player.attackCount || 0),
          );
          game.enemies = game.enemies || [];
          game.enemies.forEach((enemy) => {
            enemy.attacksRemaining = Math.max(
              0,
              Math.floor(enemy.attackCount || 0),
            );
          });
        }

        function applyLoadedState(
          preparedPayload,
          { usedBackup = false, slotId, suppressLog = false } = {},
        ) {
          const payload = preparedPayload?.state;
          if (!payload) return false;

          replaceObject(player, payload.player || {});
          replaceObject(game, payload.game || {});

          if (typeof game.autoSkillEnabled !== "boolean") {
            game.autoSkillEnabled = false;
          }
          if (typeof game.bossRetryEnabled !== "boolean") {
            game.bossRetryEnabled = false;
          }

          if (!Number.isFinite(game.floor) || game.floor <= 0) {
            game.floor = 1;
          }

          if (!Number.isFinite(game.highestFloor) || game.highestFloor < 1) {
            game.highestFloor = game.floor;
          } else {
            game.highestFloor = Math.max(game.highestFloor, game.floor);
          }
          if (!game.reachedBossFloors) game.reachedBossFloors = {};
          recordFloorProgress();

          if (!game.bossKillRecords) game.bossKillRecords = {};
          if (!game.legendaryRecords) game.legendaryRecords = {};
          ensureCodexState();
          debugCodexSnapshot = null;
          debugCodexFullyUnlocked = false;
          if (debugCodexUnlockCheckbox)
            debugCodexUnlockCheckbox.checked = false;
          restoreUiState(payload.ui);
          mergeSkillsFromSave(payload.skills || {});
          ensurePassiveTreeState();
          syncLockedSkills({ silent: true });
          normalizeOwnedEquipment();
          hydrateCodexFromOwned();
          calculateSkillBonuses();
          hideEnemyIntroGuidance();
          enemyIntroShown = false;
          const derived = recalcDerivedStats();
          const battleActive =
            game.awaitingInput || (game.enemies || []).some((e) => e.hp > 0);
          if (battleActive) {
            restoreAttackCounts();
          }
          updateUI(derived);
          renderInventoryFilters();
          renderInventory();
          renderSkillSummary();
          renderActiveSkillLoadout();
          buildTurnQueue();
          if (!suppressLog) {
            log(
              `📂 ${getSaveSlotLabel(slotId)} からロードしました${usedBackup ? " (バックアップから復旧)" : ""}`,
              "good",
            );
          }
          return true;
        }

        function getSaveSlotLabel(slotId) {
          const def = SAVE_SLOTS.find((s) => s.id === slotId);
          return def ? def.label : slotId;
        }

        function isPlayableSlot(slotId) {
          return SAVE_SLOTS.some((s) => s.id === slotId);
        }

        function setActiveSaveSlot(
          slotId,
          { persist = true, announce = false } = {},
        ) {
          if (!isPlayableSlot(slotId)) return;
          activeSaveSlotId = slotId;
          if (persist) localStorage.setItem(ACTIVE_SAVE_SLOT_KEY, slotId);
          if (announce)
            log(`🎯 現在のセーブ先: ${getSaveSlotLabel(slotId)}`, "info");
          renderSaveSlots();
        }

        function startNewRun(slotId) {
          const initialPayload = {
            version: CURRENT_SAVE_VERSION,
            state: cloneState(INITIAL_SAVE_STATE),
          };
          const prepared = prepareLoadedState(initialPayload);
          applyLoadedState(prepared, { slotId, suppressLog: true });
          spawnEnemies();
          setActiveSaveSlot(slotId, { announce: true });
          log("=== 新しく挑戦を開始 ===", "info");
        }

        function applySavePayloadWithBackup(
          slotId,
          { primary, backup },
          { announce = false, suppressLog = false } = {},
        ) {
          const attempts = [
            { payload: primary, usedBackup: false },
            { payload: backup, usedBackup: true },
          ];

          for (const attempt of attempts) {
            if (!attempt.payload) continue;
            try {
              const prepared = prepareLoadedState(attempt.payload);
              if (!prepared) throw new Error("invalid save payload");
              const ok = applyLoadedState(prepared, {
                usedBackup: attempt.usedBackup,
                slotId,
                suppressLog,
              });
              if (ok) {
                if (isPlayableSlot(slotId))
                  setActiveSaveSlot(slotId, { announce });
                return true;
              }
            } catch (err) {
              console.error("failed to load save", err);
              if (!attempt.usedBackup && backup) {
                log(
                  "メインのセーブ読み込みに失敗したため、バックアップから復旧を試みます",
                  "warning",
                );
              }
            }
          }

          if (!suppressLog) {
            log(
              "セーブデータが読み込めなかったため、新規データで開始します",
              "warning",
            );
          }
          return false;
        }

        function activateSaveSlot(slotId) {
          if (!isPlayableSlot(slotId)) return;
          const pair = readSlotPair(slotId);
          const loaded = applySavePayloadWithBackup(slotId, pair, {
            announce: true,
          });
          if (loaded) return;
          startNewRun(slotId);
        }

        function loadActiveSlotPreference() {
          const stored = localStorage.getItem(ACTIVE_SAVE_SLOT_KEY);
          if (isPlayableSlot(stored)) {
            activeSaveSlotId = stored;
          } else {
            activeSaveSlotId = "slot1";
            localStorage.setItem(ACTIVE_SAVE_SLOT_KEY, activeSaveSlotId);
          }
        }

        function autoLoadLastActiveSlot() {
          const pair = readSlotPair(activeSaveSlotId);
          const loaded = applySavePayloadWithBackup(activeSaveSlotId, pair, {
            announce: true,
          });
          if (!loaded) {
            log(
              "セーブデータ読み込み中にエラーが発生したため、新しく開始します",
              "warning",
            );
            return false;
          }
          return true;
        }

        function readSlotPair(slotId) {
          return {
            primary: readSave(slotId, "primary"),
            backup: readSave(slotId, "backup"),
          };
        }

        function formatSaveMeta(state) {
          if (!state) return "未保存";
          const payload = normalizeSavePayload(state);
          if (!payload?.state) return "未保存";
          const date = payload.savedAt ? new Date(payload.savedAt) : null;
          const ts = date ? date.toLocaleString() : "不明な日時";
          const level = payload.state.player?.level ?? "?";
          const floor = payload.state.game?.floor ?? "?";
          return `Lv${level} / ${floor}F @ ${ts}`;
        }

        function renderSaveSlots() {
          if (!saveSlotList) return;
          saveSlotList.innerHTML = "";
          SAVE_SLOTS.forEach((slot) => {
            const pair = readSlotPair(slot.id);
            const card = document.createElement("div");
            card.className = "save-slot-card";
            if (slot.id === activeSaveSlotId) card.classList.add("active");

            const header = document.createElement("div");
            header.className = "save-slot-header";
            const title = document.createElement("div");
            title.className = "save-slot-title";
            title.textContent = slot.label;
            if (slot.id === activeSaveSlotId) {
              const activeBadge = document.createElement("span");
              activeBadge.className = "save-slot-badge pill";
              activeBadge.textContent = "プレイ中";
              title.appendChild(activeBadge);
            }
            if (slot.description) {
              const badge = document.createElement("span");
              badge.className = "save-slot-badge pill";
              badge.textContent = slot.description;
              title.appendChild(badge);
            }
            const meta = document.createElement("div");
            meta.className = "save-slot-meta";
            meta.textContent = formatSaveMeta(pair.primary || pair.backup);
            header.appendChild(title);
            header.appendChild(meta);

            const actions = document.createElement("div");
            actions.className = "save-slot-actions";

            const activateBtn = document.createElement("button");
            activateBtn.textContent = "このスロットで遊ぶ";
            activateBtn.onclick = () => activateSaveSlot(slot.id);
            actions.appendChild(activateBtn);

            const saveBtn = document.createElement("button");
            saveBtn.textContent = "このスロットに保存";
            saveBtn.dataset.saveAction = "save";
            saveBtn.dataset.slot = slot.id;
            actions.appendChild(saveBtn);

            const loadBtn = document.createElement("button");
            loadBtn.textContent = "ロード";
            loadBtn.dataset.saveAction = "load";
            loadBtn.dataset.slot = slot.id;
            loadBtn.disabled = !pair.primary && !pair.backup;
            actions.appendChild(loadBtn);

            const exportBtn = document.createElement("button");
            exportBtn.textContent = "JSONをコピー";
            exportBtn.dataset.saveAction = "export";
            exportBtn.dataset.slot = slot.id;
            exportBtn.disabled = !pair.primary && !pair.backup;
            actions.appendChild(exportBtn);

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "データ削除";
            deleteBtn.dataset.saveAction = "delete";
            deleteBtn.dataset.slot = slot.id;
            deleteBtn.disabled = !pair.primary && !pair.backup;
            actions.appendChild(deleteBtn);

            const backupRow = document.createElement("div");
            backupRow.className = "subtle";
            backupRow.textContent = pair.backup
              ? "バックアップあり (直前の保存を保持)"
              : "バックアップ未作成";

            card.appendChild(header);
            card.appendChild(actions);
            card.appendChild(backupRow);
            saveSlotList.appendChild(card);
          });
        }

        function handleSaveAction(event) {
          const btn = event.target.closest("[data-save-action]");
          if (!btn) return;
          const slotId = btn.dataset.slot;
          const action = btn.dataset.saveAction;
          if (!slotId || !action) return;
          if (action === "save") {
            writeSave(slotId, buildSaveState());
            if (isPlayableSlot(slotId))
              setActiveSaveSlot(slotId, { announce: true });
            renderSaveSlots();
          } else if (action === "load") {
            const pair = readSlotPair(slotId);
            const sourceExists = pair.primary || pair.backup;
            if (!sourceExists) {
              log("保存データがありません", "warning");
              return;
            }
            const loaded = applySavePayloadWithBackup(slotId, pair, {
              announce: true,
            });
            if (loaded) {
              renderSaveSlots();
            } else {
              startNewRun(slotId);
            }
          } else if (action === "delete") {
            deleteSave(slotId);
            if (slotId === activeSaveSlotId) {
              startNewRun(slotId);
            } else {
              renderSaveSlots();
            }
          } else if (action === "export") {
            const { primary, backup } = readSlotPair(slotId);
            const source = primary || backup;
            if (!source) {
              log("エクスポートできるデータがありません", "warning");
              return;
            }
            const json = JSON.stringify(source);
            navigator.clipboard
              ?.writeText(json)
              .then(() => log("クリップボードにコピーしました", "info"))
              .catch(() => {
                log(
                  "コピーできませんでした。手動で選択してください",
                  "warning",
                );
                prompt("下記をコピーしてください", json);
              });
          }
        }

        function requestAutoSave(reason = "オートセーブ") {
          const now = Date.now();
          if (now - lastAutoSaveAt < AUTO_SAVE_COOLDOWN_MS) return;
          lastAutoSaveAt = now;
          const targetSlot = isPlayableSlot(activeSaveSlotId)
            ? activeSaveSlotId
            : "slot1";
          writeSave(targetSlot, buildSaveState(), { silent: true, reason });
          renderSaveSlots();
        }

        let lastGeneratedEquipment = null;
        let lastGeneratedPotion = null;

        function renderDebugGearPreview(item) {
          if (!debugGearPreview) return;
          debugGearPreview.innerHTML = "";
          if (!item) {
            const empty = document.createElement("div");
            empty.className = "option-label";
            empty.textContent = "プレビューがここに表示されます";
            debugGearPreview.appendChild(empty);
            return;
          }

          const title = document.createElement("div");
          title.className = "option-value";
          title.textContent = `${item.name} (${EQUIPMENT_RARITIES[item.equipment?.rarity]?.label || item.equipment?.rarityLabel || ""})`;
          applyItemRarityColor(title, item);
          debugGearPreview.appendChild(title);

          const slot = document.createElement("div");
          slot.className = "option-label";
          const slotLabel =
            EQUIPMENT_SLOTS[item.equipment?.slot]?.label ||
            item.equipment?.slot;
          slot.textContent = `部位: ${slotLabel}`;
          debugGearPreview.appendChild(slot);

          const appendList = (titleText, options) => {
            if (!options?.length) return;
            const heading = document.createElement("div");
            heading.className = "option-label";
            heading.textContent = titleText;
            debugGearPreview.appendChild(heading);
            options.forEach((opt) => {
              const row = document.createElement("div");
              row.className = "option-value";
              row.textContent = formatEquipmentValue(
                getEnhancedEntry(opt, item),
              );
              debugGearPreview.appendChild(row);
            });
          };

          const appendAffix = (label, affix, kind) => {
            if (!affix) return;
            const hasOptions = affix.options?.length;
            const effects = formatAffixEffects(affix.effects);
            if (!hasOptions && effects.length === 0) return;

            const heading = document.createElement("div");
            heading.className = "option-label";
            heading.textContent = buildTitleLabel(label, affix, kind);
            debugGearPreview.appendChild(heading);

            if (hasOptions) {
              affix.options.forEach((opt) => {
                const row = document.createElement("div");
                row.className = "option-value";
                row.textContent = formatEquipmentValue(
                  getEnhancedEntry(opt, item),
                );
                debugGearPreview.appendChild(row);
              });
            }
            effects.forEach((text) => {
              const row = document.createElement("div");
              row.className = "option-value";
              row.textContent = text;
              debugGearPreview.appendChild(row);
            });
          };

          if (item.equipment?.uniqueOptions?.length) {
            const heading = document.createElement("div");
            heading.className = "option-label";
            heading.textContent = "固有オプション";
            debugGearPreview.appendChild(heading);
            item.equipment.uniqueOptions.forEach((opt) => {
              const row = document.createElement("div");
              row.className = "option-value";
              row.textContent = `${opt.name}: ${opt.effect}`;
              debugGearPreview.appendChild(row);
            });
          }
          appendList("基礎オプション", item.equipment?.baseOptions);
          appendList("ランダムオプション", item.equipment?.randomOptions);
          appendAffix("前称号", item.equipment?.prefix, "prefix");
          appendAffix("後称号", item.equipment?.suffix, "suffix");
        }

        function resolveDebugRarity(selection) {
          if (selection === "legendary") return "legendary";
          return NON_LEGENDARY_RARITIES[
            randomInt(0, NON_LEGENDARY_RARITIES.length - 1)
          ];
        }

        function generateDebugGear({ randomRarity = false } = {}) {
          if (!debugGearSlotSelect || !debugGearRaritySelect) return null;
          const slotKey = debugGearSlotSelect.value || "weapon";
          const rarityChoice = randomRarity
            ? DEBUG_RARITY_OPTIONS[
                randomInt(0, DEBUG_RARITY_OPTIONS.length - 1)
              ]?.key
            : debugGearRaritySelect.value;
          const rarityKey = resolveDebugRarity(rarityChoice);
          const legendaryKey =
            rarityChoice === "legendary"
              ? debugLegendarySelect?.value || ""
              : "";
          const enhanceInput = Number(debugGearEnhanceInput?.value);
          const enhanceLevel = Number.isNaN(enhanceInput)
            ? 0
            : Math.max(
                0,
                Math.min(MAX_ENHANCE_LEVEL, Math.floor(enhanceInput)),
              );
          if (debugGearEnhanceInput) debugGearEnhanceInput.value = enhanceLevel;
          const item = createEquipmentItem(slotKey, rarityKey, {
            legendaryKey,
            enhanceLevel,
          });
          lastGeneratedEquipment = item;
          registerCodexDiscovery(item);
          player.inventory.items.push(item);
          log(`🛠️ ${item.name} を生成しインベントリへ追加`, "info");
          renderInventory();
          renderDebugGearPreview(item);
          return item;
        }

        function openDebugModal() {
          switchDebugTab("status");
          debugModal?.classList.remove("hidden");
        }

        function closeDebugModal() {
          debugModal?.classList.add("hidden");
        }

        function renderEnemies() {
          const wrapper = document.getElementById("enemies");
          if (!wrapper) return;

          // ★安全化：enemies が消えていても落ちない & ついでに復元
          if (!Array.isArray(game.enemies)) game.enemies = [];
          const enemies = game.enemies;
                  
          // ★ いま画面上にある .enemy-card を全部拾っておく
          const existing = new Map(
            Array.from(wrapper.querySelectorAll(".enemy-card")).map((card) => [
              card.dataset.enemyId,
              card,
            ]),
          );
          const used = new Set();

          function createEnemyCard(enemy) {
            const card = document.createElement("div");
            card.className = "enemy-card";
            card.dataset.enemyId = String(enemy.id);
            card.setAttribute("role", "button");
            card.setAttribute("aria-label", `${enemy.name} の詳細`);

            const header = document.createElement("div");
            header.className = "row";

            const info = document.createElement("div");
            info.className = "enemy-info";

            const nameRow = document.createElement("div");
            nameRow.className = "enemy-name-row";
            const titleLabel = document.createElement("span");
            titleLabel.className = "enemy-name";
            const archetype = document.createElement("span");
            archetype.className = "tag clickable";
            nameRow.appendChild(titleLabel);
            nameRow.appendChild(archetype);

            info.appendChild(nameRow);
            header.appendChild(info);

            const bar = document.createElement("div");
            bar.className = "enemy-bar";
            bar.addEventListener("animationend", (event) => {
              if (event.animationName === "barPulse")
                bar.classList.remove("pulse");
            });
            const fill = document.createElement("span");
            fill.className = "fill";
            const hpLabel = document.createElement("span");
            hpLabel.className = "label";
            bar.appendChild(fill);
            bar.appendChild(hpLabel);
            card.appendChild(header);
            card.appendChild(bar);

            const bossOrnament = document.createElement("div");
            bossOrnament.className = "boss-ornament";
            bossOrnament.innerHTML = `
              <span class="boss-line"></span>
              <span class="boss-crest"><span class="icon">👑</span>BOSS</span>
              <span class="boss-line"></span>
            `;
            card.appendChild(bossOrnament);

            const retryToggle = document.createElement("label");
            retryToggle.className = "boss-retry-toggle";
            retryToggle.title = "ボス撃破後に再挑戦するか切り替え";
            const retryCheckbox = document.createElement("input");
            retryCheckbox.type = "checkbox";
            retryCheckbox.checked = !!game.bossRetryEnabled;
            const retryLabel = document.createElement("span");
            retryLabel.textContent = "再挑戦する";
            retryToggle.appendChild(retryCheckbox);
            retryToggle.appendChild(retryLabel);
            retryToggle.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            retryCheckbox.addEventListener("change", (event) => {
              event.stopPropagation();
              game.bossRetryEnabled = !!retryCheckbox.checked;
              updateUI();
              maybeAutoSave("ボス再挑戦切替");
            });
            card.appendChild(retryToggle);

            card._refs = {
              titleLabel,
              archetype,
              bar,
              fill,
              hpLabel,
              retryToggle,
              retryCheckbox,
              bossOrnament,
              //legendarySection,
            };
            return card;
          }

          function updateEnemyCard(card, enemy, index) {
            const refs = card._refs || {};
            card.dataset.enemyId = String(enemy.id);
            card.onclick = () => openEnemyModal(enemy);
            card.classList.toggle("defeated", enemy.hp <= 0);

            card.classList.toggle("boss-card", enemy.isBoss);

            if (refs.bossOrnament) {
              refs.bossOrnament.style.display = enemy.isBoss ? "flex" : "none";
            }

            if (refs.titleLabel) {
              refs.titleLabel.textContent = `${enemy.isBoss ? "👑" : "👾"} ${enemy.name}`;
            }

            if (refs.archetype) {
              const hasArchetype = Boolean(
                enemy.archetypes?.length && !enemy.isBoss,
              );
              refs.archetype.style.display = hasArchetype
                ? "inline-flex"
                : "none";
              refs.archetype.textContent = hasArchetype
                ? enemy.archetypeLabel || "アーキ"
                : "";
              refs.archetype.onclick = hasArchetype
                ? (event) => {
                    event.stopPropagation();
                    openArchetypeModal(enemy);
                  }
                : null;
            }

            const floorNumber = Math.max(1, Math.floor(game.floor || 1));

            if (refs.retryToggle) {
              const canShowRetry = enemy.isBoss;
              refs.retryToggle.style.display = canShowRetry ? "inline-flex" : "none";
              if (refs.retryCheckbox) {
                refs.retryCheckbox.checked = !!game.bossRetryEnabled;
              }
            }

            const roundedHp = roundBattleValue(enemy.hp);
            const roundedMaxHp = Math.max(1, roundBattleValue(enemy.maxHp));
            const hpPct = Math.max(
              0,
              Math.floor((roundedHp / roundedMaxHp) * 100),
            );
            if (refs.fill) {
              refs.fill.style.width = `${hpPct}%`;
            }
            if (refs.hpLabel) {
              refs.hpLabel.textContent = `${roundedHp} / ${roundedMaxHp} (${hpPct}%)`;
            }

            if (refs.legendarySection && refs.legendaryList) {
              const dropInfo = BOSS_LEGENDARY_DROPS[game.floor];
              const pool =
                (enemy.bossLegendaryPool && enemy.bossLegendaryPool.length
                  ? enemy.bossLegendaryPool
                  : dropInfo?.legendaryKeys || []).filter(Boolean);
              if (enemy.isBoss && pool.length) {
                refs.legendarySection.style.display = "";
                refs.legendaryList.innerHTML = "";
                const killRow = document.createElement("div");
                killRow.className = "legendary-record-row";
                const killLabel = document.createElement("div");
                killLabel.className = "option-label";
                killLabel.textContent = "討伐数";
                const killValue = document.createElement("div");
                killValue.className = "option-value";
                killValue.textContent = `${getBossKillCount(enemy)}回`;
                killRow.appendChild(killLabel);
                killRow.appendChild(killValue);
                refs.legendaryList.appendChild(killRow);
                pool.forEach((key) => {
                  const row = document.createElement("div");
                  row.className = "legendary-record-row";
                  const template = getLegendaryTemplateByKey(key);
                  const record = game.legendaryRecords?.[key];
                  const name = template?.name || key;
                  const count = record?.drops ?? 0;
                  const header = document.createElement("div");
                  header.className = "option-label";
                  header.textContent = `${name} / ドロップ ${count}回`;
                  row.appendChild(header);

                  const details = document.createElement("div");
                  details.className = "option-value";
                  const uniqueText = template?.unique?.effect
                    ? `${template.unique.name} / ${template.unique.effect}`
                    : "固有効果不明";
                  const baseText = (template?.base || [])
                    .map((opt) => formatOptionRangeForCodex(opt))
                    .filter(Boolean)
                    .join(" / ");
                  details.textContent = `${uniqueText}｜${baseText || "基礎情報なし"}`;
                  row.appendChild(details);
                  refs.legendaryList.appendChild(row);
                });
              } else {
                refs.legendarySection.style.display = "none";
              }
            }
          }

          // ★ ここが重要：wrapper.innerHTML = "" で全消ししない！
          // 既存カードを再利用しつつ、足りない分だけ新規作成
          enemies.forEach((enemy, index) => {
            const id = String(enemy.id);
            let card = existing.get(id);
            if (!card) {
              card = createEnemyCard(enemy);
              wrapper.appendChild(card);
            }
            updateEnemyCard(card, enemy, index);
            used.add(id);
          });

          // もういない敵のカードだけ片付ける
          existing.forEach((card, id) => {
            if (!used.has(id)) card.remove();
          });

          syncEnemyHighlight();
        }

        function renderActions() {
          const container = document.getElementById("actions");
          container.innerHTML = "";
          const enemiesAlive = game.enemies.some((e) => e.hp > 0);
          const battleInProgress =
            game.awaitingInput || enemiesAlive || game.turnQueue?.length > 0;
          const victoryAchieved = !enemiesAlive && !battleInProgress;
          const canAct = game.awaitingInput && enemiesAlive && player.hp > 0;
          const skillSlots = player.activeSkillSlots || [];

          const row = document.createElement("div");
          row.className = "actions-row";

          const createAutoSkillToggle = () => {
            const toggleWrapper = document.createElement("div");
            toggleWrapper.className = "action-button-wrapper";
            const toggle = document.createElement("button");
            toggle.className = "main-action action-card auto-skill-toggle";
            const isOn = !!game.autoSkillEnabled;
            toggle.classList.toggle("is-on", isOn);
            toggle.setAttribute("aria-pressed", String(isOn));
            toggle.title =
              "こうげきボタンでスキル1から順番に自動使用します (使用不可時は通常攻撃)";
            toggle.onclick = () => {
              game.autoSkillEnabled = !game.autoSkillEnabled;
              renderActions();
              maybeAutoSave("自動スキル切替");
            };

            const label = document.createElement("div");
            label.className = "auto-skill-label";
            label.textContent = "自動スキル";

            const state = document.createElement("div");
            state.className = "auto-skill-state";
            const autoSkillStateText = (() => {
              if (!isOn) return "OFF: 手動のみ";
              const slots = player.activeSkillSlots || [];
              for (let i = 0; i < slots.length; i += 1) {
                const availability = canUseActiveSkill(i, {
                  suppressWarnings: true,
                });
                if (availability.canUse) {
                  return `ON: 次スキル${i + 1}`;
                }
              }
              return "ON: こうげき";
            })();
            state.textContent = autoSkillStateText;

            toggle.appendChild(label);
            toggle.appendChild(state);
            toggleWrapper.appendChild(toggle);
            return toggleWrapper;
          };

          const escapeWrapper = document.createElement("div");
          escapeWrapper.className = "action-button-wrapper";
          const escapeBtn = document.createElement("button");
          escapeBtn.classList.add("main-action");
          escapeBtn.textContent = "🏃 にげる";
          escapeBtn.disabled = !canAct;
          escapeBtn.onclick = attemptEscape;
          escapeWrapper.appendChild(escapeBtn);
          row.appendChild(escapeWrapper);

          (player.potions || []).forEach((potion, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "action-button-wrapper";

            const potionBtn = document.createElement("button");
            potionBtn.className = "potion-button main-action action-card";
            potionBtn.onclick = () => usePotion(index);
            const { useCost } = calculatePotionConsumption(potion);
            const maxFullness = potion.maxFullness ?? 100;
            potion.fullness = Math.max(
              0,
              Math.min(maxFullness, potion.fullness ?? maxFullness),
            );
            const resourceFull =
              potion.type === "hp"
                ? player.hp >= player.maxHp
                : potion.type === "mp"
                  ? player.mp >= player.maxMp
                  : false;

            const header = document.createElement("div");
            header.className = "action-top";

            const icon = document.createElement("div");
            icon.className = "potion-icon";
            icon.textContent = potion.icon || "🧪";

            const fill = document.createElement("div");
            fill.className = "potion-fill";
            fill.textContent = `${Math.round(potion.fullness)}% / ${maxFullness}%`;

            const infoChip = document.createElement("span");
            infoChip.className = "info-chip";
            infoChip.textContent = "i";
            infoChip.title = "ポーション詳細";
            infoChip.tabIndex = 0;
            infoChip.setAttribute("role", "button");
            infoChip.setAttribute("aria-label", "ポーション詳細を表示");
            infoChip.onclick = (event) => {
              event.stopPropagation();
              event.preventDefault();
              openPotionModal(potion);
            };
            infoChip.onkeydown = (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                event.stopPropagation();
                openPotionModal(potion);
              }
            };

            // ★ ここからレイアウト部分だけ修正
            const top = document.createElement("div");
            top.className = "action-top";
            top.appendChild(icon);
            top.appendChild(infoChip);

            // header はもう使わない
            potionBtn.appendChild(top); // icon + info
            potionBtn.appendChild(fill); // その外に fill

            potionBtn.title = `${potion.short || potion.name} (${useCost}%消費)`;
            potionBtn.disabled =
              !canAct || potion.fullness < useCost || resourceFull;
            applyItemRarityColor(potionBtn, { potion });
            wrapper.appendChild(potionBtn);
            row.appendChild(wrapper);
          });

          skillSlots.forEach((slot, index) => {
            const skill = slot.skillKey ? skills[slot.skillKey] : null;
            const wrapper = document.createElement("div");
            wrapper.className = "action-button-wrapper skill-row";

            const skillBtn = document.createElement("button");
            skillBtn.className = "skill-button main-action action-card";
            const remaining = Math.max(0, slot.cooldownRemaining || 0);
            const ready = remaining <= 0;
            const baseCooldown = skill
              ? getEffectiveSkillCooldown(skill)
              : null;
            const mpCost = skill?.activation?.mpCost ?? 0;
            skillBtn.disabled = skill ? !canAct || !ready : false;
            skillBtn.title = skill
              ? skill.activation?.effect
                ? `${skill.activation.effect} / CT: ${skill.activation.cooldown || "--"}T / MP: ${mpCost}`
                : "セットしたスキル"
              : "スキル未セット";
            skillBtn.onclick = () => {
              if (!skill) {
                openSkillsModal();
                return;
              }
              useActiveSkill(index);
            };

            const header = document.createElement("div");
            header.className = "action-top";

            const meta = document.createElement("div");
            meta.className = "skill-meta";

            const name = document.createElement("div");
            name.className = "skill-name";
            name.textContent = skill ? skill.name : "スキル未セット";

            const status = document.createElement("div");
            status.className = "skill-status";
            const cooldownInfo = skill
              ? ready
                ? baseCooldown !== null
                  ? `CT${baseCooldown}`
                  : ""
                : `残${remaining}`
              : "";
            status.textContent = skill
              ? [`MP${mpCost}`, cooldownInfo].filter(Boolean).join(" / ") ||
                "MP--"
              : "タップでセット";

            meta.appendChild(name);
            meta.appendChild(status);

            const infoChip = document.createElement("span");
            infoChip.className = "info-chip";
            infoChip.textContent = "i";
            infoChip.title = "スキル詳細";
            infoChip.tabIndex = 0;
            infoChip.setAttribute("role", "button");
            infoChip.setAttribute("aria-label", "スキル詳細を表示");
            infoChip.onclick = (event) => {
              event.stopPropagation();
              event.preventDefault();
              if (skill) {
                openSkillInfoModal(skill);
              } else {
                openSkillsModal();
              }
            };
            infoChip.onkeydown = (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                event.stopPropagation();
                if (skill) {
                  openSkillInfoModal(skill);
                } else {
                  openSkillsModal();
                }
              }
            };

            header.appendChild(meta);
            header.appendChild(infoChip);

            skillBtn.appendChild(header);

            wrapper.appendChild(skillBtn);
            row.appendChild(wrapper);

            if (index === 1) {
              row.appendChild(createAutoSkillToggle());
            }
          });

          if (skillSlots.length < 2) {
            row.appendChild(createAutoSkillToggle());
          }

          const wrapper = document.createElement("div");
          wrapper.className = "action-button-wrapper";
          const btn = document.createElement("button");
          btn.classList.add("main-action");
          const playerAttacks = Math.max(
            0,
            player.attacksRemaining ?? player.attackCount ?? 0,
          );

          if (player.hp <= 0) {
            btn.textContent = "戦闘不能";
            btn.disabled = true;
          } else if (!enemiesAlive) {
            const retryBoss =
              isBossFloor(game.floor) && !!game.bossRetryEnabled;
            if (retryBoss) {
              btn.textContent = "再挑戦";
              btn.onclick = retryBossFloor;
            } else {
              btn.textContent = "次の階層へ";
              btn.onclick = nextFloor;
            }
          } else {
            btn.textContent = "⚔️ こうげき";
            btn.disabled = !canAct;
            btn.onclick = playerAttack;
          }
          wrapper.appendChild(btn);
          if (player.hp > 0 && enemiesAlive) {
            const attackBadge = document.createElement("div");
            attackBadge.className = "attack-badge";
            attackBadge.textContent = `x${playerAttacks}`;
            const targetsPerAttack = Math.max(
              1,
              Math.floor(player.attackTargets ?? 1),
            );
            attackBadge.title = `1ターンあたりの攻撃回数 / 同時攻撃対象: ${targetsPerAttack}体`;
            wrapper.appendChild(attackBadge);
          }
          row.appendChild(wrapper);
          container.appendChild(row);
        }

        function renderSecondaryStats(derived) {
          const container = document.getElementById("secondary-stats");
          container.innerHTML = "";
          const rows = SECONDARY_STAT_DEFS.map((def) => ({
            label: def.label,
            value:
              def.key === "attackCount"
                ? player.attackCount
                : def.key === "attackTargets"
                  ? player.attackTargets
                  : derived[def.key]?.total ?? 0,
            unit: def.unit,
          }));

          rows.forEach((row) => {
            const el = document.createElement("div");
            el.className = "stat-row";
            const left = document.createElement("div");
            left.className = "stat-label secondary";
            left.innerHTML = `<span>${row.label}</span>`;
            const right = document.createElement("div");
            right.className = "stat-value";
            const rendered = formatStatValue(row.value, row.unit || "");
            right.innerHTML = rendered;
            el.appendChild(left);
            el.appendChild(right);
            container.appendChild(el);
          });
        }

        function adjustPrimary(key, delta) {
          if (delta === 0) return;
          if (delta > 0) {
            const use = Math.min(delta, player.statPoints);
            if (use <= 0) return;
            player.statPoints -= use;
            player.primary[key].base += use;
            player.allocations[key] += use;
            log(`能力Pを使用: ${player.primary[key].label} +${use}`, "good");
          } else {
            const refundable = player.allocations[key];
            const giveBack = Math.min(refundable, Math.abs(delta));
            if (giveBack <= 0) return;
            player.primary[key].base -= giveBack;
            player.allocations[key] -= giveBack;
            player.statPoints += giveBack;
            log(
              `能力Pを返却: ${player.primary[key].label} -${giveBack}`,
              "info",
            );
          }
          updateUI();
          maybeAutoSave("ステータス調整");
        }

        function getAdjustStep() {
          return stepOptions[currentStepIndex];
        }

        function updateStepButton() {
          if (!statStepButton) return;
          const step = getAdjustStep();
          statStepButton.textContent = `±${step}`;
          statStepButton.title = `増減幅 ${step}`;
        }

        function getSkillAdjustStep() {
          return skillStepOptions[currentSkillStepIndex];
        }

        function updateSkillStepButton() {
          if (!skillStepButton) return;
          const step = getSkillAdjustStep();
          skillStepButton.textContent = `±${step}`;
          skillStepButton.title = `スキル増減幅 ${step}`;
        }

        function renderPrimaryStats() {
          const container = document.getElementById("primary-stats");
          container.innerHTML = "";
          const step = getAdjustStep();

          primaryOrder.forEach((key) => {
            const stat = player.primary[key];
            const row = document.createElement("div");
            row.className = "stat-row primary-row";

            const info = document.createElement("div");
            info.className = "primary-info";

            const label = document.createElement("div");
            label.className = "stat-label inline";
            label.textContent = stat.label;

            const value = document.createElement("div");
            value.className = "stat-value";
            value.innerHTML = formatPrimaryValue(stat);

            info.appendChild(label);
            info.appendChild(value);

            const actions = document.createElement("div");
            actions.className = "primary-actions";

            const inc = document.createElement("button");
            inc.textContent = `+${step}`;
            inc.classList.add("mini-btn");
            inc.disabled = player.statPoints <= 0;
            inc.title = `${step}ポイント増加`;
            inc.onclick = () => adjustPrimary(key, step);

            const dec = document.createElement("button");
            dec.textContent = `-${step}`;
            dec.classList.add("mini-btn");
            dec.disabled = player.allocations[key] <= 0;
            dec.title = `${step}ポイント減少`;
            dec.onclick = () => adjustPrimary(key, -step);

            actions.appendChild(inc);
            actions.appendChild(dec);

            row.appendChild(info);
            row.appendChild(actions);
            container.appendChild(row);
          });
        }

        function renderEquipmentList() {
          if (!playerEquipmentList) return;
          playerEquipmentList.innerHTML = "";

          EQUIPMENT_SLOT_ORDER.forEach((slotKey) => {
            const slotLabel = PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey;
            const row = document.createElement("div");
            row.className = "equipment-row";

            const slot = document.createElement("div");
            slot.className = "equipment-slot-label";
            slot.textContent = slotLabel;
            row.appendChild(slot);

            const body = document.createElement("div");
            body.className = "equipment-body";
            const equipment = normalizeEquipmentItem(
              player.equipment?.[slotKey],
            );

            if (equipment?.equipment) {
              const nameRow = document.createElement("div");
              nameRow.className = "equipment-name";
              const label = document.createElement("span");
              label.textContent = equipment.name;
              applyItemRarityColor(label, equipment);
              nameRow.appendChild(label);
              const badge = createEnhanceBadge(equipment, {
                includeZero: true,
              });
              if (badge) nameRow.appendChild(badge);
              body.appendChild(nameRow);

              const optionList = document.createElement("div");
              optionList.className = "equipment-option-list compact";

              const appendOptions = (title, options) => {
                if (!options?.length) return;
                const heading = document.createElement("div");
                heading.className = "option-label";
                heading.textContent = title;
                optionList.appendChild(heading);
                options.forEach((opt) => {
                  const line = document.createElement("div");
                  line.className = "option-value";
                  line.textContent = formatEquipmentValue(
                    getEnhancedEntry(opt, equipment),
                  );
                  optionList.appendChild(line);
                });
              };

              const appendAffix = (title, affix) => {
                if (!affix) return;
                const hasOptions = affix.options?.length;
                const effects = formatAffixEffects(affix.effects);
                if (!hasOptions && effects.length === 0) return;
                const heading = document.createElement("div");
                heading.className = "option-label";
                heading.textContent = title;
                optionList.appendChild(heading);
                if (hasOptions) {
                  affix.options.forEach((opt) => {
                    const line = document.createElement("div");
                    line.className = "option-value";
                    line.textContent = formatEquipmentValue(
                      getEnhancedEntry(opt, equipment),
                    );
                    optionList.appendChild(line);
                  });
                }
                effects.forEach((text) => {
                  const line = document.createElement("div");
                  line.className = "option-value";
                  line.textContent = text;
                  optionList.appendChild(line);
                });
              };

              if (equipment.equipment.uniqueOptions?.length) {
                const heading = document.createElement("div");
                heading.className = "option-label";
                heading.textContent = "固有";
                optionList.appendChild(heading);
                equipment.equipment.uniqueOptions.forEach((opt) => {
                  const line = document.createElement("div");
                  line.className = "option-value";
                  line.textContent = `${opt.name}: ${opt.effect}`;
                  optionList.appendChild(line);
                });
              }

              appendOptions("基礎", equipment.equipment.baseOptions);
              appendOptions("ランダム", equipment.equipment.randomOptions);
              appendAffix(
                buildTitleLabel(
                  "前称号",
                  equipment.equipment.prefix,
                  "prefix",
                ),
                equipment.equipment.prefix,
              );
              appendAffix(
                buildTitleLabel(
                  "後称号",
                  equipment.equipment.suffix,
                  "suffix",
                ),
                equipment.equipment.suffix,
              );

              if (optionList.childElementCount > 0) {
                body.appendChild(optionList);
              }
            } else {
              const empty = document.createElement("div");
              empty.className = "equipment-empty";
              empty.textContent = "未装備";
              body.appendChild(empty);
            }

            row.appendChild(body);
            playerEquipmentList.appendChild(row);
          });
        }

        function renderEquipmentBonusSummary() {
          if (!equipmentBonusSummary) return;
          equipmentBonusSummary.innerHTML = "";
          const { primary, secondary } = collectEquipmentBonuses();
          const rows = [];

          primaryOrder.forEach((key) => {
            const value = primary?.[key] ?? 0;
            if (!value) return;
            rows.push({
              label: player.primary?.[key]?.label || key.toUpperCase(),
              value,
              unit: "",
            });
          });

          SECONDARY_STAT_DEFS.forEach((def) => {
            const value = secondary?.[def.key] ?? 0;
            if (!value) return;
            rows.push({ label: def.label, value, unit: def.unit || "" });
          });

          const formatValue = (value, unit = "") => {
            const isPercent = unit === "%";
            const total = displayNumber(value, { isPercent });
            const sign = value >= 0 ? "+" : "";
            return `<span class="total">${sign}${total}${unit}</span>`;
          };

          if (!rows.length) {
            const empty = document.createElement("div");
            empty.className = "help-panel";
            empty.textContent = "装備によるステータス加算はありません";
            equipmentBonusSummary.appendChild(empty);
            return;
          }

          rows.forEach((row) => {
            const el = document.createElement("div");
            el.className = "stat-row";
            const left = document.createElement("div");
            left.className = "stat-label secondary";
            left.textContent = row.label;
            const right = document.createElement("div");
            right.className = "stat-value";
            right.innerHTML = formatValue(row.value, row.unit);
            el.appendChild(left);
            el.appendChild(right);
            equipmentBonusSummary.appendChild(el);
          });
        }

        function renderEquipmentOverview() {
          renderEquipmentList();
          renderEquipmentBonusSummary();
        }

        function setPlayerModalPage(page) {
          playerModalPage = page === "equipment" ? "equipment" : "status";
          const isEquipment = playerModalPage === "equipment";
          playerStatusView?.classList.toggle("hidden", isEquipment);
          playerEquipmentView?.classList.toggle("hidden", !isEquipment);
          playerModalStatusButton?.classList.toggle("active", !isEquipment);
          playerModalEquipmentButton?.classList.toggle("active", isEquipment);
          if (isEquipment) {
            renderEquipmentOverview();
          }
        }

        function getActiveSkillSlotIndex(skillKey) {
          return player.activeSkillSlots.findIndex(
            (slot) => slot.skillKey === skillKey,
          );
        }

        function isSkillUnlocked(skill) {
          if (!skill) return false;
          if (!Array.isArray(player.unlockedSkillKeys) || !player.unlockedSkillKeys.length) {
            player.unlockedSkillKeys = Array.from(
              calculatePassiveTreeEffects().unlockedSkills,
            );
          }
          return new Set(player.unlockedSkillKeys).has(skill.key);
        }

        function toggleActiveSkillSlot(skillKey) {
          const skill = skills[skillKey];
          if (!skill || skill.type !== "active") return;
          if (!isSkillUnlocked(skill)) {
            log("パッシブツリーで解放が必要です", "warning");
            return;
          }
          if (skill.level <= 0) {
            log("スキルを習得してからセットしてください", "warning");
            return;
          }
          const assignedIndex = getActiveSkillSlotIndex(skillKey);
          if (assignedIndex >= 0) {
            player.activeSkillSlots[assignedIndex] = {
              skillKey: null,
              cooldownRemaining: 0,
            };
            log(
              `🗑 ${skill.name}をスロット${assignedIndex + 1}から解除`,
              "info",
            );
            renderActiveSkillLoadout();
            renderActions();
            return;
          }
          const emptyIndex = player.activeSkillSlots.findIndex(
            (slot) => !slot.skillKey,
          );
          if (emptyIndex === -1) {
            log(
              `セット枠が空いていません (最大${ACTIVE_SKILL_SLOT_LIMIT}枠)`,
              "warning",
            );
            return;
          }
          player.activeSkillSlots[emptyIndex] = {
            skillKey,
            cooldownRemaining: 0,
          };
          log(`✨ ${skill.name}をスロット${emptyIndex + 1}にセット`, "good");
          renderActiveSkillLoadout();
          renderActions();
        }

        function getEffectiveSkillCooldown(skill) {
          const derived = lastDerivedStats || recalcDerivedStats();
          const baseCooldown = Math.max(0, skill?.activation?.cooldown ?? 0);
          if (baseCooldown <= 0) return 0;
          const reduction = Math.max(0, derived?.cooldown?.total ?? 0);
          const scaled = Math.round(baseCooldown * (1 - reduction / 100));
          return Math.max(1, scaled);
        }

        function renderSkillThresholds(skill, { locked = false } = {}) {
          const wrapper = document.createElement("div");
          wrapper.className = "help-panel";
          const label = document.createElement("div");
          label.className = "option-label";
          label.textContent = "閾値効果 (10 / 30 / 50)";
          wrapper.appendChild(label);

          if (locked) {
            const row = document.createElement("div");
            row.className = "option-value";
            row.textContent = "？？？";
            wrapper.appendChild(row);
          } else {
            (skill.thresholds || []).forEach((threshold) => {
              const row = document.createElement("div");
              row.className = "option-value";
              const reached = (skill.reachedThresholds || []).some(
                (t) => t.level === threshold.level,
              );
              const detail =
                threshold.effect || formatSkillBonusText(threshold.bonus);
              row.textContent = `${threshold.level}Lv: ${detail || "効果未設定"}${reached ? " (達成)" : ""}`;
              if (reached) row.style.color = "#34d399";
              wrapper.appendChild(row);
            });
          }

          return wrapper;
        }

        function describeSkillScaling(skill, { locked = false } = {}) {
          if (locked) return "毎Lv: ？？？";
          if (!skill.scaling?.perLevel) return "毎Lv効果なし";
          const text = formatSkillBonusText(skill.scaling.perLevel);
          const boost = Math.max(1, getSkillGrowthMultiplier(skill.level || 1));
          const boostText = boost > 1 ? ` (成長倍率x${boost.toFixed(2)})` : "";
          return text ? `毎Lv: ${text}${boostText}` : "毎Lv効果なし";
        }

        function adjustSkillLevel(key, delta) {
          const skill = skills[key];
          if (!skill || delta === 0) return;
          if (delta > 0) {
            if (!isSkillUnlocked(skill)) {
              log("パッシブツリーで解放が必要です", "warning");
              return;
            }
            const spendable = Math.min(
              delta,
              player.skillPoints,
              skill.max - skill.level,
            );
            if (spendable <= 0) return;
            player.skillPoints -= spendable;
            skill.level += spendable;
            log(
              `スキル『${skill.name}』を強化 (+${spendable}) (${skill.level}/${skill.max})`,
              "good",
            );
          } else {
            const refundable = Math.min(skill.level, Math.abs(delta));
            if (refundable <= 0) return;
            skill.level -= refundable;
            player.skillPoints += refundable;
            log(
              `スキル『${skill.name}』を減少 (-${refundable}) (${skill.level}/${skill.max})`,
              "info",
            );
          }
          calculateSkillBonuses();
          const derived = recalcDerivedStats();
          updateUI(derived);
          maybeAutoSave(delta > 0 ? "スキルレベルアップ" : "スキル調整");
        }

        function renderActiveSkillLoadout() {
          const container = document.getElementById("active-skill-loadout");
          if (!container) return;
          container.innerHTML = "";

          const title = document.createElement("div");
          title.className = "option-label";
          title.textContent = `アクティブスキル枠 (${ACTIVE_SKILL_SLOT_LIMIT}枠までセット可)`;
          container.appendChild(title);

          player.activeSkillSlots.forEach((slot, index) => {
            const skill = slot.skillKey ? skills[slot.skillKey] : null;
            const row = document.createElement("div");
            row.className = "option-value";
            const cooldownText = skill?.activation?.cooldown
              ? ` / CT: ${skill.activation.cooldown}T`
              : "";
            const remaining = slot.cooldownRemaining
              ? ` / 残り: ${slot.cooldownRemaining}T`
              : "";
            row.textContent = `スロット${index + 1}: ${skill ? skill.name : "未セット"}${skill ? `${cooldownText}${remaining}` : ""}`;
            if (skill?.activation?.effect) {
              const detail = document.createElement("div");
              detail.className = "subtle";
              detail.textContent = `効果: ${skill.activation.effect}`;
              row.appendChild(detail);
            }
            container.appendChild(row);
          });
        }

        function renderSkillCategoryTabs() {
          const container = document.getElementById("skill-category-tabs");
          if (!container) return;
          container.innerHTML = "";
          SKILL_CATEGORIES.forEach((category) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "tab-button";
            const isActive = category === selectedSkillCategory;
            if (isActive) btn.classList.add("active");
            btn.textContent = category;
            btn.setAttribute("aria-pressed", isActive ? "true" : "false");
            btn.onclick = () => {
              selectedSkillCategory = category;
              renderSkills();
            };
            container.appendChild(btn);
          });
        }

        function renderSkillTypeTabs() {
          const container = document.getElementById("skill-type-tabs");
          if (!container) return;
          container.innerHTML = "";
          [
            { key: "active", label: "アクティブ" },
            { key: "passive", label: "パッシブ" },
          ].forEach((type) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "tab-button";
            const isActive = type.key === selectedSkillType;
            if (isActive) btn.classList.add("active");
            btn.textContent = type.label;
            btn.setAttribute("aria-pressed", isActive ? "true" : "false");
            btn.onclick = () => {
              selectedSkillType = type.key;
              renderSkills();
            };
            container.appendChild(btn);
          });
        }

        function renderSkillDetailList() {
          const container = document.getElementById("skills");
          if (!container) return;
          container.innerHTML = "";
          const step = getSkillAdjustStep();

          const section = document.createElement("div");
          const header = document.createElement("div");
          header.className = "section-title";
          const typeLabel =
            selectedSkillType === "active" ? "アクティブ" : "パッシブ";
          header.textContent = `${selectedSkillCategory} / ${typeLabel}`;
          section.appendChild(header);

          const filteredSkills = Object.entries(skills)
            .filter(
              ([, skill]) =>
                skill.category === selectedSkillCategory &&
                skill.type === selectedSkillType,
            )
            .sort((a, b) => a[1].name.localeCompare(b[1].name, "ja"));

          filteredSkills.forEach(([key, skill]) => {
            const locked = !isSkillUnlocked(skill);
            const row = document.createElement("div");
            row.className = "card";
            row.style.marginBottom = "6px";

            const headerRow = document.createElement("div");
            headerRow.className = "inline-buttons";
            headerRow.style.justifyContent = "space-between";

            const name = document.createElement("div");
            name.className = "stat-label inline";
            name.textContent = `${locked ? "？？？" : skill.name} (${skill.level}/${skill.max})`;

            const meta = document.createElement("div");
            meta.className = "pill";
            meta.textContent = `${skill.category} / ${skill.type === "active" ? "アクティブ" : "パッシブ"} / ${locked ? "未解放" : "解放済"}`;

            headerRow.appendChild(name);
            headerRow.appendChild(meta);
            row.appendChild(headerRow);

            const desc = document.createElement("div");
            desc.className = "subtle";
            desc.textContent = locked ? "？？？" : skill.desc;
            row.appendChild(desc);

            const scaling = document.createElement("div");
            scaling.className = "subtle";
            scaling.textContent = describeSkillScaling(skill, { locked });
            row.appendChild(scaling);

            const currentBonus = document.createElement("div");
            currentBonus.className = "subtle";
            currentBonus.textContent = describeSkillBonusAtLevel(
              skill,
              skill.level,
              { locked },
            );
            row.appendChild(currentBonus);

            const nextBonus = document.createElement("div");
            nextBonus.className = "subtle";
            nextBonus.textContent = describeSkillNextBonus(skill, { locked });
            row.appendChild(nextBonus);

            if (skill.type === "active") {
              const activation = document.createElement("div");
              activation.className = "subtle";
              const cooldownText = skill.activation?.cooldown
                ? `${skill.activation.cooldown}T`
                : "--";
              const mpCostText =
                skill.activation?.mpCost != null
                  ? `MP${skill.activation.mpCost}`
                  : "MP--";
              const activationDetail = locked
                ? "発動: ？？？"
                : `CT: ${cooldownText} / 消費: ${mpCostText} / 効果: ${skill.activation?.effect || "未設定"}`;
              activation.textContent = activationDetail;
              row.appendChild(activation);

              const slotButton = document.createElement("button");
              slotButton.className = "mini-btn";
              const assignedIndex = getActiveSkillSlotIndex(key);
              slotButton.textContent =
                assignedIndex >= 0
                  ? `スロット${assignedIndex + 1}解除`
                  : "スロットにセット";
              slotButton.disabled = locked || skill.level <= 0;
              slotButton.onclick = () => {
                toggleActiveSkillSlot(key);
                renderSkills();
              };
              row.appendChild(slotButton);
            }

            row.appendChild(renderSkillThresholds(skill, { locked }));

            const controls = document.createElement("div");
            controls.className = "inline-buttons";
            controls.style.marginTop = "6px";

            const downBtn = document.createElement("button");
            downBtn.className = "mini-btn";
            downBtn.textContent = `-${step}`;
            downBtn.disabled = skill.level <= 0;
            downBtn.onclick = () => adjustSkillLevel(key, -step);

            const upBtn = document.createElement("button");
            upBtn.className = "mini-btn";
            upBtn.textContent = `+${step}`;
            upBtn.disabled =
              player.skillPoints <= 0 || skill.level >= skill.max || locked;
            upBtn.onclick = () => adjustSkillLevel(key, step);

            controls.appendChild(downBtn);
            controls.appendChild(upBtn);
            row.appendChild(controls);

            section.appendChild(row);
          });

          if (!filteredSkills.length) {
            const empty = document.createElement("div");
            empty.className = "option-value";
            empty.textContent = "スキルが見つかりません";
            section.appendChild(empty);
          }

          container.appendChild(section);
        }

        function renderSkillSummary() {
          const container = document.getElementById("skills-summary");
          if (!container) return;
          container.innerHTML = "";

          SKILL_CATEGORIES.forEach((category) => {
            const card = document.createElement("div");
            card.className = "card";
            card.style.marginBottom = "6px";

            const header = document.createElement("div");
            header.className = "section-title";
            header.textContent = `${category}スキル一覧`;
            card.appendChild(header);

            const list = document.createElement("div");
            list.className = "help-panel";
            list.style.marginTop = "6px";

            const categorySkills = Object.values(skills)
              .filter((skill) => skill.category === category)
              .sort((a, b) => a.name.localeCompare(b.name, "ja"));

            categorySkills.forEach((skill) => {
              const locked = !isSkillUnlocked(skill);
              const row = document.createElement("div");
              row.className = "option-value";
              const typeLabel = skill.type === "active" ? "Act" : "Pas";
              const status = locked
                ? "未解放 (ツリー)"
                : `現在${skill.level}/${skill.max}`;
              const name = locked ? "？？？" : skill.name;
              row.textContent = `・${name} (${typeLabel}) / ${status}`;
              list.appendChild(row);
            });

            card.appendChild(list);
            container.appendChild(card);
          });
        }

        function updateSkillSummaryVisibility() {
          if (skillSummaryModal) {
            skillSummaryModal.classList.toggle("hidden", !skillSummaryVisible);
          }
          if (skillSummaryToggleButton) {
            skillSummaryToggleButton.textContent = skillSummaryVisible
              ? "全職業一覧を閉じる"
              : "全職業一覧を表示";
            skillSummaryToggleButton.setAttribute(
              "aria-pressed",
              skillSummaryVisible ? "true" : "false",
            );
          }
        }

        function renderSkills() {
          updateSkillStepButton();
          renderSkillCategoryTabs();
          renderSkillTypeTabs();
          renderActiveSkillLoadout();
          renderSkillDetailList();
          renderSkillSummary();
          updateSkillSummaryVisibility();
        }

        function isItemEquipped(item) {
          if (!item) return false;
          if (item.type === "potion" && item.potion?.id) {
            return (player.potions || []).some((p) => p?.id === item.potion.id);
          }
          if (item.type === "equipment" && item.id) {
            return Object.values(player.equipment || {}).some(
              (eq) => eq?.id === item.id,
            );
          }
          return false;
        }

        function toggleInventorySortMode() {
          inventorySortMode =
            inventorySortMode === "acquire" ? "rarity" : "acquire";
          maybeAutoSave("インベントリ並び替え切替");
        }

        function getInventoryFilterLabel(key) {
          const option = INVENTORY_FILTER_OPTIONS.find(
            (opt) => opt.key === key,
          );
          return option?.label || "すべて";
        }

        function getFilteredInventoryEntries() {
          const items = player.inventory?.items || [];
          items.forEach((item) => ensureAcquiredOrder(item));
          const entries = items.map((item, index) => ({ item, index }));
          if (inventoryFilter === "all") return entries;
          if (inventoryFilter === "items")
            return entries.filter((entry) => isItemInventory(entry));
          return entries.filter(
            ({ item }) => getInventorySlotKey(item) === inventoryFilter,
          );
        }

        function renderInventoryFilters() {
          const container = document.getElementById("inventory-filters");
          if (!container) return;
          const sortLabel =
            INVENTORY_SORT_LABEL[inventorySortMode] ||
            INVENTORY_SORT_LABEL.acquire;
          container.innerHTML = "";

          INVENTORY_FILTER_OPTIONS.forEach((option) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "inventory-filter-button";
            const isSortButton = option.key === "sort";
            const isBulkSellButton = option.key === "bulkSell";
            const isActive =
              !isSortButton && !isBulkSellButton && option.key === inventoryFilter;
            if (isActive) {
              btn.classList.add("active");
            }
            btn.setAttribute("aria-pressed", isActive ? "true" : "false");
            btn.textContent = isSortButton
              ? `${option.label}: ${sortLabel}`
              : option.label;
            btn.onclick = () => {
              if (isSortButton) {
                toggleInventorySortMode();
                renderInventoryFilters();
              } else if (isBulkSellButton) {
                openBulkSellModal();
              } else {
                inventoryFilter = option.key;
                renderInventoryFilters();
              }
              if (!isBulkSellButton) renderInventory();
            };
            container.appendChild(btn);
          });
        }

        function renderInventory() {
          const container = document.getElementById("inventory-list");
          container.innerHTML = "";
          const filtered = getFilteredInventoryEntries();

          const sorted = [...filtered].sort((a, b) => {
            if (inventorySortMode === "rarity") {
              const rarityA =
                typeof a.item?.rarity === "number" ? a.item.rarity : 0;
              const rarityB =
                typeof b.item?.rarity === "number" ? b.item.rarity : 0;
              if (rarityA !== rarityB) return rarityB - rarityA;
            }
            const orderA = getAcquiredOrder(a.item, a.index);
            const orderB = getAcquiredOrder(b.item, b.index);
            return orderB - orderA;
          });

          if (sorted.length === 0) {
            const empty = document.createElement("div");
            empty.className = "help-panel";
            empty.textContent = "該当するアイテムがありません。";
            container.appendChild(empty);
            return;
          }

          sorted.forEach(({ item, index }) => {
            normalizeEquipmentItem(item);
            const row = document.createElement("button");
            row.type = "button";
            row.className = "inventory-row";
            row.onclick = () => openInventoryItemModal(item, index);

            const name = document.createElement("div");
            name.className = "name";
            if (isItemEquipped(item)) {
              const badge = document.createElement("span");
              badge.className = "equip-badge";
              badge.textContent = "[E]";
              name.appendChild(badge);
            }
            if (item.favorite) {
              const fav = document.createElement("span");
              fav.className = "favorite-badge";
              fav.textContent = "★";
              name.appendChild(fav);
            }
            const label = document.createElement("span");
            label.textContent = item?.name || "不明なアイテム";
            applyItemRarityColor(label, item);
            name.appendChild(label);
            const enhanceBadge = createEnhanceBadge(item);
            if (enhanceBadge) name.appendChild(enhanceBadge);

            row.appendChild(name);
            container.appendChild(row);
          });
        }

        function getBulkSellTargets() {
          const selectedRarities = Array.from(bulkSellSelectedRarities);
          if (!selectedRarities.length) return [];
          return getFilteredInventoryEntries().filter(({ item }) => {
            const rarityKey = getItemRarityKey(item);
            if (!rarityKey || !selectedRarities.includes(rarityKey)) return false;
            if (isItemEquipped(item)) return false;
            if (item.favorite) return false;
            return calculateItemSellValue(item) > 0;
          });
        }

        function updateBulkSellSummary() {
          const summary = document.getElementById("bulk-sell-summary");
          const executeBtn = document.getElementById("bulk-sell-execute");
          if (!summary || !executeBtn) return;
          const targets = getBulkSellTargets();
          const total = targets.reduce(
            (sum, entry) => sum + calculateItemSellValue(entry.item),
            0,
          );
          summary.innerHTML = "";
          const countSpan = document.createElement("span");
          countSpan.textContent = `対象: ${targets.length}件`;
          const totalSpan = document.createElement("span");
          totalSpan.className = "amount";
          totalSpan.innerHTML = `<span>合計</span><span>${formatGold(total)}G</span>`;
          summary.appendChild(countSpan);
          summary.appendChild(totalSpan);
          executeBtn.disabled = targets.length === 0 || total <= 0;
        }

        function renderBulkSellRarityList() {
          const container = document.getElementById("bulk-sell-rarity-list");
          const filterLabel = document.getElementById("bulk-sell-filter-label");
          if (!container || !filterLabel) return;
          container.innerHTML = "";
          filterLabel.textContent = `表示: ${getInventoryFilterLabel(
            inventoryFilter,
          )}`;

          BULK_SELL_RARITY_ORDER.forEach((key) => {
            const rarity =
              EQUIPMENT_RARITIES[key] || POTION_RARITIES[key] || { label: key };
            const row = document.createElement("div");
            row.className = "bulk-sell-rarity-item";

            const mainLabel = document.createElement("label");
            mainLabel.className = "bulk-sell-rarity-main";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = bulkSellSelectedRarities.has(key);
            checkbox.onchange = () => {
              if (checkbox.checked) {
                bulkSellSelectedRarities.add(key);
              } else {
                bulkSellSelectedRarities.delete(key);
              }
              updateBulkSellSummary();
            };

            const texts = document.createElement("div");
            texts.style.display = "flex";
            texts.style.flexDirection = "column";
            const label = document.createElement("span");
            label.className = "label";
            label.textContent = rarity.label || key;
            applyItemRarityColor(label, { equipment: { rarity: key } });
            const desc = document.createElement("span");
            desc.className = "desc";
            desc.textContent = `${SELL_VALUE_BY_RARITY[key] ?? 0}G / 基本価値`;
            texts.appendChild(label);
            texts.appendChild(desc);

            mainLabel.appendChild(checkbox);
            mainLabel.appendChild(texts);

            const actions = document.createElement("div");
            actions.className = "bulk-sell-rarity-actions";

            const notifyLabel = document.createElement("label");
            notifyLabel.className = "bulk-sell-rarity-action";
            const notifyText = document.createElement("span");
            notifyText.textContent = "通知";
            const notifyCheckbox = document.createElement("input");
            notifyCheckbox.type = "checkbox";
            notifyCheckbox.checked = isDropToastEnabledForRarity(key);
            notifyCheckbox.onchange = () => {
              if (notifyCheckbox.checked) {
                dropToastNotificationRarities.add(key);
              } else {
                dropToastNotificationRarities.delete(key);
              }
              maybeAutoSave("ドロップ通知設定変更");
            };
            notifyLabel.appendChild(notifyText);
            notifyLabel.appendChild(notifyCheckbox);

            const autoSellLabel = document.createElement("label");
            autoSellLabel.className = "bulk-sell-rarity-action";
            const autoSellText = document.createElement("span");
            autoSellText.textContent = "自動売却";
            const autoSellCheckbox = document.createElement("input");
            autoSellCheckbox.type = "checkbox";
            autoSellCheckbox.checked = isAutoSellEnabledForRarity(key);
            autoSellCheckbox.onchange = () => {
              if (autoSellCheckbox.checked) {
                autoSellRarities.add(key);
              } else {
                autoSellRarities.delete(key);
              }
              maybeAutoSave("自動売却設定変更");
            };
            autoSellLabel.appendChild(autoSellText);
            autoSellLabel.appendChild(autoSellCheckbox);

            actions.appendChild(autoSellLabel);
            actions.appendChild(notifyLabel);

            row.appendChild(mainLabel);
            row.appendChild(actions);
            container.appendChild(row);
          });

          updateBulkSellSummary();
        }

        function openBulkSellModal() {
          const modal = document.getElementById("bulk-sell-modal");
          if (!modal) return;
          renderBulkSellRarityList();
          modal.classList.remove("hidden");
        }

        function closeBulkSellModal() {
          const modal = document.getElementById("bulk-sell-modal");
          if (!modal) return;
          modal.classList.add("hidden");
        }

        function executeBulkSell() {
          const items = player.inventory?.items || [];
          const targets = getBulkSellTargets();
          if (!targets.length) {
            log("売却対象のアイテムがありません", "warning");
            return;
          }
          const sortedIndexes = targets
            .map(({ index }) => index)
            .sort((a, b) => b - a);
          let total = 0;
          sortedIndexes.forEach((idx) => {
            const target = items[idx];
            if (!target) return;
            const price = calculateItemSellValue(target);
            if (price > 0) {
              total += price;
              items.splice(idx, 1);
            }
          });
          if (total > 0) {
            grantGold(total, { source: "一括売却" });
          }
          closeBulkSellModal();
          renderInventory();
          updateUI();
        }

        function renderWeaponEnhancePanel() {
          const summary = document.getElementById("weapon-enhance-summary");
          const actions = document.getElementById("weapon-enhance-actions");
          const note = document.getElementById("weapon-enhance-note");
          const table = document.getElementById("weapon-enhance-table");
          if (!summary || !actions || !note || !table) return;

          summary.innerHTML = "";
          actions.innerHTML = "";
          note.textContent = "";
          table.innerHTML = "";

          const equipment = normalizeEquipmentItem(
            weaponEnhanceTarget || player.equipment?.weapon,
          );
          weaponEnhanceTarget = equipment || null;
          if (!equipment) {
            const empty = document.createElement("div");
            empty.className = "option-label";
            empty.textContent = "強化対象の装備がありません";
            summary.appendChild(empty);
            note.textContent =
              "インベントリから装備を選んで強化ボタンを押してください。";
            return;
          }

          const header = document.createElement("div");
          header.className = "option-label";
          header.style.display = "flex";
          header.style.alignItems = "center";
          header.style.gap = "8px";
          const name = document.createElement("span");
          name.textContent = equipment.name;
          applyItemRarityColor(name, equipment);
          header.appendChild(name);
          const badge = createEnhanceBadge(equipment, { includeZero: true });
          if (badge) header.appendChild(badge);
          summary.appendChild(header);

          const level = Math.max(0, equipment.enhanceLevel || 0);
          const step = getWeaponEnhanceStep(level);
          const success = step?.success ?? 0;
          const enhanceCost = step ? calculateWeaponEnhanceCost(level) : 0;
          const repairCost = calculateWeaponEnhanceCost(level) * 2;
          const { bonusPercent } = describeEnhanceEffect(level);
          const nextEffect = step
            ? describeEnhanceEffect(step.to)
            : { bonusPercent };
          const projectedGain = Math.max(
            0,
            Math.round((nextEffect.bonusPercent - bonusPercent) * 10) / 10,
          );

          const infoGrid = document.createElement("div");
          infoGrid.className = "enhance-info-grid";
          const infoList = [
            {
              label: "現在の強化値",
              value: `+${level}${equipment.enhanceBroken ? " (破損)" : ""}`,
            },
            {
              label: "成功率",
              value: step ? `${formatEnhanceRate(success)}%` : "最大",
            },
            {
              label: "強化費用",
              value: step ? `${formatGold(enhanceCost)}G` : "なし",
            },
            {
              label: "装備補正",
              value:
                bonusPercent > 0 ? `全オプション ${bonusPercent}%` : "補正なし",
            },
            {
              label: "成功時の見込み",
              value: step
                ? `全オプション +${projectedGain}% (次は+${step.to})`
                : `最大強化達成 (全オプション ${bonusPercent}%)`,
            },
          ];
          infoList.forEach((entry) => {
            const row = document.createElement("div");
            row.className = "option-value";
            row.textContent = `${entry.label}: ${entry.value}`;
            infoGrid.appendChild(row);
          });
          summary.appendChild(infoGrid);

          const enhanceBtn = document.createElement("button");
          enhanceBtn.textContent = step
            ? `強化する (${formatGold(enhanceCost)}G)`
            : "最大強化済み";
          enhanceBtn.disabled =
            !step || equipment.enhanceBroken || player.gold < enhanceCost;
          enhanceBtn.onclick = () => attemptWeaponEnhance();
          actions.appendChild(enhanceBtn);

          const repairBtn = document.createElement("button");
          repairBtn.textContent = `修理 (${formatGold(repairCost)}G)`;
          repairBtn.disabled =
            !equipment.enhanceBroken || player.gold < repairCost;
          repairBtn.onclick = () => repairWeapon();
          actions.appendChild(repairBtn);

          const penaltyText = equipment.enhanceBroken
            ? `装備が破損しています。${formatGold(repairCost)}Gで修理できます。`
            : level >= 10
              ? `失敗すると破損し、修理に${formatGold(repairCost)}Gかかります。`
              : level >= 6
                ? "失敗すると強化値が1下がります。"
                : "失敗してもペナルティはありません。";
          note.textContent = penaltyText;

          if (step) {
            const entry = document.createElement("div");
            entry.className = "enhance-row current";
            const title = document.createElement("div");
            title.className = "option-label";
            title.textContent = `+${step.from} → +${step.to}`;
            entry.appendChild(title);
            const rate = document.createElement("div");
            rate.className = "option-value";
            rate.textContent = `成功率 ${formatEnhanceRate(step.success)}%`;
            entry.appendChild(rate);
            const costRow = document.createElement("div");
            costRow.className = "option-value";
            costRow.textContent = `費用 ${formatGold(enhanceCost)}G`;
            entry.appendChild(costRow);
            table.appendChild(entry);
          } else {
            const entry = document.createElement("div");
            entry.className = "enhance-row";
            const title = document.createElement("div");
            title.className = "option-label";
            title.textContent = `+${level}`;
            entry.appendChild(title);
            const noteRow = document.createElement("div");
            noteRow.className = "option-value";
            noteRow.textContent = "これ以上の強化はできません";
            entry.appendChild(noteRow);
            table.appendChild(entry);
          }
        }

        function clearEnhanceAnimationTimers() {
          enhanceAnimationState.timers.forEach((timer) => clearTimeout(timer));
          enhanceAnimationState.timers = [];
        }

        function applyEnhanceOutcomeIfNeeded() {
          const outcome = enhanceAnimationState.pendingOutcome;
          if (!outcome || enhanceAnimationState.completed) return false;
          enhanceAnimationState.completed = true;
          const {
            equipment,
            success,
            broken,
            penalty,
            newLevel,
            oldLevel,
            cost,
          } = outcome;
          if (success) {
            equipment.enhanceBroken = false;
            equipment.enhanceLevel = newLevel;
            log(
              `🔨 ${equipment.name} を強化成功！ +${oldLevel} → +${newLevel}`,
              "good",
            );
          } else {
            if (broken) {
              equipment.enhanceBroken = true;
              const wasEquipped = unequipItemById(equipment);
              log(
                `⚠️ ${equipment.name} の強化失敗…破損しました (修理費 ${formatGold(cost * 2)}G)`,
                "danger",
              );
              if (wasEquipped) {
                log(`🧤 ${equipment.name} を装備から外しました`, "warning");
              }
            } else if (penalty === "downgrade") {
              equipment.enhanceBroken = false;
              equipment.enhanceLevel = newLevel;
              log(
                `⚠️ ${equipment.name} の強化失敗… +${oldLevel} → +${newLevel}`,
                "warning",
              );
            } else {
              equipment.enhanceBroken = false;
              log(`⚠️ ${equipment.name} の強化失敗…ペナルティなし`, "warning");
            }
          }
          const derived = recalcDerivedStats();
          updateUI(derived);
          renderInventory();
          renderWeaponEnhancePanel();
          rerenderInventoryItemModal();
          return true;
        }

        function finishEnhanceAnimation() {
          clearEnhanceAnimationTimers();
          const applied = applyEnhanceOutcomeIfNeeded();
          if (applied) {
            maybeAutoSave("装備強化");
          }
          if (weaponEnhanceAnimation) {
            weaponEnhanceAnimation.classList.add("hidden");
            weaponEnhanceAnimation.classList.remove(
              "is-progress",
              "is-success",
              "is-fail",
              "is-broken",
            );
            weaponEnhanceAnimation.onclick = null;
          }
          enhanceAnimationState = {
            active: false,
            phase: "idle",
            timers: [],
            pendingOutcome: null,
            completed: true,
          };
        }

        function showEnhanceAnimationResult(outcome, { skipped = false } = {}) {
          if (!weaponEnhanceAnimation) {
            finishEnhanceAnimation();
            return;
          }
          clearEnhanceAnimationTimers();
          enhanceAnimationState.phase = "result";
          weaponEnhanceAnimation.classList.remove(
            "is-progress",
            "is-success",
            "is-fail",
            "is-broken",
          );
          const deltaText =
            outcome.statDelta === 0
              ? "ステータス変化なし"
              : `ステータス ${outcome.statDelta > 0 ? "+" : ""}${outcome.statDelta}%`;
          if (outcome.success) {
            weaponEnhanceAnimation.classList.add("is-success");
            weaponEnhanceAnimationIcon.textContent = "✨";
            weaponEnhanceAnimationTitle.textContent = "強化成功！";
            weaponEnhanceAnimationDetail.textContent = `+${outcome.oldLevel} → +${outcome.newLevel}`;
            weaponEnhanceAnimationGain.textContent = deltaText;
          } else {
            weaponEnhanceAnimation.classList.add("is-fail");
            if (outcome.broken)
              weaponEnhanceAnimation.classList.add("is-broken");
            weaponEnhanceAnimationIcon.textContent = outcome.broken
              ? "💥"
              : "😢";
            weaponEnhanceAnimationTitle.textContent = outcome.broken
              ? "破損..."
              : "強化失敗";
            weaponEnhanceAnimationDetail.textContent = outcome.broken
              ? `${outcome.equipment.name} は修理が必要です`
              : outcome.penalty === "downgrade"
                ? `+${outcome.oldLevel} → +${outcome.newLevel} に低下`
                : `${outcome.equipment.name} は据え置きでした`;
            weaponEnhanceAnimationGain.textContent =
              outcome.broken && outcome.penalty !== "downgrade"
                ? "効果なし"
                : deltaText;
          }
          const nextDelay = skipped ? 450 : 1400;
          enhanceAnimationState.timers.push(
            setTimeout(() => finishEnhanceAnimation(), nextDelay),
          );
        }

        function startEnhanceAnimation(outcome) {
          if (!weaponEnhanceAnimation) {
            enhanceAnimationState.pendingOutcome = outcome;
            finishEnhanceAnimation();
            return;
          }
          clearEnhanceAnimationTimers();
          enhanceAnimationState = {
            active: true,
            phase: "progress",
            timers: [],
            pendingOutcome: outcome,
            completed: false,
          };
          weaponEnhanceAnimation.classList.remove(
            "hidden",
            "is-success",
            "is-fail",
            "is-broken",
          );
          weaponEnhanceAnimation.classList.add("is-progress");
          weaponEnhanceAnimationIcon.textContent = "🔨";
          weaponEnhanceAnimationTitle.textContent = "鍛冶中...";
          weaponEnhanceAnimationDetail.textContent = `${outcome.equipment.name} をカンカン叩いています`;
          weaponEnhanceAnimationGain.textContent = "火花が散っている...";
          enhanceAnimationState.timers.push(
            setTimeout(() => showEnhanceAnimationResult(outcome), 1100),
          );
          weaponEnhanceAnimation.onclick = () => {
            if (enhanceAnimationState.phase === "progress") {
              showEnhanceAnimationResult(outcome, { skipped: true });
            } else {
              finishEnhanceAnimation();
            }
          };
        }

        function prepareEnhanceOutcome(equipment, level, step, cost) {
          const roll = Math.random() * 100;
          const success = roll < step.success;
          const outcome = {
            equipment,
            success,
            broken: false,
            penalty: "none",
            oldLevel: level,
            newLevel: level,
            cost,
          };
          if (success) {
            outcome.newLevel = step.to;
          } else if (level >= 10) {
            outcome.broken = true;
            outcome.penalty = "broken";
          } else if (level >= 6) {
            outcome.penalty = "downgrade";
            outcome.newLevel = Math.max(0, level - 1);
          }
          const beforeEffect = describeEnhanceEffect(level);
          const afterEffect = describeEnhanceEffect(outcome.newLevel);
          outcome.statDelta =
            Math.round(
              (afterEffect.bonusPercent - beforeEffect.bonusPercent) * 10,
            ) / 10;
          return outcome;
        }

        function attemptWeaponEnhance() {
          const equipment = normalizeEquipmentItem(
            weaponEnhanceTarget || player.equipment?.weapon,
          );
          if (!equipment) {
            log("強化する装備を選択してください", "warning");
            return;
          }
          if (equipment.enhanceBroken) {
            log("まずは修理が必要です", "warning");
            return;
          }
          const level = Math.max(0, equipment.enhanceLevel || 0);
          const step = getWeaponEnhanceStep(level);
          if (!step) {
            log("これ以上強化できません", "info");
            return;
          }
          const cost = calculateWeaponEnhanceCost(level);
          if (player.gold < cost) {
            log("強化費用が不足しています", "warning");
            return;
          }

          player.gold -= cost;
          const outcome = prepareEnhanceOutcome(equipment, level, step, cost);
          startEnhanceAnimation(outcome);
        }

        function repairWeapon() {
          const equipment = normalizeEquipmentItem(
            weaponEnhanceTarget || player.equipment?.weapon,
          );
          if (!equipment) {
            log("修理する装備を選択してください", "warning");
            return;
          }
          if (!equipment.enhanceBroken) {
            log("修理が必要な状態ではありません", "info");
            return;
          }
          const level = Math.max(0, equipment.enhanceLevel || 0);
          const cost = calculateWeaponEnhanceCost(level) * 2;
          if (player.gold < cost) {
            log("修理費用が不足しています", "warning");
            return;
          }
          player.gold -= cost;
          equipment.enhanceBroken = false;
          log(`🛠️ ${equipment.name} を修理しました (+${level})`, "info");
          const derived = recalcDerivedStats();
          updateUI(derived);
          renderInventory();
          renderWeaponEnhancePanel();
          rerenderInventoryItemModal();
          maybeAutoSave("装備修理");
        }

        function equipPotionFromInventory(inventoryIndex, slotIndex) {
          const items = player.inventory?.items || [];
          if (!items[inventoryIndex]) return;
          const entry = items[inventoryIndex];
          if (entry.type !== "potion" || !entry.potion) return;
          if (!player.potions?.length || !player.potions[slotIndex]) return;

          const newPotion = { ...entry.potion };
          registerCodexDiscovery(entry);
          const previous = player.potions[slotIndex];
          player.potions[slotIndex] = newPotion;

          const alreadyHasPrevious = items.some(
            (it, idx) =>
              idx !== inventoryIndex &&
              it.type === "potion" &&
              it.potion?.id === previous?.id,
          );

          if (previous && !alreadyHasPrevious) {
            const removed = ensureAcquiredOrder(
              createPotionInventoryItem(previous, {
                description: "スロットから外したポーション",
              }),
            );
            items.push(removed);
            registerCodexDiscovery(removed);
          }

          log(
            `💧 ${newPotion.name} をスロット${slotIndex + 1}に装備した`,
            "info",
          );
          updateUI();
          renderInventory();
        }

        function sellInventoryItem(index, item, priceOverride) {
          const items = player.inventory?.items || [];
          if (!items[index]) return;
          if (isItemEquipped(item)) {
            log("装備中のアイテムは売却できません", "warning");
            return;
          }
          if (item.favorite) {
            log("お気に入り登録中のアイテムは売却できません", "warning");
            return;
          }
          const sellPrice = priceOverride ?? calculateItemSellValue(item);
          if (!sellPrice || sellPrice <= 0) {
            log("このアイテムは売却できません", "warning");
            return;
          }
          items.splice(index, 1);
          grantGold(sellPrice, { source: "売却" });
          closeInventoryItemModal();
          renderInventory();
          updateUI();
        }

        const playerDownOverlay = document.getElementById("player-down-overlay");
        const enemyModal = document.getElementById("enemy-modal");
        const modalFeature = document.getElementById("modal-feature");
        const modalLegendarySection = document.getElementById(
          "modal-legendary-section",
        );
        const modalBossKills = document.getElementById("modal-boss-kills");
        const modalLegendaryName = document.getElementById(
          "modal-legendary-name",
        );
        const modalLegendaryStatus = document.getElementById(
          "modal-legendary-status",
        );
        const modalLegendaryStats = document.getElementById(
          "modal-legendary-stats",
        );
        const potionModal = document.getElementById("potion-modal");
        const skillInfoModal = document.getElementById("skill-info-modal");
        const playerModal = document.getElementById("player-modal");
        const playerStatusView = document.getElementById("player-status-view");
        const playerEquipmentView = document.getElementById(
          "player-equipment-view",
        );
        const playerEquipmentList = document.getElementById(
          "player-equipment-list",
        );
        const equipmentBonusSummary = document.getElementById(
          "equipment-bonus-summary",
        );
        const skillsModal = document.getElementById("skills-modal");
        const weaponEnhanceModal = document.getElementById(
          "weapon-enhance-modal",
        );
        const weaponEnhanceAnimation = document.getElementById(
          "weapon-enhance-animation",
        );
        const weaponEnhanceAnimationTitle = document.getElementById(
          "weapon-enhance-animation-title",
        );
        const weaponEnhanceAnimationDetail = document.getElementById(
          "weapon-enhance-animation-detail",
        );
        const weaponEnhanceAnimationGain = document.getElementById(
          "weapon-enhance-animation-gain",
        );
        const weaponEnhanceAnimationIcon = document.getElementById(
          "weapon-enhance-animation-icon",
        );
        const inventoryModal = document.getElementById("inventory-modal");
        const bulkSellModal = document.getElementById("bulk-sell-modal");
        const inventoryItemModal = document.getElementById(
          "inventory-item-modal",
        );
        const codexModal = document.getElementById("codex-modal");
        const codexDetailModal = document.getElementById("codex-detail-modal");
        const closeModalButton = document.getElementById("modal-close");
        const potionModalCloseButton = document.getElementById("potion-close");
        const skillInfoCloseButton =
          document.getElementById("skill-info-close");
        const playerModalCloseButton = document.getElementById("player-close");
        const skillsModalCloseButton = document.getElementById("skills-close");
        const weaponEnhanceCloseButton = document.getElementById(
          "weapon-enhance-close",
        );
        const inventoryModalCloseButton =
          document.getElementById("inventory-close");
        const bulkSellModalCloseButton = document.getElementById(
          "bulk-sell-close",
        );
        const inventoryItemCloseButton = document.getElementById(
          "inventory-item-close",
        );
        const statHelpButton = document.getElementById("stat-help");
        const potionModalName = document.getElementById("potion-modal-name");
        const inventoryCompareResult = document.getElementById(
          "inventory-compare-result",
        );
        const potionModalType = document.getElementById("potion-modal-type");
        const potionModalRarity = document.getElementById(
          "potion-modal-rarity",
        );
        const potionModalEffect = document.getElementById(
          "potion-modal-effect",
        );
        const potionModalCost = document.getElementById("potion-modal-cost");
        const potionModalFill = document.getElementById("potion-modal-fill");
        const potionModalPrefix = document.getElementById(
          "potion-modal-prefix",
        );
        const potionModalSuffix = document.getElementById(
          "potion-modal-suffix",
        );
        const potionModalDesc = document.getElementById("potion-modal-desc");
        const codexTabs = document.getElementById("codex-tabs");
        const codexList = document.getElementById("codex-list");
        const codexDetailName = document.getElementById("codex-detail-name");
        const codexDetailBody = document.getElementById("codex-detail-body");
        const codexCloseButton = document.getElementById("codex-close");
        const codexDetailCloseButton =
          document.getElementById("codex-detail-close");
        const warpModal = document.getElementById("warp-modal");
        const warpCloseButton = document.getElementById("warp-close");
        const warpBossList = document.getElementById("warp-boss-list");
        const warpMaxButton = document.getElementById("warp-max-floor");
        const warpCurrentFloor = document.getElementById("warp-current-floor");
        const warpMaxLabel = document.getElementById("warp-max-label");
        const skillInfoName = document.getElementById("skill-info-name");
        const skillInfoType = document.getElementById("skill-info-type");
        const skillInfoCooldown = document.getElementById(
          "skill-info-cooldown",
        );
        const skillInfoLevel = document.getElementById("skill-info-level");
        const skillInfoEffect = document.getElementById("skill-info-effect");
        const skillInfoNote = document.getElementById("skill-info-note");
        const inventoryItemName = document.getElementById(
          "inventory-item-name",
        );
        const inventoryItemDesc = document.getElementById(
          "inventory-item-desc",
        );
        const inventoryItemMeta = document.getElementById(
          "inventory-item-meta",
        );
        const inventoryItemDetail = document.getElementById(
          "inventory-item-detail",
        );
        const inventoryItemActions = document.getElementById(
          "inventory-item-actions",
        );
        const memoModal = document.getElementById("memo-modal");
        const memoCloseButton = document.getElementById("memo-close");
        const resetModal = document.getElementById("reset-modal");
        const resetCloseButton = document.getElementById("reset-close");
        const resetCancelButton = document.getElementById("reset-cancel");
        const resetConfirmButton = document.getElementById("reset-confirm");
        const resetSpentLabel = document.getElementById("reset-spent");
        const resetButton = document.getElementById("reset-stats");
        const statStepButton = document.getElementById("stat-step");
        const skillStepButton = document.getElementById("skill-step");
        const playerModalStatusButton = document.getElementById(
          "player-modal-status-btn",
        );
        const playerModalEquipmentButton = document.getElementById(
          "player-modal-equipment-btn",
        );
        const skillSummaryToggleButton = document.getElementById(
          "skill-summary-toggle",
        );
        const skillDetailView = document.getElementById("skill-detail-view");
        const skillSummaryModal = document.getElementById(
          "skill-summary-modal",
        );
        const skillSummaryCloseButton = document.getElementById(
          "skill-summary-close",
        );
        const resetSkillsButton = document.getElementById("reset-skills");
        const skillResetModal = document.getElementById("skill-reset-modal");
        const skillResetCloseButton =
          document.getElementById("skill-reset-close");
        const skillResetCancelButton =
          document.getElementById("skill-reset-cancel");
        const skillResetConfirmButton = document.getElementById(
          "skill-reset-confirm",
        );
        const skillResetSpentLabel =
          document.getElementById("skill-reset-spent");
        const debugModal = document.getElementById("debug-modal");
        const debugOpenButton = document.getElementById("btn-debug");
        const debugCloseButton = document.getElementById("debug-close");
        const debugTargetSelect = document.getElementById("debug-target");
        const debugEnemySelect = document.getElementById("debug-enemy");
        const debugClearButton = document.getElementById("debug-clear-status");
        const debugTabButtons = document.querySelectorAll(".debug-tab-button");
        const debugTabStatus = document.getElementById("debug-tab-status");
        const debugTabEquipment = document.getElementById(
          "debug-tab-equipment",
        );
        const debugTabAdjust = document.getElementById("debug-tab-adjust");
        const debugTabSave = document.getElementById("debug-tab-save");
        const saveSlotList = document.getElementById("save-slot-list");
        const debugGearSlotSelect = document.getElementById("debug-gear-slot");
        const debugGearRaritySelect =
          document.getElementById("debug-gear-rarity");
        const debugLegendaryWrapper = document.getElementById(
          "debug-legendary-wrapper",
        );
        const debugLegendarySelect = document.getElementById(
          "debug-legendary-template",
        );
        const debugGearEnhanceInput =
          document.getElementById("debug-gear-enhance");
        const debugGearPreview = document.getElementById("debug-gear-preview");
        const debugGenerateGearButton = document.getElementById(
          "debug-generate-gear",
        );
        const debugGenerateGearRandomButton = document.getElementById(
          "debug-generate-gear-random",
        );
        const debugPotionTemplateSelect = document.getElementById(
          "debug-potion-template",
        );
        const debugPotionVariantSelect = document.getElementById(
          "debug-potion-variant",
        );
        const debugPotionRaritySelect = document.getElementById(
          "debug-potion-rarity",
        );
        const debugPotionSlotSelect =
          document.getElementById("debug-potion-slot");
        const debugPotionLegendaryWrapper = document.getElementById(
          "debug-potion-legendary-wrapper",
        );
        const debugPotionLegendarySelect = document.getElementById(
          "debug-potion-legendary-template",
        );
        const debugPotionPreview = document.getElementById(
          "debug-potion-preview",
        );
        const debugGeneratePotionButton = document.getElementById(
          "debug-generate-potion",
        );
        const debugGeneratePotionRandomButton = document.getElementById(
          "debug-generate-potion-random",
        );
        const debugRerollPotionButton = document.getElementById(
          "debug-reroll-potion",
        );
        const debugLevelInput = document.getElementById("debug-level-input");
        const debugHpInput = document.getElementById("debug-hp-input");
        const debugGoldInput = document.getElementById("debug-gold-input");
        const debugFloorInput = document.getElementById("debug-floor-input");
        const debugForceLegendaryCheckbox = document.getElementById(
          "debug-force-legendary",
        );
        const debugAutoAttackCheckbox =
          document.getElementById("debug-auto-attack");
        debugCodexUnlockCheckbox = document.getElementById("debug-codex-unlock");
        const debugApplyLevelButton =
          document.getElementById("debug-apply-level");
        const debugApplyHpButton = document.getElementById("debug-apply-hp");
        const debugApplyGoldButton =
          document.getElementById("debug-apply-gold");
        const debugApplyFloorButton =
          document.getElementById("debug-apply-floor");
        const debugBossFloorButtons = document.querySelectorAll(
          "[data-debug-boss-floor]",
        );
        const debugNewRunButton = document.getElementById("debug-new-run");
        const inventoryOpenButton = document.getElementById("btn-inventory");
        const bulkSellExecuteButton = document.getElementById("bulk-sell-execute");
        const codexOpenButton = document.getElementById("btn-codex");
        const warpOpenButton = document.getElementById("btn-warp");
        const archetypeModal = document.getElementById("archetype-modal");
        const archetypeModalName = document.getElementById(
          "archetype-modal-name",
        );
        const archetypeModalDesc = document.getElementById(
          "archetype-modal-desc",
        );
        const archetypeModalAbilities = document.getElementById(
          "archetype-modal-abilities",
        );
        const archetypeCloseButton = document.getElementById("archetype-close");

        function formatLegendaryStatValue(value, def) {
          const unit = def?.unit || "";
          const precision = def?.precision ?? (unit === "%" ? 1 : 0);
          const numeric = Number(value);
          if (Number.isNaN(numeric)) return `--${unit}`;
          const formatted = precision
            ? numeric.toFixed(precision)
            : Math.round(numeric).toString();
          return `${formatted}${unit}`;
        }

        function getBossRecordKey(enemy) {
          const fallback = Math.max(1, Math.floor(game.floor || 1));
          const keySource = enemy?.bossSkillKey ?? enemy?.bossFloor ?? fallback;
          return String(Math.max(1, Math.floor(Number(keySource) || fallback)));
        }

        function getBossKillCount(enemy) {
          const key = getBossRecordKey(enemy);
          return game.bossKillRecords?.[key] ?? 0;
        }

        function renderBossLegendarySection(enemy) {
          if (
            !modalLegendarySection ||
            !modalBossKills ||
            !modalLegendaryName ||
            !modalLegendaryStatus ||
            !modalLegendaryStats
          )
            return;
          if (!enemy?.isBoss) {
            modalLegendarySection.classList.add("hidden");
            modalLegendaryStats.innerHTML = "";
            modalBossKills.textContent = "";
            return;
          }

          const dropInfo = BOSS_LEGENDARY_DROPS[game.floor];
          const pool =
            (enemy.bossLegendaryPool && enemy.bossLegendaryPool.length
              ? enemy.bossLegendaryPool
              : dropInfo?.legendaryKeys || []).filter(Boolean);

          modalLegendarySection.classList.remove("hidden");
          modalBossKills.textContent = `討伐数: ${getBossKillCount(enemy)}回`;
          modalLegendaryName.textContent = "レジェンダリー";
          modalLegendaryStatus.textContent = pool.length
            ? `候補: ${pool.length}種`
            : "候補なし";
          modalLegendaryStats.innerHTML = "";

          if (!pool.length) {
            const placeholder = document.createElement("div");
            placeholder.className = "option-value";
            placeholder.textContent = "ドロップ候補が設定されていません";
            modalLegendaryStats.appendChild(placeholder);
            return;
          }

          pool.forEach((key) => {
            const template = getLegendaryTemplateByKey(key);
            const record = game.legendaryRecords?.[key];
            const name = template?.name || key;
            const count = record?.drops ?? 0;
            const details = document.createElement("details");
            details.className = "legendary-record-row";

            const summary = document.createElement("summary");
            summary.textContent = `${name} / ドロップ ${count}回`;
            details.appendChild(summary);

            const body = document.createElement("div");
            body.className = "legendary-records";

            const uniqueRow = document.createElement("div");
            uniqueRow.className = "option-value";
            const uniqueText = template?.unique?.effect
              ? `${template.unique.name} / ${template.unique.effect}`
              : "固有効果不明";
            uniqueRow.textContent = uniqueText;
            body.appendChild(uniqueRow);

            const baseText = (template?.base || [])
              .map((opt) => formatOptionRangeForCodex(opt))
              .filter(Boolean)
              .join(" / ");
            const baseRow = document.createElement("div");
            baseRow.className = "option-value";
            baseRow.textContent = baseText ? `基礎: ${baseText}` : "基礎情報なし";
            body.appendChild(baseRow);

            details.appendChild(body);
            modalLegendaryStats.appendChild(details);
          });
        }

        const CODEX_CATEGORIES = [
          { key: "enemy", label: "敵" },
          { key: "archetype", label: "アーキタイプ" },
          { key: "boss", label: "ボス" },
          { key: "equipment", label: "装備" },
          { key: "potion", label: "アイテム" },
          { key: "titlePrefix", label: "称号(前)" },
          { key: "titleSuffix", label: "称号(後)" },
        ];

        let currentCodexCategory = "enemy";

        const EQUIPMENT_SLOT_ORDER = Object.keys(PLAYER_EQUIPMENT_SLOTS);
        const SECONDARY_STAT_DEFS = [
          { key: "physAtk", label: "物理攻撃力" },
          { key: "magAtk", label: "魔法攻撃力" },
          { key: "physPen", label: "物理貫通", unit: "%" },
          { key: "magPen", label: "魔法貫通", unit: "%" },
          { key: "critRate", label: "クリティカル率", unit: "%" },
          { key: "critDamage", label: "クリティカルダメージ", unit: "%" },
          { key: "accuracy", label: "命中率", unit: "%" },
          { key: "evade", label: "回避率", unit: "%" },
          { key: "maxHp", label: "最大HP" },
          { key: "maxMp", label: "最大MP" },
          { key: "physDef", label: "物理防御力" },
          { key: "magDef", label: "魔法防御力" },
          { key: "damageReduction", label: "被ダメージ軽減", unit: "%" },
          { key: "block", label: "ブロック率", unit: "%" },
          { key: "speed", label: "行動速度" },
          { key: "attackCount", label: "通常攻撃回数" },
          { key: "attackTargets", label: "同時攻撃対象" },
          { key: "cooldown", label: "クールタイム短縮", unit: "%" },
          { key: "controlResist", label: "行動阻害抵抗", unit: "%" },
          { key: "dotResist", label: "DoT抵抗", unit: "%" },
          { key: "debuffResist", label: "弱体化抵抗", unit: "%" },
          { key: "hpRegen", label: "HP再生" },
          { key: "lifeSteal", label: "HP吸収", unit: "%" },
          { key: "barrier", label: "バリア" },
          { key: "dropRate", label: "ドロップ率UP", unit: "%" },
          { key: "rarity", label: "レアリティUP", unit: "%" },
          { key: "namedRate", label: "ネームド遭遇率", unit: "%" },
          { key: "titleChance", label: "称号付与率UP", unit: "%" },
          { key: "goldChance", label: "ゴールド確率", unit: "%" },
        ];
        const TITLE_GROUP_ORDER = ["normal", "legendary", "potion"];

        function formatStatLabel(key) {
          return EQUIPMENT_STAT_BY_KEY[key]?.label || key;
        }

        function formatOptionRangeForCodex(option) {
          if (!option) return "";
          const [min, max] = option.range || [option.min ?? 0, option.max ?? 0];
          const unit =
            option.unit || EQUIPMENT_STAT_BY_KEY[option.key]?.unit || "";
          const label = formatStatLabel(option.key);
          const minText = typeof min === "number" ? min : "?";
          const maxText = typeof max === "number" ? max : "?";
          return `${label} ${minText}${unit}〜${maxText}${unit}`;
        }

        function buildEnemyCodexEntries() {
          const codex = ensureCodexState();
          const entries = [];
          ENEMY_NAME_POOLS.forEach((pool) => {
            pool.names.forEach((name) => {
              entries.push({
                key: `monster:${name}`,
                name,
                summary: `${pool.min}F〜${pool.max}F に出現する雑魚敵。`,
                detailRows: [
                  { label: "種別", value: "雑魚敵" },
                  { label: "階層", value: `${pool.min}F〜${pool.max}F` },
                  {
                    label: "備考",
                    value: "タイプやアーキタイプにより性質が変化する。",
                  },
                ],
                discovered: !!codex.enemyMonsters?.[name],
                minFloor: pool.min,
              });
            });
          });
          return entries;
        }

        function buildArchetypeCodexEntries() {
          const codex = ensureCodexState();
          return ENEMY_VARIANTS.map((variant) => {
            const abilityText = (variant.abilities || [])
              .map((ability) => {
                const detail = describeModifiers(ability.modifiers);
                return detail ? `${ability.label}: ${detail}` : ability.label;
              })
              .filter(Boolean)
              .join(" / ");
            return {
              key: `variant:${variant.key}`,
              name: variant.label,
              summary: variant.description,
              detailRows: [
                { label: "種別", value: "アーキタイプ" },
                { label: "特徴", value: variant.description || "" },
                { label: "アビリティ", value: abilityText || "不明" },
              ],
              discovered: !!codex.enemyVariants?.[variant.key],
              minFloor: variant.minFloor || 0,
            };
          });
        }

        function buildBossCodexEntries() {
          const codex = ensureCodexState();
          return BOSS_FLOORS.map((floor) => {
            const def = BOSS_DEFINITIONS[floor];
            const discovered = !!codex.bosses?.[floor];
            const skill = BOSS_SKILLS[floor];
            const skillText = skill
              ? `${skill.name}${skill.description ? `: ${skill.description}` : ""}`
              : "--";
            const dropInfo = BOSS_LEGENDARY_DROPS[floor];
            const dropKeys =
              dropInfo?.legendaryKeys ||
              (dropInfo?.legendaryKey ? [dropInfo.legendaryKey] : []);
            const dropTemplates = dropKeys
              .map((key) => getLegendaryTemplateByKey(key))
              .filter(Boolean);
            const dropName = discovered
              ? dropTemplates.length
                ? dropTemplates.map((t) => t.name).join(" / ")
                : "？？？"
              : dropInfo
                ? "？？？"
                : "--";
            const dropChanceText = dropInfo
              ? formatBossLegendaryChanceDetail(floor)
              : null;
            return {
              key: `boss:${floor}`,
              name: def?.name || `${floor}F ボス`,
              summary: def?.flavor || "強力な階層ボス",
              detailRows: [
                { label: "階層", value: `${floor}F` },
                { label: "特徴", value: def?.flavor || "未知" },
                {
                  label: "伝説",
                  value: def?.legendaryKey
                    ? getLegendaryTemplateByKey(def.legendaryKey)?.name ||
                      "？？？"
                    : "--",
                },
                { label: "スキル", value: skillText },
                {
                  label: "ドロップ",
                  value: dropName,
                  interactive: discovered && dropTemplates.length > 0,
                  dropTemplates,
                  dropSlot: dropInfo?.slot,
                },
                { label: "レジェンド率", value: dropChanceText || "--" },
              ],
              discovered,
              floor,
            };
          });
        }

        function buildEquipmentCodexEntries() {
          const codex = ensureCodexState();
          const entries = [];
          Object.entries(EQUIPMENT_TEMPLATE_LIBRARY).forEach(
            ([slotKey, templates]) => {
              templates.forEach((template) => {
                const optionText = (template.base || [])
                  .map((opt) => formatOptionRangeForCodex(opt))
                  .join(" / ");
                entries.push({
                  key: template.key,
                  name: template.name,
                  summary: optionText,
                  detailRows: [
                    {
                      label: "部位",
                      value: PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey,
                    },
                    { label: "基礎", value: optionText || "--" },
                  ],
                  discovered: !!codex.equipment?.[template.key],
                  slotKey,
                });
              });
            },
          );

          Object.entries(LEGENDARY_EQUIPMENT_LIBRARY).forEach(
            ([slotKey, templates]) => {
              templates.forEach((template) => {
                const optionText = (template.base || [])
                  .map((opt) => formatOptionRangeForCodex(opt))
                  .join(" / ");
                const uniqueText = template.unique?.effect
                  ? `${template.unique.name} / ${template.unique.effect}`
                  : "";
                entries.push({
                  key: template.key,
                  name: template.name,
                  summary: uniqueText || optionText,
                  detailRows: [
                    {
                      label: "部位",
                      value: PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey,
                    },
                    { label: "基礎", value: optionText || "--" },
                    { label: "固有", value: uniqueText || "--" },
                  ],
                  discovered: !!codex.equipment?.[template.key],
                  slotKey,
                });
              });
            },
          );

          return entries;
        }

        function buildPotionCodexEntries() {
          const codex = ensureCodexState();
          const entries = [];
          Object.values(POTION_BASE_TEMPLATES).forEach((template) => {
            (template.variants || []).forEach((variant) => {
              const key = `potion:${template.key}:${variant.key}`;
              const effectText =
                variant.effectText || template.summary || "ポーション";
              entries.push({
                key,
                name: `${template.label} (${variant.label})`,
                summary: effectText,
                detailRows: [
                  {
                    label: "区分",
                    value:
                      template.category === "buff"
                        ? "バフ"
                        : template.type === "hp"
                          ? "HP"
                          : "MP",
                  },
                  { label: "概要", value: effectText },
                ],
                discovered:
                  !!codex.potions?.[`potion:${template.key}:${variant.key}`],
              });
            });
          });

          LEGENDARY_POTIONS.forEach((potion) => {
            entries.push({
              key: `legendary:${potion.key}`,
              name: potion.name,
              summary: potion.summary || potion.tagline,
              detailRows: [
                { label: "区分", value: "レジェンダリー" },
                {
                  label: "概要",
                  value: potion.summary || potion.tagline || "特殊効果",
                },
              ],
              discovered: !!codex.potions?.[`legendary:${potion.key}`],
            });
          });

          return entries;
        }

        function buildTitleCodexEntries(kindFilter = null) {
          const codex = ensureCodexState();
          const entries = [];
          const formatRandomScaling = (values, formatter) =>
            values
              .map((value) => formatter(value))
              .filter(Boolean)
              .join(" / ");

          const describeTitleSpecialEffects = (title) => {
            const effects = [];
            if (title?.primaryPerLevelStats?.length) {
              const statLabel = title.primaryPerLevelStats
                .map((stat) => formatStatLabel(stat))
                .join(" / ");
              const scalingText = formatRandomScaling(
                TITLE_PRIMARY_PER_LEVEL_EFFECTS,
                (effect) =>
                  effect
                    ? `${
                        effect.interval === 1
                          ? "Lv毎"
                          : `${effect.interval}Lv毎`
                      }+${effect.amount}`
                    : "",
              );
              effects.push(`一次成長: ${statLabel} (ランダム: ${scalingText})`);
            }
            if (title?.primaryFixedStats?.length) {
              const statLabel = title.primaryFixedStats
                .map((stat) => formatStatLabel(stat))
                .join(" / ");
              const scalingText = formatRandomScaling(
                TITLE_PRIMARY_FIXED_EFFECTS,
                (value) => (value != null ? `${value}固定` : ""),
              );
              effects.push(`一次固定: ${statLabel} (ランダム: ${scalingText})`);
            }
            if (title?.attackCountBonus) {
              const scalingText = formatRandomScaling(
                TITLE_ATTACK_COUNT_BONUS_EFFECTS,
                (value) => (value != null ? `通常攻撃+${value}回` : ""),
              );
              effects.push(`連撃: ランダム (${scalingText})`);
            }
            if (title?.attackTargetsBonus) {
              effects.push(`多重攻撃: 攻撃対象+${title.attackTargetsBonus}`);
            }
            return effects;
          };

          const buildTitleEntry = (title, kind) => {
            if (kindFilter && kind !== kindFilter) return;
            const stats = (title.options || [])
              .map((opt) => formatStatLabel(opt))
              .join(" / ");
            const specialEffects = describeTitleSpecialEffects(title);
            const summaryParts = [stats, specialEffects[0]].filter(Boolean);
            const detailEffects = [
              stats ? `通常: ${stats}` : null,
              ...specialEffects,
            ].filter(Boolean);
            const group = title.group || "normal";
            const rank = title.rank || 1;
            const kindLabel = kind === "prefix" ? "前" : "後";
            entries.push({
              key: `${kind}:${title.key}`,
              name: `${title.name} (${kindLabel})`,
              summary: summaryParts.join(" / "),
              detailRows: [
                { label: "位置", value: kindLabel },
                { label: "ランク", value: `★${rank}` },
                { label: "効果", value: detailEffects.join("\n") || "--" },
                {
                  label: "区分",
                  value:
                    group === "legendary"
                      ? "レジェンド用"
                      : group === "potion"
                        ? "ポーション用"
                        : "通常",
                },
              ],
              discovered: !!codex.titles?.[`${kind}:${title.key}`],
              group,
              rank,
              kind,
            });
          };

          const buildPotionAffixEntries = (base, kind) => {
            const typeLabel = kind === "prefix" ? "前" : "後";
            const categoryLabels = {
              general: "汎用",
              recovery: "回復",
              buff: "バフ",
              legendaryGeneral: "レジェンド汎用",
              legendaryRecovery: "レジェンド回復",
              legendaryBuff: "レジェンドバフ",
              legendaryCost: "レジェンド消費軽減",
            };
            Object.entries(base || {}).forEach(([category, list]) => {
              (list || []).forEach((affix) => {
                if (kindFilter && kind !== kindFilter) return;
                const isLegendary = category.startsWith("legendary");
                const group = isLegendary ? "legendary" : "potion";
                const rank = isLegendary ? 3 : 1;
                const key = `potion-${kind}:${affix.key}`;
                entries.push({
                  key,
                  name: `${affix.name} (${typeLabel})`,
                  summary: affix.effect || "--",
                  detailRows: [
                    { label: "位置", value: typeLabel },
                    { label: "ランク", value: `★${rank}` },
                    {
                      label: "区分",
                      value:
                        group === "legendary" ? "レジェンド用" : "ポーション用",
                    },
                    {
                      label: "カテゴリ",
                      value: categoryLabels[category] || category,
                    },
                    { label: "効果", value: affix.effect || "--" },
                  ],
                  discovered: !!codex.titles?.[key],
                  group,
                  rank,
                  kind,
                });
              });
            });
          };

          EQUIPMENT_TITLE_PREFIXES.forEach((title) =>
            buildTitleEntry(title, "prefix"),
          );
          EQUIPMENT_TITLE_SUFFIXES.forEach((title) =>
            buildTitleEntry(title, "suffix"),
          );

          buildPotionAffixEntries(POTION_PREFIXES, "prefix");
          buildPotionAffixEntries(POTION_SUFFIXES, "suffix");

          return entries;
        }

        function buildCodexEntries(categoryKey) {
          switch (categoryKey) {
            case "enemy":
              return buildEnemyCodexEntries();
            case "archetype":
              return buildArchetypeCodexEntries();
            case "boss":
              return buildBossCodexEntries();
            case "equipment":
              return buildEquipmentCodexEntries();
            case "potion":
              return buildPotionCodexEntries();
            case "titlePrefix":
              return buildTitleCodexEntries("prefix");
            case "titleSuffix":
              return buildTitleCodexEntries("suffix");
            default:
              return [];
          }
        }

        function sortCodexEntries(entries, categoryKey) {
          switch (categoryKey) {
            case "enemy":
              return entries.slice().sort((a, b) => {
                if ((a.minFloor || 0) !== (b.minFloor || 0))
                  return (a.minFloor || 0) - (b.minFloor || 0);
                return a.name.localeCompare(b.name, "ja");
              });
            case "boss":
              return entries
                .slice()
                .sort((a, b) => (a.floor ?? 0) - (b.floor ?? 0));
            case "equipment":
              return entries.slice().sort((a, b) => {
                const slotOrderA = EQUIPMENT_SLOT_ORDER.indexOf(a.slotKey);
                const slotOrderB = EQUIPMENT_SLOT_ORDER.indexOf(b.slotKey);
                if (slotOrderA !== slotOrderB) return slotOrderA - slotOrderB;
                return a.name.localeCompare(b.name, "ja");
              });
            case "titlePrefix":
            case "titleSuffix":
              return entries.slice().sort((a, b) => {
                const groupA = TITLE_GROUP_ORDER.indexOf(a.group);
                const groupB = TITLE_GROUP_ORDER.indexOf(b.group);
                if (groupA !== groupB) return groupA - groupB;
                if (a.rank !== b.rank) return (a.rank || 0) - (b.rank || 0);
                if (a.kind !== b.kind) return a.kind === "prefix" ? -1 : 1;
                return a.name.localeCompare(b.name, "ja");
              });
            case "archetype":
              return entries.slice().sort((a, b) => {
                if ((a.minFloor || 0) !== (b.minFloor || 0))
                  return (a.minFloor || 0) - (b.minFloor || 0);
                return a.name.localeCompare(b.name, "ja");
              });
            default:
              return entries.slice();
          }
        }

        function collectAllCodexKeys() {
          const keys = {
            enemyMonsters: [],
            enemyVariants: [],
            bosses: [],
            equipment: [],
            potions: [],
            titles: [],
          };

          ENEMY_NAME_POOLS.forEach((pool) => {
            pool.names.forEach((name) => keys.enemyMonsters.push(name));
          });
          ENEMY_VARIANTS.forEach((variant) =>
            keys.enemyVariants.push(variant.key),
          );
          keys.bosses = Object.keys(BOSS_DEFINITIONS);

          Object.values(EQUIPMENT_TEMPLATE_LIBRARY).forEach((templates) => {
            templates.forEach((template) => keys.equipment.push(template.key));
          });
          Object.values(LEGENDARY_EQUIPMENT_LIBRARY).forEach((templates) => {
            templates.forEach((template) => keys.equipment.push(template.key));
          });

          Object.values(POTION_BASE_TEMPLATES).forEach((template) => {
            (template.variants || []).forEach((variant) => {
              keys.potions.push(`potion:${template.key}:${variant.key}`);
            });
          });
          LEGENDARY_POTIONS.forEach((potion) =>
            keys.potions.push(`legendary:${potion.key}`),
          );

          EQUIPMENT_TITLE_PREFIXES.forEach((title) =>
            keys.titles.push(`prefix:${title.key}`),
          );
          EQUIPMENT_TITLE_SUFFIXES.forEach((title) =>
            keys.titles.push(`suffix:${title.key}`),
          );
          Object.values(POTION_PREFIXES).forEach((list) => {
            (list || []).forEach((affix) =>
              keys.titles.push(`potion-prefix:${affix.key}`),
            );
          });
          Object.values(POTION_SUFFIXES).forEach((list) => {
            (list || []).forEach((affix) =>
              keys.titles.push(`potion-suffix:${affix.key}`),
            );
          });

          return keys;
        }

        function applyDebugCodexUnlock(enabled) {
          if (enabled) {
            debugCodexSnapshot = cloneState(ensureCodexState());
            const codex = ensureCodexState();
            const allKeys = collectAllCodexKeys();
            Object.entries(allKeys).forEach(([category, keyList]) => {
              if (!codex[category]) codex[category] = {};
              keyList.forEach((key) => {
                if (key !== undefined && key !== null) {
                  codex[category][key] = true;
                }
              });
            });
            debugCodexFullyUnlocked = true;
            log("🐞 図鑑を全解放しました", "info");
          } else {
            if (debugCodexSnapshot) {
              game.codex = cloneState(debugCodexSnapshot);
            } else {
              game.codex = {
                enemyMonsters: {},
                enemyVariants: {},
                bosses: {},
                equipment: {},
                potions: {},
                titles: {},
              };
            }
            ensureCodexState();
            debugCodexSnapshot = null;
            debugCodexFullyUnlocked = false;
            log("🐞 図鑑の解放状態を元に戻しました", "info");
          }

          if (!codexModal?.classList.contains("hidden")) {
            renderCodexTabs();
            renderCodexList();
          }
        }

        function renderCodexTabs() {
          if (!codexTabs) return;
          codexTabs.innerHTML = "";
          CODEX_CATEGORIES.forEach((cat) => {
            const btn = document.createElement("button");
            btn.className = `codex-tab ${currentCodexCategory === cat.key ? "active" : ""}`;
            btn.textContent = cat.label;
            btn.onclick = () => {
              currentCodexCategory = cat.key;
              renderCodexTabs();
              renderCodexList();
            };
            codexTabs.appendChild(btn);
          });
        }

        function renderCodexList() {
          if (!codexList) return;
          const entries = sortCodexEntries(
            buildCodexEntries(currentCodexCategory),
            currentCodexCategory,
          );
          codexList.innerHTML = "";

          if (!entries.length) {
            const empty = document.createElement("div");
            empty.className = "codex-detail-empty";
            empty.textContent = "情報がありません";
            codexList.appendChild(empty);
            return;
          }

          entries.forEach((entry) => {
            const card = document.createElement("button");
            card.className = `codex-entry ${entry.discovered ? "" : "undiscovered"}`;
            card.dataset.entryKey = entry.key || "";

            const nameRow = document.createElement("div");
            nameRow.className = "codex-name";
            const name = document.createElement("span");
            name.textContent = entry.discovered ? entry.name : "？？？";
            const pill = document.createElement("span");
            pill.className = "pill";
            pill.textContent = entry.discovered ? "確認済" : "未発見";
            nameRow.appendChild(name);
            nameRow.appendChild(pill);

            const desc = document.createElement("div");
            desc.className = "codex-desc";
            desc.textContent = entry.discovered ? entry.summary : "？？？";

            card.appendChild(nameRow);
            card.appendChild(desc);
            card.onclick = () => openCodexDetail(entry);
            codexList.appendChild(card);
          });
        }

        function renderCodexEquipmentPreview(template, slotKey) {
          if (!codexDetailBody || !template) return;
          const slotLabel =
            PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey || "部位不明";
          const preview = document.createElement("div");
          preview.className = "help-panel";

          const heading = document.createElement("div");
          heading.className = "option-label";
          heading.textContent = `${template.name} (${slotLabel})`;
          preview.appendChild(heading);

          const baseText = (template.base || [])
            .map((opt) => formatOptionRangeForCodex(opt))
            .filter(Boolean)
            .join(" / ");
          const baseRow = document.createElement("div");
          baseRow.className = "option-value";
          baseRow.textContent = baseText ? `基礎: ${baseText}` : "基礎情報なし";
          preview.appendChild(baseRow);

          if (template.unique?.name || template.unique?.effect) {
            const uniqueRow = document.createElement("div");
            uniqueRow.className = "option-value";
            const effectText = [template.unique?.name, template.unique?.effect]
              .filter(Boolean)
              .join(" / ");
            uniqueRow.textContent = effectText
              ? `固有: ${effectText}`
              : "固有効果不明";
            preview.appendChild(uniqueRow);
          }

          const existingPreview = codexDetailBody.querySelector(
            ".codex-preview-block",
          );
          if (existingPreview) existingPreview.remove();
          preview.classList.add("codex-preview-block");
          codexDetailBody.appendChild(preview);
        }

        function openCodexEquipmentEntry(key, slotKey) {
          if (!key) return;
          currentCodexCategory = "equipment";
          openCodexModal();
          const entries = sortCodexEntries(
            buildCodexEntries(currentCodexCategory),
            currentCodexCategory,
          );
          const target = entries.find((entry) => entry.key === key);
          if (target) {
            openCodexDetail(target);
            const list = document.getElementById("codex-list");
            if (list) {
              const card = Array.from(list.querySelectorAll(".codex-entry")).find(
                (el) => el.dataset.entryKey === key,
              );
              card?.scrollIntoView({ block: "nearest" });
            }
          }
          const template = getLegendaryTemplateByKey(key);
          if (template) renderCodexEquipmentPreview(template, slotKey);
        }

        function openCodexDetail(entry) {
          if (!codexDetailModal || !codexDetailBody || !codexDetailName) return;
          const discovered = !!entry.discovered;
          codexDetailName.textContent = discovered ? entry.name : "？？？";
          codexDetailBody.innerHTML = "";

          if (!discovered) {
            const row = document.createElement("div");
            row.className = "codex-detail-empty";
            row.textContent = "未発見のため詳細不明";
            codexDetailBody.appendChild(row);
          } else {
            (entry.detailRows || []).forEach((detail) => {
              const row = document.createElement("div");
              row.className = "codex-detail-row";
              const label = document.createElement("div");
              label.className = "label";
              label.textContent = detail.label;
              const value = document.createElement("div");
              value.className = "value";

              if (detail.interactive && (detail.dropTemplate || detail.dropTemplates?.length)) {
                const templates = detail.dropTemplates?.length
                  ? detail.dropTemplates
                  : detail.dropTemplate
                    ? [detail.dropTemplate]
                    : [];
                if (templates.length === 1) {
                  const btn = document.createElement("button");
                  btn.className = "mini-btn";
                  btn.textContent = detail.value || "表示";
                  const template = templates[0];
                  btn.onclick = () =>
                    openCodexEquipmentEntry(template.key, detail.dropSlot);
                  value.appendChild(btn);
                } else {
                  templates.forEach((template) => {
                    const btn = document.createElement("button");
                    btn.className = "mini-btn";
                    btn.textContent = template.name || "表示";
                    btn.onclick = () =>
                      openCodexEquipmentEntry(template.key, detail.dropSlot);
                    value.appendChild(btn);
                  });
                }
              } else {
                value.textContent = detail.value || "--";
              }

              row.appendChild(label);
              row.appendChild(value);
              codexDetailBody.appendChild(row);
            });
          }

          codexDetailModal.classList.remove("hidden");
        }

        function closeCodexDetail() {
          codexDetailModal?.classList.add("hidden");
        }

        function openCodexModal() {
          ensureCodexState();
          renderCodexTabs();
          renderCodexList();
          codexModal?.classList.remove("hidden");
        }

        function closeCodexModal() {
          codexModal?.classList.add("hidden");
          closeCodexDetail();
        }

        function getReachedBossFloors() {
          const reached = game.reachedBossFloors || {};
          const maxFloor = Math.max(1, Math.floor(game.highestFloor || 1));
          return BOSS_FLOORS.filter((floor) => reached[floor] && floor <= maxFloor);
        }

        function openBossInfoFromWarp(floor) {
          const entry = buildBossCodexEntries().find((e) => e.floor === floor);
          if (!entry) return;
          currentCodexCategory = "boss";
          renderCodexTabs();
          renderCodexList();
          openCodexDetail(entry);
          codexModal?.classList.remove("hidden");
        }

        function renderWarpOptions() {
          if (!warpBossList || !warpMaxButton || !warpCurrentFloor || !warpMaxLabel)
            return;
          recordFloorProgress();
          const currentFloor = Math.max(1, Math.floor(game.floor || 1));
          const maxFloor = Math.max(currentFloor, Math.floor(game.highestFloor || 1));
          warpCurrentFloor.textContent = currentFloor;
          warpMaxLabel.textContent = maxFloor;

          const reachedBosses = getReachedBossFloors();
          warpBossList.innerHTML = "";

          if (!reachedBosses.length) {
            const empty = document.createElement("div");
            empty.className = "warp-note";
            empty.textContent = "到達済みのボス階がありません";
            warpBossList.appendChild(empty);
          } else {
            reachedBosses.forEach((floor) => {
              const row = document.createElement("div");
              row.className = "warp-boss-row";

              const bossName = BOSS_DEFINITIONS[floor]?.name || "ボス";
              const legendaryLabel = formatBossLegendaryChanceLabel(floor);

              const btn = document.createElement("button");
              btn.textContent = `${floor}F ${bossName}へ (伝説${legendaryLabel})`;
              btn.onclick = () => warpToFloor(floor);
              row.appendChild(btn);

              const info = document.createElement("button");
              info.className = "mini-btn info-btn";
              info.textContent = "i";
              info.title = "図鑑で確認";
              info.onclick = (e) => {
                e.stopPropagation();
                openBossInfoFromWarp(floor);
              };
              row.appendChild(info);

              warpBossList.appendChild(row);
            });
          }

          warpMaxButton.textContent = `${maxFloor}F へワープ`;
          warpMaxButton.disabled = false;
          warpMaxButton.onclick = () => warpToFloor(maxFloor);
        }

        function warpToFloor(targetFloor) {
          if (!Number.isFinite(targetFloor)) return;
          const battleOngoing =
            game.enemies.some((e) => e.hp > 0) && player.hp > 0;
          if (battleOngoing) {
            log("戦闘中はワープできません", "warning");
            return;
          }
          const nextFloor = Math.max(1, Math.floor(targetFloor));
          game.floor = nextFloor;
          player.buffs.guard = 0;
          clearTurnOrderPreview();
          game.turnQueue = [];
          spawnEnemies();
          updateUI();
          log(`🌀 ${nextFloor}F へワープ`, "info");
          maybeAutoSave("ワープ");
          closeWarpModal();
        }

        function openWarpModal() {
          renderWarpOptions();
          warpModal?.classList.remove("hidden");
        }

        function closeWarpModal() {
          warpModal?.classList.add("hidden");
        }

        function openEnemyModal(enemy) {
          document.getElementById("modal-name").textContent = enemy.name;
          document.getElementById("modal-hp").textContent =
            `${roundBattleValue(enemy.hp)} / ${Math.max(1, roundBattleValue(enemy.maxHp))}`;
          document.getElementById("modal-atk").textContent = Math.ceil(
            enemy.atk,
          );
          document.getElementById("modal-def").textContent = Math.ceil(
            enemy.def,
          );
          document.getElementById("modal-spd").textContent =
            enemy.spd.toFixed(1);
          document.getElementById("modal-acc").textContent =
            `${Math.round(enemy.accuracy)}%`;
          document.getElementById("modal-evd").textContent =
            `${Math.round(enemy.evade)}%`;
          const resist = enemy.resist || {};
          const resistText = [
            `行動${Math.round(resist.control ?? 0)}%`,
            `持続${Math.round(resist.dot ?? 0)}%`,
            `弱体${Math.round(resist.debuff ?? 0)}%`,
          ].join(" / ");
          document.getElementById("modal-resist").textContent = resistText;
          const tag = document.getElementById("modal-tag");
          if (enemy.isBoss) {
            tag.textContent = "BOSS";
            tag.style.display = "inline-flex";
          } else if (enemy.archetypes?.length) {
            tag.textContent = enemy.archetypeLabel || "アーキ";
            tag.style.display = "inline-flex";
          } else {
            tag.style.display = "none";
          }
          if (modalFeature) {
            const feature = enemy.baseFlavor || enemy.flavor || "特徴情報なし";
            modalFeature.textContent = feature;
            modalFeature.classList.toggle("hidden", !feature);
          }
          renderBossLegendarySection(enemy);
          enemyModal.classList.remove("hidden");
        }

        function closeEnemyModal() {
          enemyModal.classList.add("hidden");
        }

        function openArchetypeModal(enemy) {
          if (!enemy?.archetypes?.length) return;
          const archetypeNames =
            enemy.archetypeName ||
            enemy.archetypes.map((a) => a.name).join(" / ") ||
            enemy.archetypeLabel ||
            "";
          const archetypeFlavors =
            enemy.archetypeFlavor ||
            enemy.archetypes
              .map((a) => a.flavor)
              .filter(Boolean)
              .join("｜") ||
            "特徴不明";
          archetypeModalName.textContent = archetypeNames;
          archetypeModalDesc.textContent = archetypeFlavors;
          archetypeModalAbilities.innerHTML = "";

          enemy.archetypes.forEach((entry, index) => {
            const variant = ENEMY_VARIANTS.find((v) => v.key === entry.key);
            const header = document.createElement("div");
            header.className = "option-value";
            header.textContent = `#${index + 1} ${entry.name}`;
            archetypeModalAbilities.appendChild(header);

            const baseModifierText = describeModifiers(
              entry.baseModifiers || variant?.baseModifiers,
            );
            const baseRow = document.createElement("div");
            baseRow.className = "option-value";
            baseRow.textContent = baseModifierText
              ? `基礎補正: ${baseModifierText}`
              : "基礎補正: なし";
            archetypeModalAbilities.appendChild(baseRow);

            const abilityList = entry.abilities?.length
              ? entry.abilities
              : (variant?.abilities || [])
                  .filter(Boolean)
                  .slice(0, entry.rank || 1);

            if (!abilityList.length) {
              const none = document.createElement("div");
              none.className = "option-value";
              none.textContent = "追加能力なし";
              archetypeModalAbilities.appendChild(none);
            } else {
              abilityList.forEach((ability) => {
                const row = document.createElement("div");
                row.className = "option-value";
                const detail = describeModifiers(ability.modifiers);
                row.textContent = detail
                  ? `・${ability.label}: ${detail}`
                  : `・${ability.label}`;
                archetypeModalAbilities.appendChild(row);
              });
            }

            const statusDetail = describeArchetypeStatus(
              ARCHETYPE_STATUS_ON_HIT[entry.key],
              entry.rank || 1,
            );
            if (statusDetail) {
              const statusRow = document.createElement("div");
              statusRow.className = "option-value";
              statusRow.textContent = `状態異常付与: ${statusDetail}`;
              archetypeModalAbilities.appendChild(statusRow);
            }
          });

          archetypeModal?.classList.remove("hidden");
        }

        function closeArchetypeModal() {
          archetypeModal?.classList.add("hidden");
        }

        function openPotionModal(potion) {
          if (!potion) return;
          const { useCost, refund } = calculatePotionConsumption(potion);
          const maxFullness = potion.maxFullness ?? 100;
          const currentFill = Math.max(
            0,
            Math.min(maxFullness, potion.fullness ?? maxFullness),
          );
          potionModalName.textContent = potion.name;
          const typeLabel =
            potion.category === "buff"
              ? "バフ"
              : potion.type === "hp"
                ? "HP回復"
                : potion.type === "mp"
                  ? "MP回復"
                  : "特殊";
          potionModalType.textContent = typeLabel;
          potionModalEffect.textContent = describePotionEffect(potion);
          potionModalRarity.textContent = potion.rarityLabel || "";
          applyItemRarityColor(potionModalRarity, { potion });
          const costText = refund > 0
            ? `1回 ${useCost}% 消費（${refund}%還元）`
            : `1回 ${useCost}% 消費`;
          potionModalCost.textContent = costText;
          potionModalFill.textContent = `${Math.round(currentFill)}% / ${maxFullness}%`;
          potionModalPrefix.textContent = describePotionAffix(potion.prefix);
          potionModalSuffix.textContent = describePotionAffix(potion.suffix);
          potionModalDesc.textContent = potion.summary || potion.desc || "";
          potionModal.classList.remove("hidden");
        }

        function closePotionModal() {
          potionModal.classList.add("hidden");
        }

        function openSkillInfoModal(skill) {
          if (!skill) return;
          const baseCooldown = skill.activation?.cooldown ?? 0;
          const effectiveCooldown =
            baseCooldown > 0 ? getEffectiveSkillCooldown(skill) : 0;
          const cooldownText = baseCooldown
            ? `基礎 ${baseCooldown}T / 実効 ${effectiveCooldown}T`
            : "CTなし";
          const mpCost = skill.activation?.mpCost ?? 0;
          const mpCostText = mpCost > 0 ? `MP${mpCost}` : "MP消費なし";
          const locked = !isSkillUnlocked(skill);
          skillInfoName.textContent = skill.name;
          skillInfoType.textContent = `${skill.type === "active" ? "アクティブ" : "パッシブ"} (${skill.category || "分類不明"})`;
          skillInfoCooldown.textContent = `${cooldownText} / 消費: ${mpCostText}`;
          skillInfoLevel.textContent = `${skill.level || 0} / ${skill.max ?? "--"}`;
          skillInfoEffect.textContent =
            skill.activation?.effect || skill.desc || "効果未設定";
          const perLevelText = skill.scaling?.perLevel
            ? `毎Lv: ${formatSkillBonusText(skill.scaling.perLevel)}`
            : "毎Lv効果なし";
          const currentText = describeSkillBonusAtLevel(skill, skill.level, {
            locked,
            label: "現在合計",
          });
          const nextText = describeSkillNextBonus(skill, { locked });
          skillInfoNote.innerHTML = `<div>${perLevelText}</div><div>${currentText}</div><div>${nextText}</div>`;
          skillInfoModal?.classList.remove("hidden");
        }

        function closeSkillInfoModal() {
          skillInfoModal?.classList.add("hidden");
        }

        function resetSkillBonuses() {
          calculateSkillBonuses();
          recalcDerivedStats();
        }

        function resetSkills() {
          const spent = Object.values(skills).reduce(
            (sum, skill) => sum + skill.level,
            0,
          );
          if (spent === 0) {
            log("リセットするスキルがありません", "info");
            return;
          }
          Object.values(skills).forEach((skill) => {
            skill.level = 0;
          });
          player.activeSkillSlots = Array.from(
            { length: ACTIVE_SKILL_SLOT_LIMIT },
            () => ({ skillKey: null, cooldownRemaining: 0 }),
          );
          resetSkillBonuses();
          player.skillPoints += spent;
          updateUI();
          renderActiveSkillLoadout();
          renderSkillSummary();
          log("スキルをリセットしました", "info");
          maybeAutoSave("スキルリセット");
        }

        function openPlayerModal() {
          updateUI();
          setPlayerModalPage("status");
          playerModal.classList.remove("hidden");
        }

        function closePlayerModal() {
          playerModal.classList.add("hidden");
        }

        function openSkillsModal() {
          updateUI();
          skillsModal.classList.remove("hidden");
        }

        function closeSkillsModal() {
          skillsModal.classList.add("hidden");
          skillSummaryVisible = false;
          updateSkillSummaryVisibility();
        }

        function openWeaponEnhanceModal(targetItem = null) {
          weaponEnhanceTarget = targetItem || player.equipment?.weapon || null;
          renderWeaponEnhancePanel();
          weaponEnhanceModal?.classList.remove("hidden");
        }

        function closeWeaponEnhanceModal() {
          weaponEnhanceTarget = null;
          if (enhanceAnimationState.active) {
            finishEnhanceAnimation();
          }
          weaponEnhanceModal?.classList.add("hidden");
        }

        function openInventoryModal() {
          renderInventoryFilters();
          renderInventory();
          inventoryModal.classList.remove("hidden");
        }

        function closeInventoryModal() {
          closeInventoryItemModal();
          inventoryModal.classList.add("hidden");
        }

        function clearComparisonResult() {
          if (!inventoryCompareResult) return;
          inventoryCompareResult.innerHTML = "";
          inventoryCompareResult.style.display = "none";
        }

        function renderComparisonResult(slotKey, item) {
          if (!inventoryCompareResult || !item?.equipment) return;
          const slotName = PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey;
          const equipped = player.equipment?.[slotKey];
          const diffs = diffEquipmentBonuses(item, equipped).sort(
            (a, b) => b.delta - a.delta,
          );

          inventoryCompareResult.innerHTML = "";
          inventoryCompareResult.style.display = "block";

          const heading = document.createElement("div");
          heading.className = "option-label";
          heading.textContent = `${slotName}との比較`;
          inventoryCompareResult.appendChild(heading);

          const currentRow = document.createElement("div");
          currentRow.className = "subtle";
          const currentLabel = document.createElement("span");
          currentLabel.textContent = "現在";
          const currentName = document.createElement("span");
          currentName.textContent = equipped?.name || "なし";
          applyItemRarityColor(currentName, equipped);
          currentRow.appendChild(currentLabel);
          currentRow.appendChild(currentName);
          const currentEnhance = createEnhanceBadge(equipped, {
            includeZero: true,
          });
          if (currentEnhance) currentRow.appendChild(currentEnhance);
          inventoryCompareResult.appendChild(currentRow);

          const nextRow = document.createElement("div");
          nextRow.className = "subtle";
          const nextLabel = document.createElement("span");
          nextLabel.textContent = "候補";
          const nextName = document.createElement("span");
          nextName.textContent = item.name;
          applyItemRarityColor(nextName, item);
          nextRow.appendChild(nextLabel);
          nextRow.appendChild(nextName);
          const nextEnhance = createEnhanceBadge(item, { includeZero: true });
          if (nextEnhance) nextRow.appendChild(nextEnhance);
          inventoryCompareResult.appendChild(nextRow);

          if (!diffs.length) {
            const row = document.createElement("div");
            row.className = "option-value";
            row.textContent = "ステータス変化なし";
            inventoryCompareResult.appendChild(row);
            return;
          }

          const list = document.createElement("div");
          list.className = "stat-diff-list";
          diffs.forEach((diff) => {
            const row = document.createElement("div");
            row.className = `stat-diff ${diff.delta > 0 ? "positive" : "negative"}`;
            const label = document.createElement("span");
            label.textContent = diff.label;
            const value = document.createElement("span");
            value.textContent = diff.text.replace(`${diff.label} `, "");
            row.appendChild(label);
            row.appendChild(value);
            list.appendChild(row);
          });
          inventoryCompareResult.appendChild(list);
        }

        function openInventoryItemModal(item, index) {
          if (!item) return;
          currentInventorySelection = { item, index, id: item.id };
          normalizeEquipmentItem(item);
          clearComparisonResult();
          inventoryItemName.innerHTML = "";
          const nameSpan = document.createElement("span");
          nameSpan.textContent = item?.name || "不明なアイテム";
          applyItemRarityColor(nameSpan, item);
          inventoryItemName.appendChild(nameSpan);
          const badge = createEnhanceBadge(item, { includeZero: true });
          if (badge) inventoryItemName.appendChild(badge);
          inventoryItemDesc.textContent = item?.desc || "説明なし";

          const updateMeta = () => {
            const metaParts = [];
            if (item.favorite) metaParts.push("★お気に入り");
            if (isItemEquipped(item)) metaParts.push("装備中");
            const qty = typeof item?.quantity === "number" ? item.quantity : 1;
            if (qty > 1) metaParts.push(`所持: ×${qty}`);
            if (item.equipment?.rarityLabel)
              metaParts.push(item.equipment.rarityLabel);
            if (item.potion?.rarityLabel)
              metaParts.push(item.potion.rarityLabel);
            inventoryItemMeta.textContent = metaParts.join(" / ");
            inventoryItemMeta.style.display = metaParts.length
              ? "flex"
              : "none";
          };
          updateMeta();

          const sellPrice = calculateItemSellValue(item);

          inventoryItemDetail.innerHTML = "";
          if (item.type === "potion" && item.potion) {
            const { useCost, refund } = calculatePotionConsumption(item.potion);
            const maxFullness = item.potion.maxFullness ?? 100;
            const currentFill = Math.max(
              0,
              Math.min(maxFullness, item.potion.fullness ?? maxFullness),
            );
            const fields = [
              {
                label: "種類",
                value:
                  item.potion.category === "buff"
                    ? "バフ"
                    : item.potion.type === "hp"
                      ? "HP回復"
                      : item.potion.type === "mp"
                        ? "MP回復"
                        : "特殊",
              },
              {
                label: "ランク",
                value: item.potion.rarityLabel || item.potion.rarity,
              },
              { label: "効果", value: describePotionEffect(item.potion) },
              {
                label: "前置詞",
                value: describePotionAffix(item.potion.prefix),
              },
              {
                label: "後置詞",
                value: describePotionAffix(item.potion.suffix),
              },
              {
                label: "消費",
                value:
                  refund > 0
                    ? `1回 ${useCost}% 消費（${refund}%還元）`
                    : `1回 ${useCost}% 消費`,
              },
              {
                label: "残量",
                value: `${Math.round(currentFill)}% / ${maxFullness}%`,
              },
            ];
            if (sellPrice > 0) {
              fields.push({
                label: "売値",
                value: `${formatGold(sellPrice)}G`,
              });
            }
            fields.forEach((f) => {
              const row = document.createElement("div");
              row.textContent = `${f.label} ${f.value}`;
              inventoryItemDetail.appendChild(row);
            });
          } else if (item.type === "equipment" && item.equipment) {
            const rarity = item.equipment.rarityLabel || item.equipment.rarity;
            const slotLabel =
              EQUIPMENT_SLOTS[item.equipment.slot]?.label ||
              item.equipment.slot;
            const fields = [
              { label: "部位", value: slotLabel },
              { label: "レア度", value: rarity },
            ];
            const level = Math.max(0, item.enhanceLevel || 0);
            const broken = item.enhanceBroken;
            if (level > 0 || broken) {
              fields.push({
                label: "強化値",
                value: `${broken ? "破損中 / " : ""}+${level}`,
              });
            }
            if (sellPrice > 0) {
              fields.push({
                label: "売値",
                value: `${formatGold(sellPrice)}G`,
              });
            }
            fields.forEach((f) => {
              const row = document.createElement("div");
              row.textContent = `${f.label} ${f.value}`;
              inventoryItemDetail.appendChild(row);
            });

            const appendOptions = (title, options) => {
              if (!options?.length) return;
              const block = document.createElement("div");
              block.className = "equipment-option-list";
              const heading = document.createElement("div");
              heading.className = "option-label";
              heading.textContent = title;
              block.appendChild(heading);
              options.forEach((option) => {
                const line = document.createElement("div");
                line.className = "option-value";
                line.textContent = formatEquipmentValue(
                  getEnhancedEntry(option, item),
                );
                block.appendChild(line);
              });
              inventoryItemDetail.appendChild(block);
            };

            const appendAffix = (label, affix, kind) => {
              if (!affix) return;
              const hasOptions = affix.options?.length;
              const effects = formatAffixEffects(affix.effects);
              if (!hasOptions && effects.length === 0) return;
              const block = document.createElement("div");
              block.className = "equipment-option-list";
              const heading = document.createElement("div");
              heading.className = "option-label";
              heading.textContent = buildTitleLabel(label, affix, kind);
              block.appendChild(heading);
              if (hasOptions) {
                affix.options.forEach((option) => {
                  const line = document.createElement("div");
                  line.className = "option-value";
                  line.textContent = formatEquipmentValue(
                    getEnhancedEntry(option, item),
                  );
                  block.appendChild(line);
                });
              }
              effects.forEach((text) => {
                const line = document.createElement("div");
                line.className = "option-value";
                line.textContent = text;
                block.appendChild(line);
              });
              inventoryItemDetail.appendChild(block);
            };

            if (item.equipment.uniqueOptions?.length) {
              const uniqueBlock = document.createElement("div");
              uniqueBlock.className = "equipment-option-list";
              const heading = document.createElement("div");
              heading.className = "option-label";
              heading.textContent = "固有オプション";
              uniqueBlock.appendChild(heading);
              item.equipment.uniqueOptions.forEach((opt) => {
                const line = document.createElement("div");
                line.className = "option-value";
                line.textContent = `${opt.name}: ${opt.effect}`;
                uniqueBlock.appendChild(line);
              });
              inventoryItemDetail.appendChild(uniqueBlock);
            }

            appendOptions("基礎オプション", item.equipment.baseOptions);
            appendOptions("ランダムオプション", item.equipment.randomOptions);
            appendAffix("前称号", item.equipment.prefix, "prefix");
            appendAffix("後称号", item.equipment.suffix, "suffix");
          } else {
            const empty = document.createElement("div");
            empty.className = "help-panel";
            empty.textContent = "詳細情報はありません";
            empty.style.gridColumn = "1 / -1";
            inventoryItemDetail.appendChild(empty);
          }

          const renderActions = () => {
            inventoryItemActions.innerHTML = "";
            const favoriteBtn = document.createElement("button");
            const updateFavoriteButton = () => {
              favoriteBtn.textContent = item.favorite
                ? "★ お気に入り中"
                : "☆ お気に入り登録";
              favoriteBtn.ariaPressed = item.favorite ? "true" : "false";
            };
            favoriteBtn.onclick = () => {
              item.favorite = !item.favorite;
              renderInventory();
              updateFavoriteButton();
              updateMeta();
              renderActions();
            };
            updateFavoriteButton();
            inventoryItemActions.appendChild(favoriteBtn);

            let sellBtn = null;
            const refreshSellButton = () => {
              if (!sellBtn) return;
              const equipped = isItemEquipped(item);
              const disabled = equipped || item.favorite;
              const label = disabled
                ? equipped
                  ? "装備中は売却不可"
                  : "お気に入りは売却不可"
                : `売却 (${formatGold(sellPrice)}G)`;
              sellBtn.textContent = label;
              sellBtn.disabled = disabled;
            };

            if (
              item.type === "potion" &&
              item.potion &&
              player.potions?.length
            ) {
              player.potions.forEach((p, slot) => {
                const btn = document.createElement("button");
                const isSame = p?.id === item.potion.id;
                btn.textContent = isSame
                  ? `スロット${slot + 1}（装備中）`
                  : `スロット${slot + 1}に装備`;
                btn.disabled = isSame;
                btn.onclick = () => {
                  equipPotionFromInventory(index, slot);
                  closeInventoryItemModal();
                };
                inventoryItemActions.appendChild(btn);
              });
            } else if (item.type === "equipment" && item.equipment) {
              const slotLabel =
                EQUIPMENT_SLOTS[item.equipment.slot]?.label ||
                item.equipment.slot;
              const addEquipButtons = (slotKey) => {
                const slotName =
                  PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotLabel;
                const equipped = player.equipment?.[slotKey];
                const isSame = equipped?.id === item.id;
                const broken = !!item.enhanceBroken;
                const equipBtn = document.createElement("button");
                equipBtn.textContent = broken
                  ? `${slotName}に装備できません（破損中）`
                  : isSame
                    ? `${slotName}（装備中）`
                    : `${slotName}に装備`;
                equipBtn.disabled = isSame || broken;
                equipBtn.onclick = () => {
                  equipItem(slotKey, item);
                  log(`🛡️ ${item.name} を${slotName}に装備した`, "good");
                  renderInventory();
                  clearComparisonResult();
                  updateMeta();
                  renderActions();
                };
                inventoryItemActions.appendChild(equipBtn);

                const compareBtn = document.createElement("button");
                compareBtn.textContent = `${slotName}と比較`;
                compareBtn.onclick = () =>
                  renderComparisonResult(slotKey, item);
                inventoryItemActions.appendChild(compareBtn);

                if (equipped) {
                  const unequipBtn = document.createElement("button");
                  unequipBtn.textContent = `${slotName}を外す`;
                  unequipBtn.onclick = () => {
                    unequipItem(slotKey);
                    log(`🧤 ${slotName}の装備を外した`, "info");
                    renderInventory();
                    clearComparisonResult();
                    updateMeta();
                    renderActions();
                  };
                  inventoryItemActions.appendChild(unequipBtn);
                }
              };

              if (item.equipment.slot === "accessory") {
                ["accessory1", "accessory2"].forEach(addEquipButtons);
              } else {
                addEquipButtons(item.equipment.slot);
              }

              const enhanceBtn = document.createElement("button");
              enhanceBtn.textContent = "強化する";
              enhanceBtn.onclick = () => openWeaponEnhanceModal(item);
              inventoryItemActions.appendChild(enhanceBtn);
            } else {
              const note = document.createElement("div");
              note.className = "help-panel";
              note.textContent = "装備可能なスロットがありません";
              inventoryItemActions.appendChild(note);
            }

            if (sellPrice > 0) {
              sellBtn = document.createElement("button");
              refreshSellButton();
              sellBtn.onclick = () => sellInventoryItem(index, item, sellPrice);
              inventoryItemActions.appendChild(sellBtn);
            }
          };

          renderActions();
          inventoryItemModal?.classList.remove("hidden");
        }

        function closeInventoryItemModal() {
          clearComparisonResult();
          currentInventorySelection = null;
          inventoryItemModal?.classList.add("hidden");
        }

        function rerenderInventoryItemModal() {
          if (!currentInventorySelection) return;
          const items = player.inventory?.items || [];
          const { item, index, id } = currentInventorySelection;
          const currentIndex = items.findIndex((entry) =>
            id ? entry.id === id : entry === item,
          );
          const targetIndex = currentIndex >= 0 ? currentIndex : index;
          const targetItem = items[targetIndex] || item;
          openInventoryItemModal(targetItem, targetIndex);
        }

        function promptPlayerTurn() {
          restoreAttackCounts();
          game.awaitingInput = true;
          if (!activeTurnActor) {
            activeTurnActor = { type: "player", id: null };
          }
          setCurrentActorEntry(activeTurnActor);
          renderTurnOrder();
          renderActions();
        }

        function endPlayerTurn() {
          game.awaitingInput = false;
          finalizeLegendaryPlayerTurn();
          finalizeTurn(player);
          renderActions();
          advanceTurnOrderPreview(
            activeTurnActor || { type: "player", id: null },
          );
          setTimeout(() => nextTurn(), 350);
        }

        function choosePlayerAttackTargets(maxTargets = 1) {
          const aliveEnemies = game.enemies.filter((e) => e.hp > 0);
          if (aliveEnemies.length === 0) return [];
          const confused = hasStatus(player, "confusion");
          const pool = confused ? [...aliveEnemies, player] : aliveEnemies;
          if (!pool.length) return [];
          const count = Math.min(
            Math.max(1, Math.floor(maxTargets || 1)),
            pool.length,
          );
          if (!confused) {
            return pool.slice(0, count);
          }
          const available = [...pool];
          const targets = [];
          for (let i = 0; i < count; i += 1) {
            const pickIndex =
              available.length === 1
                ? 0
                : Math.floor(Math.random() * available.length);
            const chosen = available.splice(pickIndex, 1)[0];
            if (chosen) targets.push(chosen);
          }
          return targets;
        }

        function chooseTargetForPlayer() {
          const targets = choosePlayerAttackTargets(1);
          return targets[0] || null;
        }

        function chooseTargetForEnemy(enemy) {
          const allies = game.enemies.filter(
            (e) => e.hp > 0 && e.id !== enemy.id,
          );
          if (
            hasStatus(enemy, "confusion") &&
            (allies.length > 0 || player.hp > 0)
          ) {
            const pool = [player, ...allies, enemy];
            return pool[Math.floor(Math.random() * pool.length)];
          }
          return player;
        }

        function getAccuracyWithStatus(entity) {
          const debuff = getStatus(entity, "accuracyDown");
          let acc = entity.accuracy || 90;
          if (debuff) {
            acc *=
              1 -
              (debuff.potency ??
                STATUS_DEFINITIONS.accuracyDown.potency ??
                0.15);
          }
          return Math.max(30, acc);
        }

        function getEvasionWithStatus(entity) {
          const debuff = getStatus(entity, "evasionDown");
          let eva = entity.evade || 0;
          if (debuff) {
            eva *=
              1 -
              (debuff.potency ??
                STATUS_DEFINITIONS.evasionDown.potency ??
                0.15);
          }
          return Math.max(0, eva);
        }

        function attemptHit(attacker, defender) {
          const acc = getAccuracyWithStatus(attacker);
          const eva = getEvasionWithStatus(defender);
          const hitChance = Math.max(20, Math.min(98, 90 + (acc - eva) * 0.4));
          return Math.random() * 100 < hitChance;
        }

        function rollCritical(attacker) {
          const isPlayer = attacker === player;
          const derived = isPlayer
            ? lastDerivedStats || recalcDerivedStats()
            : null;
          const rate = isPlayer
            ? (derived?.critRate.total ?? 0)
            : (attacker?.critRate ?? 12);
          const critChance = Math.max(0, Math.min(100, rate));
          const isCritical = Math.random() * 100 < critChance;
          const baseMultiplier = isPlayer ? 1.5 : 1.4;
          const bonus = isPlayer
            ? Math.max(0, Math.min(50, derived?.critDamage.total ?? 0))
            : Math.max(0, Math.min(50, attacker?.critDamage ?? 0));
          const multiplier = isCritical ? baseMultiplier + bonus / 100 : 1;
          return { isCritical, multiplier };
        }

        function calcDamage(
          attacker,
          defender,
          { type = "physical", includeKnowledgeForPlayer = false } = {},
        ) {
          const variance = 0.85 + Math.random() * 0.3;
          const attackDebuff =
            type === "physical"
              ? getStatus(attacker, "physAttackDown")
              : getStatus(attacker, "magAttackDown");
          const baseAttack =
            type === "physical"
              ? attacker.atk
              : attacker.magAtk || attacker.atk;
          let attackPower =
            baseAttack * (attackDebuff ? 1 - (attackDebuff.potency ?? 0.2) : 1);
          if (
            includeKnowledgeForPlayer &&
            type === "physical" &&
            attacker === player
          ) {
            const knowledge = statTotal("int");
            const knowledgeBonus = knowledge * 0.5;
            attackPower += knowledgeBonus;
          }
          if (hasStatus(attacker, "curse")) {
            attackPower *= 0.9;
          }
          let defense =
            type === "physical"
              ? defender.def
              : defender.magDef || defender.def;
          const defenseDown =
            type === "physical"
              ? getStatus(defender, "physDefenseDown")
              : getStatus(defender, "magDefenseDown");
          if (defenseDown) {
            defense *= 1 - (defenseDown.potency ?? 0.2);
          }
          let raw = Math.max(1, attackPower * variance - defense);
          if (attacker === player) {
            raw *= getPlayerLegendaryDamageMultiplier(defender);
          }
          return Math.max(1, Math.round(raw));
        }

        function applyDamage(
  target,
  amount,
  {
    type = "physical",
    source = "",
    isDot = false,
    attacker = null,
    isCritical = false,
  } = {},
) {
  let final = Math.max(0, Math.round(amount));
  const reduction = Math.max(0, Math.min(90, target.damageReduction || 0));
  if (reduction > 0) {
    final = Math.round(final * (1 - reduction / 100));
  }

  if (target === player) {
    const legendaryMitigation = getPlayerLegendaryDamageTakenMultiplier();
    if (legendaryMitigation !== 1) {
      final = Math.round(final * legendaryMitigation);
    }
  }

  const blockChance = !isDot ? Math.max(0, Math.min(100, target.block || 0)) : 0;
  const blocked = blockChance > 0 && Math.random() * 100 < blockChance;
  if (blocked) {
    final = Math.round(final * 0.5);
  }

  if (blocked && target === player) {
    getLegendaryOptionsByTrigger("block").forEach((option) => {
      executeLegendaryPayload(option, { target: player, trigger: "block" });
    });
  }

  if (
    target === player &&
    player.buffs.guard > 0 &&
    !hasStatus(player, "seal")
  ) {
    final = Math.round(final * 0.7);
  }

  let barrierAbsorbed = 0;
  if (
    final > 0 &&
    typeof target.barrierRemaining === "number" &&
    target.barrierRemaining > 0
  ) {
    barrierAbsorbed = Math.min(target.barrierRemaining, final);
    target.barrierRemaining -= barrierAbsorbed;
    final -= barrierAbsorbed;
  }

  final = Math.max(0, Math.round(final));
  target.hp = Math.max(0, target.hp - final);

  if (!isDot && final > 0 && hasStatus(target, "sleep")) {
    removeStatus(target, "sleep");
    log(`${target.name} は攻撃を受けて目を覚ました`, "info");
  }

  if (target === player) {
    flashBar("hp-bar");
    const playerBar = document.getElementById("hp-bar")?.parentElement;
    playerBar?.classList.add("popup-anchor");

    if (final > 0) {
      showDamagePopup(playerBar, final, "player", {
        isCritical,
        target: "player",
      });
    }

    if (barrierAbsorbed > 0) {
      showDamagePopup(playerBar, barrierAbsorbed, "player", {
        isCritical,
        target: "player",
      });
    }
  } else {
    if (final > 0) triggerEnemyHit(target, final, { isCritical });
    if (barrierAbsorbed > 0) {
      triggerEnemyHit(target, barrierAbsorbed, { isCritical });
    }
    updateEnemyCardHp(target);
  }

  if (blocked && final >= 0) {
    log(
      `${target.name} はブロックして被ダメージを軽減`,
      target === player ? "good" : "info",
    );
  }
  if (barrierAbsorbed > 0) {
    log(
      `${target.name} のバリアが ${barrierAbsorbed} ダメージを吸収`,
      target === player ? "good" : "info",
    );
  }

  const canLifeSteal =
    !isDot &&
    attacker &&
    attacker !== target &&
    typeof attacker.lifeSteal === "number" &&
    attacker.lifeSteal > 0 &&
    attacker.maxHp;

  if (canLifeSteal) {
    const healAmount = Math.max(
      0,
      roundBattleValue(final * (attacker.lifeSteal / 100)),
    );
    if (healAmount > 0) {
      const healed = applyHealing(attacker, healAmount);
      if (healed > 0) {
        const logLevel = attacker === player ? "good" : "info";
        log(`🩸 HP吸収で ${healed} 回復`, logLevel);
      }
    }
  }

  return final;
}


        function applyHealing(target, amount) {
          if (!target || amount <= 0) return 0;
          const maxHp = Math.max(0, roundBattleValue(target.maxHp ?? 0));
          if (maxHp <= 0) return 0;
          const currentHp = Math.max(0, roundBattleValue(target.hp ?? 0));
          const missing = Math.max(0, maxHp - currentHp);
          const healed = Math.min(
            Math.max(0, roundBattleValue(amount)),
            missing,
          );
          if (healed <= 0) return 0;
          target.hp = Math.min(maxHp, currentHp + healed);
          if (target === player) {
            flashBar("hp-bar");
            const playerBar = document.getElementById("hp-bar")?.parentElement;
            showHealPopup(playerBar, healed);
          } else {
            updateEnemyCardHp(target);
            const card = findEnemyCard(target);
            showHealPopup(card, healed);
          }
          return healed;
        }

        function onEnemyDefeated(enemy, { cause = "" } = {}) {
          if (!enemy || enemy.defeated) return;
          enemy.defeated = true;
          if (enemy.isBoss) {
            const key = getBossRecordKey(enemy);
            if (!game.bossKillRecords) game.bossKillRecords = {};
            game.bossKillRecords[key] = (game.bossKillRecords[key] ?? 0) + 1;
          }
          const baseGold = Math.max(
            1,
            Math.round(5 + game.floor * 2 + (enemy.isBoss ? 20 : 0)),
          );
          grantGold(baseGold, { source: cause || "撃破" });
          if (enemy.expReward) {
            grantExp(enemy.expReward, { source: cause || enemy.name });
          }
          attemptEnemyDrop(enemy);
          refillPotionsOnKill();
          updateUI();
        }

        function usePotion(index) {
          if (!game.awaitingInput) return;
          if (!player.potions || !player.potions[index]) return;
          const enemiesAlive = game.enemies.some((e) => e.hp > 0);
          if (!enemiesAlive) {
            log("ポーションは戦闘中のみ使用できます", "warning");
            return;
          }
          const potion = player.potions[index];
          const maxFullness = potion.maxFullness ?? 100;
          const { useCost, refund } = calculatePotionConsumption(potion);
          potion.fullness = Math.max(
            0,
            Math.min(maxFullness, potion.fullness ?? maxFullness),
          );
          if (potion.fullness < useCost) {
            log("ポーションの残量が足りない…", "warning");
            return;
          }

          const derived = recalcDerivedStats();
          if (potion.type === "hp") {
            if (player.hp >= derived.maxHp.total) {
              log("HPは十分に残っている", "info");
              return;
            }
            const heal = Math.min(
              potion.amount,
              derived.maxHp.total - player.hp,
            );
            const healed = applyHealing(player, heal);
            log(
              `${potion.icon || "🧪"} ${potion.name}を飲んでHPを${healed}回復`,
              "good",
            );
          } else if (potion.type === "mp") {
            if (player.mp >= derived.maxMp.total) {
              log("MPは十分に残っている", "info");
              return;
            }
            const restored = Math.min(
              potion.amount,
              derived.maxMp.total - player.mp,
            );
            player.mp = Math.min(derived.maxMp.total, player.mp + restored);
            log(
              `${potion.icon || "🔮"} ${potion.name}を飲んでMPを${restored}回復`,
              "good",
            );
          } else {
            log(
              `${potion.icon || "🧪"} ${potion.name}を使用: ${describePotionEffect(potion)}`,
              "good",
            );
          }

          potion.fullness = Math.max(0, potion.fullness - useCost);
          if (refund > 0) {
            potion.fullness = Math.min(maxFullness, potion.fullness + refund);
            log(`💧 消費の${refund}%が還元された`, "info");
          }
          updateUI();
        }

        function refillPotionsOnKill() {
          if (!player.potions?.length) return false;
          let restored = false;
          player.potions.forEach((potion) => {
            const maxFullness = potion.maxFullness ?? 100;
            const current = Math.max(
              0,
              Math.min(maxFullness, potion.fullness ?? maxFullness),
            );
            const next = Math.min(maxFullness, current + POTION_REFILL_ON_KILL);
            if (next > current) {
              potion.fullness = next;
              restored = true;
            } else {
              potion.fullness = current;
            }
          });
          if (restored) {
            log("💧 ポーションの残量が少し回復した", "info");
          }
          return restored;
        }

        function tryAutoSkillFromAttack() {
          if (!game.autoSkillEnabled) return false;
          const slots = player.activeSkillSlots || [];
          for (let i = 0; i < slots.length; i += 1) {
            const used = performActiveSkill(i, {
              suppressWarnings: true,
              endTurnOnSuccess: true,
              saveReason: "自動スキル使用",
            });
            if (used) return true;
          }
          return false;
        }

        function playerAttack() {
          if (!game.awaitingInput) return;
          const attacks = Math.max(
            0,
            Math.floor(player.attacksRemaining ?? player.attackCount ?? 0),
          );
          const targetsPerAttack = Math.max(
            1,
            Math.floor(player.attackTargets ?? 1),
          );
          if (attacks <= 0) {
            log("攻撃回数が残っていない…", "warning");
            return;
          }
          if (tryAutoSkillFromAttack()) return;
          player.attacksRemaining = attacks;
          let acted = false;
          for (let i = 0; i < attacks; i += 1) {
            const targets = choosePlayerAttackTargets(targetsPerAttack);
            if (!targets.length) break;
            acted = true;
            const attackLabel =
              attacks > 1 ? `(${i + 1}/${attacks})` : "";
            for (let j = 0; j < targets.length; j += 1) {
              const target = targets[j];
              const targetLabel =
                targets.length > 1 ? ` [${j + 1}/${targets.length}]` : "";
              const forcedHit = consumeLegendaryGuaranteedHit();
              const hit = forcedHit ? true : attemptHit(player, target);
              if (!hit) {
                log(
                  `⚔️ あなたの攻撃${attackLabel}${targetLabel}は外れた…`,
                  "warning",
                );
                continue;
              }
              const { isCritical, multiplier } = rollCritical(player);
              const dmg = Math.round(
                calcDamage(player, target, { includeKnowledgeForPlayer: true }) *
                  multiplier,
              );
              const dealt = applyDamage(target, dmg, {
                source: "player",
                attacker: player,
                isCritical,
              });
              const extraAttacks = applyLegendaryHitEffects(target, {
                isSkill: false,
                isCritical,
              });
              if (extraAttacks > 0) {
                attacks += extraAttacks;
              }
              const targetName = target === player ? "自分" : target.name;
              const critLabel = isCritical ? "💥 クリティカル！ " : "";
              log(
                `${critLabel}⚔️ あなたの攻撃${attackLabel}${targetLabel}！ ${targetName} に ${dealt} ダメージ`,
                target === player ? "warning" : "player",
              );
              if (target !== player && target.hp <= 0) {
                log(`${target.name} を倒した！`, "good");
                onEnemyDefeated(target, { cause: "撃破" });
                checkVictory();
                if (!game.enemies.some((e) => e.hp > 0)) break;
              }
            }
            player.attacksRemaining = Math.max(0, attacks - i - 1);
          }
          if (!acted) return;
          updateUI();
          maybeAutoSave("攻撃");
          endPlayerTurn();
        }

        function canUseActiveSkill(
          slotIndex,
          { suppressWarnings = false } = {},
        ) {
          if (!game.awaitingInput) return { canUse: false, reason: "not-turn" };
          if (hasStatus(player, "silence")) {
            if (!suppressWarnings) log("沈黙中でスキルが使えない！", "warning");
            return { canUse: false, reason: "silence" };
          }

          const slot = player.activeSkillSlots?.[slotIndex];
          const skill = slot?.skillKey ? skills[slot.skillKey] : null;
          if (!skill || skill.type !== "active") {
            if (!suppressWarnings)
              log("この枠にはスキルがセットされていません", "warning");
            return { canUse: false, reason: "unset" };
          }
          if (skill.level <= 0) {
            if (!suppressWarnings)
              log("スキルを習得してから使用してください", "warning");
            return { canUse: false, reason: "unlearned" };
          }
          if (slot.cooldownRemaining > 0) {
            if (!suppressWarnings)
              log(
                `${skill.name}はクールタイム中 (${slot.cooldownRemaining}T)`,
                "warning",
              );
            return { canUse: false, reason: "cooldown" };
          }

          const target = chooseTargetForPlayer();
          if (!target) return { canUse: false, reason: "no-target" };

          const mpCost = skill.activation?.mpCost ?? 0;
          if (player.mp < mpCost) {
            if (!suppressWarnings)
              log(`MPが足りない！ (必要MP: ${mpCost})`, "warning");
            return { canUse: false, reason: "mp" };
          }

          return { canUse: true, slot, skill, target, mpCost };
        }

        function performActiveSkill(
          slotIndex,
          { suppressWarnings = false, endTurnOnSuccess = false, saveReason = "" } = {},
        ) {
          const availability = canUseActiveSkill(slotIndex, { suppressWarnings });
          if (!availability.canUse) return false;
          const { slot, skill, target, mpCost } = availability;
          consumeMp(mpCost);
          showSkillPopup(getPlayerHpBarContainer(), skill.name, "player");

          const hit = attemptHit(player, target);
          const effectLabel = skill.activation?.effect
            ? `: ${skill.activation.effect}`
            : "";
          if (!hit) {
            log(`🌀 ${skill.name}${effectLabel} は外れた…`, "warning");
            slot.cooldownRemaining = getEffectiveSkillCooldown(skill);
            renderActiveSkillLoadout();
            updateUI();
            if (endTurnOnSuccess) {
              if (saveReason) maybeAutoSave(saveReason);
              endPlayerTurn();
            }
            return true;
          }

          const baseDamage = calcDamage(player, target);
          const multiplier = 1.1 + skill.level * 0.02;
          const dmg = Math.round(baseDamage * multiplier);
          const dealt = applyDamage(target, dmg, {
            source: skill.name,
            attacker: player,
          });
          applyLegendaryHitEffects(target, { isSkill: true, isCritical: false });
          log(
            `🌀 ${skill.name}${effectLabel}！ ${target.name} に ${dealt} ダメージ`,
            "player",
          );

          if (target.hp <= 0) {
            log(`${target.name} を倒した！`, "good");
            onEnemyDefeated(target, { cause: skill.name });
            checkVictory();
          }

          slot.cooldownRemaining = getEffectiveSkillCooldown(skill);
          renderActiveSkillLoadout();
          updateUI();
          if (endTurnOnSuccess) {
            if (saveReason) maybeAutoSave(saveReason);
            endPlayerTurn();
          }
          return true;
        }

        function useActiveSkill(slotIndex) {
          performActiveSkill(slotIndex);
        }

        function powerStrike() {
          if (!game.awaitingInput) return;
          if (hasStatus(player, "silence")) {
            log("沈黙中でスキルが使えない！", "warning");
            return;
          }
          if (player.mp < 5) {
            log("MPが足りない！", "warning");
            return;
          }
          consumeMp(5);
          const target = chooseTargetForPlayer();
          if (!target) return;
          showSkillPopup(getPlayerHpBarContainer(), "パワーストライク", "player");
          const hit = attemptHit(player, target);
          if (!hit) {
            log("🌌 パワーストライクは空振り！", "warning");
            updateUI();
            endPlayerTurn();
            return;
          }
          const dmg = Math.round(
            calcDamage(player, target) * 1.6 + (player.buffs.focus ? 6 : 0),
          );
          const dealt = applyDamage(target, dmg, {
            source: "player",
            attacker: player,
          });
          applyLegendaryHitEffects(target, { isSkill: true, isCritical: false });
          log(
            `🌌 パワーストライク！ ${target.name} に ${dealt} ダメージ`,
            "player",
          );
          if (target.hp <= 0) {
            log(`${target.name} を粉砕！`, "good");
            onEnemyDefeated(target, { cause: "撃破" });
            checkVictory();
          } else {
            const knocked = applyStatus(target, "knockdown", {
              duration: 1,
              chance: 70,
            });
            if (knocked) log(`${target.name} を転倒させた！`, "good");
          }
          updateUI();
          endPlayerTurn();
        }

        function heal() {
          if (!game.awaitingInput) return;
          if (hasStatus(player, "silence")) {
            log("沈黙中でスキルが使えない！", "warning");
            return;
          }
          if (player.mp < 4) {
            log("MPが足りない！", "warning");
            return;
          }
          consumeMp(4);
          showSkillPopup(getPlayerHpBarContainer(), "ヒール", "player");
          const healAmount = Math.max(
            6,
            Math.round(player.maxHp * 0.12 + (player.buffs.focus ? 5 : 0)),
          );
          const healed = applyHealing(player, healAmount);
          log(`✨ ヒール！ HPが ${healed} 回復`, "good");
          updateUI();
          endPlayerTurn();
        }

        function guard() {
          if (!game.awaitingInput) return;
          if (hasStatus(player, "silence")) {
            log("沈黙中でスキルが使えない！", "warning");
            return;
          }
          if (player.mp < 2) {
            log("MPが足りない！", "warning");
            return;
          }
          consumeMp(2);
          showSkillPopup(getPlayerHpBarContainer(), "ガード", "player");
          player.buffs.guard = 2;
          log("🛡️ 守りを固めた！ 次の2ターン被ダメ軽減", "good");
          updateUI();
          endPlayerTurn();
        }

        function boost() {
          if (!game.awaitingInput) return;
          if (hasStatus(player, "silence")) {
            log("沈黙中でスキルが使えない！", "warning");
            return;
          }
          if (player.mp < 2) {
            log("MPが足りない！", "warning");
            return;
          }
          consumeMp(2);
          showSkillPopup(getPlayerHpBarContainer(), "ブースト", "player");
          player.buffs.haste = 2;
          log("💨 ブースト！ 次の2ターン行動速度アップ", "good");
          updateUI();
          endPlayerTurn();
        }

        function focus() {
          if (!game.awaitingInput) return;
          if (hasStatus(player, "silence")) {
            log("沈黙中でスキルが使えない！", "warning");
            return;
          }
          if (player.mp < 3) {
            log("MPが足りない！", "warning");
            return;
          }
          consumeMp(3);
          showSkillPopup(getPlayerHpBarContainer(), "フォーカス", "player");
          player.buffs.focus = 2;
          log("🎯 フォーカス！ クリティカル率アップ", "good");
          updateUI();
          endPlayerTurn();
        }

        function resetPlayerAfterPenalty({ restoreHp = true } = {}) {
          player.statuses = [];
          player.buffs = { guard: 0, haste: 0, focus: 0 };
          recalcDerivedStats();
          player.hp = restoreHp
            ? player.maxHp
            : Math.min(player.hp, player.maxHp);
          player.mp = player.maxMp;
          player.barrierRemaining = Math.max(
            0,
            Math.max(player.barrierRemaining ?? 0, player.barrierMax),
          );
          player.attacksRemaining = player.attackCount;
          player.activeSkillSlots.forEach((slot) => {
            slot.cooldownRemaining = 0;
          });
          game.enemies = [];
          clearTurnOrderPreview();
          game.turnQueue = [];
          game.awaitingInput = false;
        }

        function retreatLowerFloors(
          drop,
          { reason = "撤退", tone = "warning", restoreHp = true } = {},
        ) {
          const previousFloor = game.floor;
          game.floor = Math.max(1, game.floor - drop);
          const moved = previousFloor - game.floor;
          const movementText =
            moved > 0 ? `${moved}階さがる` : "これ以上下がれない";
          log(
            `↘️ ${reason}で${movementText} (${previousFloor}F → ${game.floor}F)`,
            tone,
          );
          resetPlayerAfterPenalty({ restoreHp });
          spawnEnemies();
          updateUI();
          maybeAutoSave(`戦闘終了: ${reason}`);
        }

        function resolvePlayerDefeatSequence() {
          if (!game.playerDefeatInProgress) return;
          clearTimeout(playerDefeatResolveTimer);
          playerDefeatResolveTimer = null;
          try {
            retreatLowerFloors(20, { reason: "戦闘不能", tone: "danger" });
          } finally {
            hidePlayerDownOverlay();
            game.playerDefeatInProgress = false;
          }
        }

        function handlePlayerDefeat() {
          if (game.playerDefeatInProgress) return;
          game.playerDefeatInProgress = true;

          game.awaitingInput = false;
          updateUI();
          showPlayerDownOverlay();

          clearTimeout(playerDefeatResolveTimer);
          playerDefeatResolveTimer = window.setTimeout(
            resolvePlayerDefeatSequence,
            1100,
          );
        }

        function attemptEscape() {
          if (!game.awaitingInput) return;
          const enemiesAlive = game.enemies.some((e) => e.hp > 0);
          if (!enemiesAlive) {
            log("逃げる相手がいない", "info");
            return;
          }
          retreatLowerFloors(5, {
            reason: "にげだした",
            tone: "warning",
            restoreHp: false,
          });
        }

        function enemyAction(enemy) {
          if (enemy.hp <= 0) return false;
          if (enemy.isBoss) {
            if (enemy.bossSkillCooldown > 0) {
              enemy.bossSkillCooldown = Math.max(
                0,
                enemy.bossSkillCooldown - 1,
              );
            }
            tryBossSkill(enemy);
          }
          const attacks = Math.max(
            0,
            Math.floor(enemy.attacksRemaining ?? enemy.attackCount ?? 0),
          );
          if (attacks <= 0) return false;
          enemy.attacksRemaining = attacks;
          for (let i = 0; i < attacks; i += 1) {
            const target = chooseTargetForEnemy(enemy);
            if (!target) return false;
            const hit = attemptHit(enemy, target);
            const targetLabel = target === player ? "あなた" : target.name;
              if (!hit) {
                log(
                  `☠️ ${enemy.name} の攻撃${attacks > 1 ? `(${i + 1}/${attacks})` : ""}は ${targetLabel} に当たらなかった`,
                  "info",
                );
              if (target === player) {
                handleLegendaryEvadeTrigger();
              }
                continue;
              }
            const dmg = calcDamage(enemy, target);
            const { isCritical, multiplier } = rollCritical(enemy);
            const finalDmg = Math.round(dmg * multiplier);
            const dealt = applyDamage(target, finalDmg, {
              source: enemy.name,
              attacker: enemy,
              isCritical,
            });
            const critText = isCritical ? "💥 クリティカル！ " : "";
            log(
              `${critText}☠️ ${enemy.name} の攻撃${attacks > 1 ? `(${i + 1}/${attacks})` : ""}！ ${targetLabel}に ${dealt} ダメージ`,
              "enemy",
            );
            if (target.hp > 0) {
              tryApplyArchetypeStatusOnHit(enemy, target);
            }
            if (target !== player && target.hp <= 0) {
              log(`${target.name} は倒れた`, "good");
              onEnemyDefeated(target, { cause: "混乱" });
              checkVictory();
              if (!game.enemies.some((e) => e.hp > 0)) return false;
            }
            if (player.hp <= 0) {
              handlePlayerDefeat();
              return true;
            }
            enemy.attacksRemaining = Math.max(0, attacks - i - 1);
          }
          return false;
        }

        function nextTurn() {
          if (player.hp <= 0) {
            handlePlayerDefeat();
            return;
          }
          if (game.turnQueue.length === 0) {
            buildTurnQueue();
          }
          const actor = game.turnQueue.shift();
          if (!actor) {
            setCurrentActorEntry(null);
            renderTurnOrder();
            return;
          }
          activeTurnActor = actor;
          setCurrentActorEntry(actor);
          renderTurnOrder();
          const entity =
            actor.type === "player"
              ? player
              : game.enemies.find((e) => e.id === actor.id);
          if (!entity) {
            advanceTurnOrderPreview(actor);
            nextTurn();
            return;
          }

          const turnState = processTurnStart(entity);
          updateUI();

          if (entity.hp <= 0) {
            if (actor.type === "enemy") {
              onEnemyDefeated(entity, { cause: "撃破" });
              log(`${entity.name} は倒れた`, "good");
              checkVictory();
            } else {
              handlePlayerDefeat();
              return;
            }
            advanceTurnOrderPreview(actor);
            setTimeout(() => nextTurn(), 380);
            return;
          }

          if (turnState.skipTurn) {
            finalizeTurn(entity);
            advanceTurnOrderPreview(actor);
            setTimeout(() => nextTurn(), 380);
            return;
          }

          if (actor.type === "player") {
            promptPlayerTurn();
            return;
          }
          const playerFell = enemyAction(entity);
          if (playerFell) {
            activeTurnActor = null;
            setCurrentActorEntry(null);
            renderTurnOrder();
            return;
          }
          finalizeTurn(entity);
          updateUI();
          if (player.hp <= 0) {
            handlePlayerDefeat();
            return;
          }
          advanceTurnOrderPreview(actor);
          setTimeout(() => nextTurn(), 380);
        }

        function checkVictory() {
          if (game.enemies.some((e) => e.hp > 0)) return;
          const mpGain = 3 + skills.arcaneFlow.level * 2;
          player.mp = Math.min(player.maxMp, player.mp + mpGain);
          log(`✨ 戦闘に勝利し、MPを ${mpGain} 回復した`, "good");
          game.awaitingInput = false;
          clearTurnOrderPreview();
          game.turnQueue = [];
          updateUI();
          maybeAutoSave("ステージクリア");
        }

        function levelUp() {
          const previousLevel = player.level;
          player.level += 1;
          player.expToLevel = Math.round(player.expToLevel * 1.25);
          recalcDerivedStats();
          player.hp = player.maxHp;
          player.mp = player.maxMp;
          player.statPoints += 5;
          player.skillPoints += 1;
          player.passivePoints += 1;
          log(
            `⬆️ レベルアップ！ Lv${player.level} 能力P+5 / スキルP+1 / パッシブP+1`,
            "good",
          );
          triggerLevelUpEffect(player.level);
          if (previousLevel === 1 && player.level === 2) {
            showLevelUpGuidance();
          }
          maybeAutoSave("レベルアップ");
        }

        function resetAllocations() {
          const spent = pendingResetSpent;
          Object.entries(player.allocations).forEach(([key, amount]) => {
            if (amount > 0) {
              player.primary[key].base -= amount;
              player.allocations[key] = 0;
            }
          });
          player.statPoints += spent;
          recalcDerivedStats();
          updateUI();
          log("ステータスをリセットしました", "info");
          pendingResetSpent = 0;
          maybeAutoSave("ステータス振り直し");
        }

        function retryBossFloor() {
          if (game.enemies.some((e) => e.hp > 0) && player.hp > 0) {
            log("敵が残っている！", "warning");
            return;
          }
          if (!isBossFloor(game.floor)) {
            nextFloor();
            return;
          }
          player.buffs.guard = 0;
          clearTurnOrderPreview();
          game.turnQueue = [];
          spawnEnemies();
          updateUI();
          log("🔁 ボス階を再挑戦", "info");
          maybeAutoSave("ボス再挑戦");
        }

        function nextFloor() {
          if (game.enemies.some((e) => e.hp > 0) && player.hp > 0) {
            log("敵が残っている！", "warning");
            return;
          }
          game.floor += 1;
          player.buffs.guard = 0;
          clearTurnOrderPreview();
          game.turnQueue = [];
          spawnEnemies();
          updateUI();
          maybeAutoSave("次の階へ進行");
        }

        playerDownOverlay?.addEventListener("click", () => {
          if (!playerDownOverlay.classList.contains("interactive")) return;
          resolvePlayerDefeatSequence();
        });

        document
          .getElementById("btn-skill-tree")
          .addEventListener("click", openPassiveTreeModal);
        document
          .getElementById("btn-player-modal")
          .addEventListener("click", openPlayerModal);
        playerModalStatusButton?.addEventListener("click", () =>
          setPlayerModalPage("status"),
        );
        playerModalEquipmentButton?.addEventListener("click", () =>
          setPlayerModalPage("equipment"),
        );
        inventoryOpenButton?.addEventListener("click", openInventoryModal);
        codexOpenButton?.addEventListener("click", openCodexModal);
        warpOpenButton?.addEventListener("click", openWarpModal);
        warpCloseButton?.addEventListener("click", closeWarpModal);
        warpModal?.addEventListener("click", (e) => {
          if (e.target === warpModal) closeWarpModal();
        });
        debugOpenButton?.addEventListener("click", openDebugModal);
        debugCloseButton?.addEventListener("click", closeDebugModal);
        archetypeCloseButton?.addEventListener("click", closeArchetypeModal);
        closeModalButton.addEventListener("click", closeEnemyModal);
        potionModalCloseButton.addEventListener("click", closePotionModal);
        skillInfoCloseButton?.addEventListener("click", closeSkillInfoModal);
        playerModalCloseButton.addEventListener("click", closePlayerModal);
        skillsModalCloseButton.addEventListener("click", closeSkillsModal);
        passiveTreeCloseButton?.addEventListener("click", closePassiveTreeModal);
        passiveTreeModal?.addEventListener("click", (e) => {
          if (e.target === passiveTreeModal) closePassiveTreeModal();
        });
        passiveTreeOpenSkillsButton?.addEventListener("click", () => {
          closePassiveTreeModal();
          openSkillsModal();
        });
        passiveTreeResetButton?.addEventListener("click", () => {
          const reset = resetPassiveTree(activePassiveTreeCategory);
          if (reset) {
            log(
              `🔁 ${activePassiveTreeCategory}のパッシブツリーをリセット`,
              "info",
            );
            renderPassiveTree();
          } else {
            log("リセットするノードがありません", "info");
          }
        });
        weaponEnhanceCloseButton?.addEventListener(
          "click",
          closeWeaponEnhanceModal,
        );
        bulkSellModalCloseButton?.addEventListener("click", closeBulkSellModal);
        bulkSellExecuteButton?.addEventListener("click", executeBulkSell);
        inventoryModalCloseButton?.addEventListener(
          "click",
          closeInventoryModal,
        );
        inventoryItemCloseButton?.addEventListener(
          "click",
          closeInventoryItemModal,
        );
        debugTargetSelect?.addEventListener("change", updateDebugTargetState);
        debugClearButton?.addEventListener("click", () => {
          const target = getDebugTarget();
          if (!target) {
            log("対象が存在しません", "warning");
            return;
          }
          target.statuses = [];
          log(`🐞 デバッグ: ${target.name} の状態異常を全解除`, "info");
          updateUI();
        });
        debugTabButtons.forEach((btn) => {
          btn.addEventListener("click", () => switchDebugTab(btn.dataset.tab));
        });

        debugApplyLevelButton?.addEventListener("click", applyDebugLevelChange);
        debugApplyHpButton?.addEventListener("click", applyDebugHpChange);
        debugApplyGoldButton?.addEventListener("click", applyDebugGoldChange);
        debugApplyFloorButton?.addEventListener("click", () =>
          applyDebugFloorChange(),
        );
        debugBossFloorButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const floor = Number(btn.dataset.debugBossFloor);
            if (Number.isNaN(floor)) return;
            applyDebugFloorChange(floor);
          });
        });
        debugForceLegendaryCheckbox?.addEventListener("change", () => {
          debugForceBossLegendaryDrop = !!debugForceLegendaryCheckbox.checked;
        });
        debugAutoAttackCheckbox?.addEventListener("change", () => {
          setDebugAutoAttackEnabled(!!debugAutoAttackCheckbox.checked);
        });
        debugCodexUnlockCheckbox?.addEventListener("change", () => {
          applyDebugCodexUnlock(!!debugCodexUnlockCheckbox.checked);
        });
        debugNewRunButton?.addEventListener("click", () =>
          startNewRun(activeSaveSlotId),
        );
        saveSlotList?.addEventListener("click", handleSaveAction);
        debugGearSlotSelect?.addEventListener(
          "change",
          populateLegendaryTemplateSelect,
        );
        debugGearRaritySelect?.addEventListener(
          "change",
          populateLegendaryTemplateSelect,
        );
        if (debugGearEnhanceInput) {
          debugGearEnhanceInput.max = MAX_ENHANCE_LEVEL;
          if (!debugGearEnhanceInput.value) debugGearEnhanceInput.value = 0;
        }
        debugGenerateGearButton?.addEventListener("click", () => {
          generateDebugGear();
        });
        debugGenerateGearRandomButton?.addEventListener("click", () => {
          const keys = Object.keys(EQUIPMENT_RARITIES);
          const randomKey = keys[randomInt(0, keys.length - 1)];
          debugGearRaritySelect.value = randomKey;
          populateLegendaryTemplateSelect();
          generateDebugGear({ randomRarity: true });
        });

        const refreshDebugPotionPreview = () =>
          renderDebugPotionPreview(buildDebugPotionPreview());
        debugPotionTemplateSelect?.addEventListener("change", () => {
          populateDebugPotionVariantSelect();
          refreshDebugPotionPreview();
        });
        debugPotionVariantSelect?.addEventListener(
          "change",
          refreshDebugPotionPreview,
        );
        debugPotionRaritySelect?.addEventListener("change", () => {
          updateDebugPotionControlState();
          refreshDebugPotionPreview();
        });
        debugPotionLegendarySelect?.addEventListener(
          "change",
          refreshDebugPotionPreview,
        );
        debugGeneratePotionButton?.addEventListener("click", () => {
          generateDebugPotion();
        });
        debugGeneratePotionRandomButton?.addEventListener("click", () => {
          const templateKeys = Object.keys(POTION_BASE_TEMPLATES);
          if (templateKeys.length) {
            const randomTemplate =
              templateKeys[randomInt(0, templateKeys.length - 1)];
            debugPotionTemplateSelect.value = randomTemplate;
            populateDebugPotionVariantSelect(randomTemplate);
            const variants =
              POTION_BASE_TEMPLATES[randomTemplate]?.variants || [];
            if (variants.length) {
              const randomVariant = variants[randomInt(0, variants.length - 1)];
              debugPotionVariantSelect.value = randomVariant.key;
            }
          }
          const rarityKeys = DEBUG_POTION_RARITY_OPTIONS.map((opt) => opt.key);
          if (rarityKeys.length) {
            debugPotionRaritySelect.value =
              rarityKeys[randomInt(0, rarityKeys.length - 1)];
          }
          updateDebugPotionControlState();
          if (
            debugPotionRaritySelect.value === "legendary" &&
            LEGENDARY_POTIONS.length
          ) {
            const randomLegendary =
              LEGENDARY_POTIONS[randomInt(0, LEGENDARY_POTIONS.length - 1)];
            debugPotionLegendarySelect.value = randomLegendary?.key || "";
          }
          refreshDebugPotionPreview();
          generateDebugPotion({
            randomRarity: debugPotionRaritySelect?.value === "random",
          });
        });
        debugRerollPotionButton?.addEventListener(
          "click",
          rerollDebugPotionPreview,
        );
        statHelpButton.addEventListener("click", () => {
          memoModal.classList.remove("hidden");
        });
        memoCloseButton.addEventListener("click", () =>
          memoModal.classList.add("hidden"),
        );
        memoModal.addEventListener("click", (e) => {
          if (e.target === memoModal) memoModal.classList.add("hidden");
        });

        codexCloseButton?.addEventListener("click", closeCodexModal);
        codexDetailCloseButton?.addEventListener("click", closeCodexDetail);

        statStepButton.addEventListener("click", () => {
          currentStepIndex = (currentStepIndex + 1) % stepOptions.length;
          updateStepButton();
          renderPrimaryStats();
        });

        skillStepButton?.addEventListener("click", () => {
          currentSkillStepIndex =
            (currentSkillStepIndex + 1) % skillStepOptions.length;
          updateSkillStepButton();
          renderSkills();
        });

        skillSummaryToggleButton?.addEventListener("click", () => {
          renderSkillSummary();
          skillSummaryVisible = !skillSummaryVisible;
          updateSkillSummaryVisibility();
        });
        skillSummaryCloseButton?.addEventListener("click", () => {
          skillSummaryVisible = false;
          updateSkillSummaryVisibility();
        });
        skillSummaryModal?.addEventListener("click", (e) => {
          if (e.target === skillSummaryModal) {
            skillSummaryVisible = false;
            updateSkillSummaryVisibility();
          }
        });

        resetButton.addEventListener("click", () => {
          pendingResetSpent = Object.values(player.allocations).reduce(
            (a, b) => a + b,
            0,
          );
          if (pendingResetSpent === 0) {
            log("リセットするポイントがありません", "info");
            return;
          }
          resetSpentLabel.textContent = pendingResetSpent;
          resetModal.classList.remove("hidden");
        });
        resetCloseButton.addEventListener("click", () =>
          resetModal.classList.add("hidden"),
        );
        resetCancelButton.addEventListener("click", () =>
          resetModal.classList.add("hidden"),
        );
        resetConfirmButton.addEventListener("click", () => {
          resetModal.classList.add("hidden");
          resetAllocations();
        });
        resetModal.addEventListener("click", (e) => {
          if (e.target === resetModal) resetModal.classList.add("hidden");
        });
        potionModal.addEventListener("click", (e) => {
          if (e.target === potionModal) closePotionModal();
        });
        skillInfoModal?.addEventListener("click", (e) => {
          if (e.target === skillInfoModal) closeSkillInfoModal();
        });
        resetSkillsButton.addEventListener("click", () => {
          const spent = Object.values(skills).reduce(
            (sum, skill) => sum + skill.level,
            0,
          );
          if (spent === 0) {
            log("リセットするスキルがありません", "info");
            return;
          }
          skillResetSpentLabel.textContent = spent;
          skillResetModal.classList.remove("hidden");
        });
        skillResetCloseButton.addEventListener("click", () =>
          skillResetModal.classList.add("hidden"),
        );
        skillResetCancelButton.addEventListener("click", () =>
          skillResetModal.classList.add("hidden"),
        );
        skillResetConfirmButton.addEventListener("click", () => {
          skillResetModal.classList.add("hidden");
          resetSkills();
        });
        skillResetModal.addEventListener("click", (e) => {
          if (e.target === skillResetModal)
            skillResetModal.classList.add("hidden");
        });
        enemyModal.addEventListener("click", (e) => {
          if (e.target === enemyModal) closeEnemyModal();
        });
        playerModal.addEventListener("click", (e) => {
          if (e.target === playerModal) closePlayerModal();
        });
        skillsModal.addEventListener("click", (e) => {
          if (e.target === skillsModal) closeSkillsModal();
        });
        inventoryModal?.addEventListener("click", (e) => {
          if (e.target === inventoryModal) closeInventoryModal();
        });
        bulkSellModal?.addEventListener("click", (e) => {
          if (e.target === bulkSellModal) closeBulkSellModal();
        });
        inventoryItemModal?.addEventListener("click", (e) => {
          if (e.target === inventoryItemModal) closeInventoryItemModal();
        });
        codexModal?.addEventListener("click", (e) => {
          if (e.target === codexModal) closeCodexModal();
        });
        codexDetailModal?.addEventListener("click", (e) => {
          if (e.target === codexDetailModal) closeCodexDetail();
        });
        debugModal?.addEventListener("click", (e) => {
          if (e.target === debugModal) closeDebugModal();
        });
        archetypeModal?.addEventListener("click", (e) => {
          if (e.target === archetypeModal) closeArchetypeModal();
        });

        loadActiveSlotPreference();
        renderSaveSlots();

        const loadedFromSave = autoLoadLastActiveSlot();

        if (!loadedFromSave) {
          const initialDerived = recalcDerivedStats();
          renderSecondaryStats(initialDerived);
          log("=== 挑戦開始 ===", "info");
          spawnEnemies();
          updateUI(initialDerived);
        } else {
          renderSaveSlots();
        }
      })();
    </script>
  </body>
</html>
