<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lane Battle 3x3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anta&family=Noto+Sans+JP:wght@400;700;900&display=swap');

        body {
            background-color: #020617;
            color: #f1f5f9;
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        body.h-screen {
            height: 100svh;
            min-height: 100svh;
        }

        body.p-4 {
            padding: clamp(8px, 2vw, 16px);
        }

        .anta { font-family: 'Anta', sans-serif; }

        .enemy-grid-shell {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .enemy-row-labels {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            font-size: 10px;
            color: #94a3b8;
            font-weight: 700;
            letter-spacing: 0.08em;
        }

        .enemy-row-labels span {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px;
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid #1f2937;
        }

        .enemy-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.85);
            border: 2px solid #1e293b;
        }

        .enemy-cell {
            position: relative;
            min-height: clamp(62px, 12vh, 86px);
            border-radius: 10px;
            border: 1px solid #1f2937;
            background: rgba(15, 23, 42, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .enemy-cell.is-empty {
            border-style: dashed;
            color: #475569;
            font-size: 10px;
        }

        .enemy-card {
            width: 100%;
            height: 100%;
            padding: 6px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(127, 29, 29, 0.6));
            border-radius: 8px;
            border: 1px solid rgba(248, 113, 113, 0.6);
            gap: 4px;
        }

        .enemy-card.is-front {
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.4) inset;
        }

        .enemy-name {
            font-size: 10px;
            font-weight: 700;
            color: #fecaca;
        }

        .enemy-hp-bar {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(30, 41, 59, 0.8);
            overflow: hidden;
            position: relative;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f87171, #dc2626);
            transition: width 0.2s ease;
        }

        .hp-bar-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 900;
            color: #f8fafc;
            text-shadow: 0 0 4px rgba(15, 23, 42, 0.9);
            letter-spacing: 0.04em;
            pointer-events: none;
        }

        .enemy-action {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #bae6fd;
            font-weight: 700;
        }

        .enemy-action-bar {
            flex: 1;
            height: 4px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            overflow: hidden;
        }

        .enemy-action-fill {
            height: 100%;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            transition: width 0.2s ease;
        }

        .enemy-action.is-idle {
            opacity: 0.35;
        }

        .lane-container {
            display: flex;
            gap: 8px;
            padding: clamp(6px, 1.8vw, 12px);
            height: clamp(70px, 14vh, 110px);
            background: rgba(15, 23, 42, 0.8);
            border-top: 2px solid #1e293b;
            border-bottom: 2px solid #1e293b;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .lane-container::-webkit-scrollbar { display: none; }

        .skill-block {
            min-width: clamp(48px, 12vw, 60px);
            height: clamp(60px, 12vh, 75px);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            font-size: clamp(12px, 3vw, 14px);
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            color: #e0f2fe;
            box-shadow: 0 4px 0 rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .attack-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .lane-hint {
            font-size: 10px;
            color: #94a3b8;
            text-align: center;
        }

        #logs {
            max-height: 24vh;
            overflow: hidden;
            font-size: clamp(8px, 1.6vw, 11px);
        }

        .attack-btn {
            min-width: clamp(72px, 20vw, 96px);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 900;
            font-size: clamp(12px, 3vw, 14px);
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            color: #e0f2fe;
            box-shadow: 0 4px 0 rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.2s ease;
        }

        .attack-btn.is-active {
            filter: brightness(1.2);
            box-shadow: 0 0 12px rgba(56, 189, 248, 0.7);
        }

        .attack-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .lane-hint {
            font-size: 10px;
            color: #94a3b8;
            text-align: center;
        }

        #logs {
            max-height: 24vh;
            overflow: hidden;
            font-size: clamp(8px, 1.6vw, 11px);
        }

        .pop-up {
            position: absolute;
            animation: popUp 0.8s ease-out forwards;
            pointer-events: none;
            font-weight: 900;
            z-index: 50;
        }

        @keyframes popUp {
            0% { transform: translateY(0); opacity: 0; }
            20% { opacity: 1; transform: translateY(-16px); }
            100% { transform: translateY(-60px); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col h-screen p-4">
    <div class="mb-4">
        <div class="flex justify-between items-end mb-2 px-1">
            <span class="text-xs text-red-400 font-bold anta">ENEMY LANE 3x3</span>
            <span id="enemy-count" class="text-sm font-bold anta">9 / 9</span>
        </div>
        <div class="enemy-grid-shell">
            <div class="enemy-row-labels">
                <span>後列</span>
                <span>中列</span>
                <span class="text-cyan-300">前列</span>
            </div>
            <div id="enemy-grid" class="enemy-grid"></div>
        </div>
    </div>

    <div class="mb-4">
        <div class="text-[10px] text-slate-500 mb-1 text-center font-bold">ATTACK LANE (タップで発動)</div>
        <div id="skill-lane" class="lane-container"></div>
    </div>

    <div class="mb-4">
        <div class="text-[10px] text-slate-500 mb-2 text-center font-bold">攻撃対象の列を選択</div>
        <div class="flex items-center justify-center gap-3">
            <button class="attack-btn" data-col="0" type="button">左列</button>
            <button class="attack-btn" data-col="1" type="button">中央</button>
            <button class="attack-btn" data-col="2" type="button">右列</button>
        </div>
    </div>

    <div class="mb-4">
        <div class="flex justify-between items-end mb-1 px-2">
            <div class="flex flex-col">
                <span class="text-[10px] text-green-400 font-bold">PLAYER HP</span>
            </div>
        </div>
        <div class="w-full bg-slate-800 h-3 rounded-full overflow-hidden relative">
            <div id="player-hp-bar" class="bg-green-500 h-full w-full transition-all"></div>
            <div id="player-hp-txt" class="hp-bar-text">100 / 100</div>
        </div>
    </div>

    <div id="logs" class="flex-grow flex flex-col justify-end text-[10px] gap-1 opacity-60 font-mono mb-2">
        <div>-- BATTLE START --</div>
    </div>

    <div class="lane-hint">下が最前列。前列が倒れると後ろが前にスライドします。</div>

    <script>
        const enemyRows = 3;
        const enemyCols = 3;

        const state = {
            player: { hp: 100, maxHp: 100, shield: 0 },
            columns: [],
            lane: [],
            isGameOver: false,
            lastFrameTime: 0,
            spawnInterval: 1800,
            lastSpawn: 0,
            selectedColumn: 1,
            types: [
                { name: '斬', type: 'red', val: 35, desc: 'ATTACK' },
                { name: '防', type: 'blue', val: 25, desc: 'SHIELD' },
                { name: '癒', type: 'green', val: 20, desc: 'HEAL' }
            ]
        };

        const enemyGrid = document.getElementById('enemy-grid');
        const enemyCountText = document.getElementById('enemy-count');
        const playerHpText = document.getElementById('player-hp-txt');
        const playerHpBar = document.getElementById('player-hp-bar');
        const skillLane = document.getElementById('skill-lane');
        const logs = document.getElementById('logs');

        function createEnemy(row, col) {
            const base = 80 + row * 30 + col * 10;
            return {
                id: `${row}-${col}-${Math.random()}`,
                name: `E${row + 1}-${col + 1}`,
                hp: base,
                maxHp: base,
                action: 0
            };
        }

        function initEnemies() {
            state.columns = Array.from({ length: enemyCols }, (_, col) => (
                Array.from({ length: enemyRows }, (_, row) => createEnemy(row, col))
            ));
            render();
        }

        function addLog(message) {
            const div = document.createElement('div');
            div.innerText = `> ${message}`;
            logs.appendChild(div);
            if (logs.childNodes.length > 6) {
                logs.removeChild(logs.firstChild);
            }
        }

        function popText(text, color, x, y) {
            const el = document.createElement('div');
            el.className = `pop-up ${color} text-xl`;
            el.innerText = text;
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function countEnemies() {
            return state.columns.reduce((sum, column) => (
                sum + column.filter(Boolean).length
            ), 0);
        }

        function renderEnemies() {
            enemyGrid.innerHTML = '';
            for (let row = 0; row < enemyRows; row++) {
                for (let col = 0; col < enemyCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'enemy-cell';
                    const enemy = state.columns[col][row];
                    if (!enemy) {
                        cell.classList.add('is-empty');
                        cell.innerHTML = '<span>--</span>';
                    } else {
                        const card = document.createElement('div');
                        const isFront = row === getFrontEnemyRow(state.columns[col]);
                        card.className = `enemy-card${isFront ? ' is-front' : ''}`;
                        card.innerHTML = `
                            <div>
                                <div class="enemy-name">${enemy.name}</div>
                            </div>
                            <div class="enemy-hp-bar">
                                <div class="enemy-hp-fill" style="width:${(enemy.hp / enemy.maxHp) * 100}%"></div>
                                <div class="hp-bar-text">${enemy.hp} / ${enemy.maxHp}</div>
                            </div>
                            <div class="enemy-action${isFront ? '' : ' is-idle'}">
                                <span>行動</span>
                                <div class="enemy-action-bar">
                                    <div class="enemy-action-fill" style="width:${Math.min(100, enemy.action * 100)}%"></div>
                                </div>
                            </div>
                        `;
                        cell.appendChild(card);
                    }
                    enemyGrid.appendChild(cell);
                }
            }
        }

        function renderLane() {
            skillLane.innerHTML = '';

            const withChain = state.lane.map((block, i) => {
                let count = 1;
                let l = i - 1;
                while (l >= 0 && state.lane[l].type === block.type) { count++; l--; }
                let r = i + 1;
                while (r < state.lane.length && state.lane[r].type === block.type) { count++; r++; }
                return { ...block, chain: count };
            });

            withChain.forEach((block, index) => {
                const div = document.createElement('div');
                div.className = `skill-block type-${block.type} flex-shrink-0`;
                div.innerHTML = `<span class="text-[8px] opacity-60">${block.desc}</span><span class="text-xl">${block.name}</span>`;

                if (block.chain > 1) {
                    const badge = document.createElement('div');
                    badge.className = 'chain-badge font-bold';
                    badge.innerText = block.chain;
                    div.appendChild(badge);
                }

                div.onclick = () => executeChain(index);
                skillLane.appendChild(div);
            });
        }

        function render() {
            renderEnemies();
            renderLane();
            updateUI();
        }

        function updateUI() {
            const remaining = countEnemies();
            enemyCountText.innerText = `${remaining} / ${enemyRows * enemyCols}`;
            playerHpText.innerText = `${state.player.hp} / ${state.player.maxHp}`;
            playerHpBar.style.width = `${(state.player.hp / state.player.maxHp) * 100}%`;
            document.querySelectorAll('.attack-btn').forEach((button) => {
                const col = Number(button.dataset.col);
                button.classList.toggle('is-active', col === state.selectedColumn);
            });
        }

        function shiftColumn(colIndex) {
            const column = state.columns[colIndex];
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) continue;
                let above = row - 1;
                while (above >= 0 && !column[above]) {
                    above -= 1;
                }
                if (above >= 0) {
                    column[row] = column[above];
                    column[above] = null;
                }
            }
        }

        function getFrontEnemyRow(column) {
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) return row;
            }
            return null;
        }

        function attackColumn(colIndex, damage) {
            if (state.isGameOver) return;
            const column = state.columns[colIndex];
            const targetRow = getFrontEnemyRow(column);
            if (targetRow === null) {
                addLog(`列${colIndex + 1}に敵がいません。`);
                return;
            }
            const enemy = column[targetRow];
            enemy.hp = Math.max(0, enemy.hp - damage);
            popText(`-${damage}`, 'text-red-400', 50, 30);
            addLog(`列${colIndex + 1}の前列に攻撃！ ${damage}ダメージ`);
            if (enemy.hp === 0) {
                addLog(`${enemy.name}を撃破！`);
                column[targetRow] = null;
                shiftColumn(colIndex);
            }
            if (countEnemies() === 0) {
                state.isGameOver = true;
                addLog('VICTORY!');
            }
            render();
        }

        function spawnBlock() {
            if (state.lane.length >= 10) return;
            const proto = state.types[Math.floor(Math.random() * state.types.length)];
            state.lane.push({ ...proto, id: Math.random() });
            render();
        }

        function executeChain(index) {
            const type = state.lane[index].type;
            let indices = [index];

            let l = index - 1;
            while (l >= 0 && state.lane[l].type === type) { indices.push(l); l--; }
            let r = index + 1;
            while (r < state.lane.length && state.lane[r].type === type) { indices.push(r); r++; }

            const chainSize = indices.length;
            const multiplier = [0, 1, 2.4, 5.5, 9.5, 14][Math.min(chainSize, 5)];
            const baseVal = state.lane[index].val;

            indices.sort((a, b) => b - a).forEach((i) => state.lane.splice(i, 1));

            if (type === 'red') {
                const damage = Math.floor(baseVal * multiplier);
                attackColumn(state.selectedColumn, damage);
            } else if (type === 'blue') {
                const shield = Math.floor(baseVal * multiplier);
                state.player.shield += shield;
                popText(`+${shield} SHIELD`, 'text-blue-300', 50, 30);
                addLog(`${chainSize}チェイン：防御(+${shield})`);
            } else if (type === 'green') {
                const heal = Math.floor(baseVal * multiplier);
                state.player.hp = Math.min(state.player.maxHp, state.player.hp + heal);
                popText(`+${heal} HEAL`, 'text-green-300', 50, 30);
                addLog(`${chainSize}チェイン：回復(+${heal})`);
            }

            render();
        }

        function enemyAction(enemy) {
            if (state.isGameOver) return;
            const damage = 7 + Math.floor(enemy.maxHp / 50);
            let remaining = damage;
            if (state.player.shield > 0) {
                const absorbed = Math.min(state.player.shield, remaining);
                state.player.shield -= absorbed;
                remaining -= absorbed;
            }
            if (remaining > 0) {
                state.player.hp = Math.max(0, state.player.hp - remaining);
            }
            addLog(`${enemy.name}の攻撃！ ${damage}ダメージ`);
            if (state.player.hp === 0) {
                state.isGameOver = true;
                addLog('DEFEAT...');
            }
            render();
        }

        function updateEnemyActions(delta) {
            const actionSpeed = 3200;
            state.columns.forEach((column) => {
                const frontRow = getFrontEnemyRow(column);
                column.forEach((enemy, row) => {
                    if (!enemy) return;
                    if (row !== frontRow) return;
                    enemy.action = Math.min(1, enemy.action + delta / actionSpeed);
                    if (enemy.action >= 1) {
                        enemy.action = 0;
                        enemyAction(enemy);
                    }
                });
            });
        }

        function gameLoop(time) {
            if (state.isGameOver) return;
            if (!state.lastFrameTime) state.lastFrameTime = time;
            const delta = time - state.lastFrameTime;
            state.lastFrameTime = time;

            if (time - state.lastSpawn > state.spawnInterval) {
                spawnBlock();
                state.lastSpawn = time;
            }

            updateEnemyActions(delta);
            requestAnimationFrame(gameLoop);
        }

        document.querySelectorAll('.attack-btn').forEach((button) => {
            button.addEventListener('click', () => {
                state.selectedColumn = Number(button.dataset.col);
                updateUI();
            });
        });

        initEnemies();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
