<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lane Battle 3x3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anta&family=Noto+Sans+JP:wght@400;700;900&display=swap');

        body {
            background-color: #020617;
            color: #f1f5f9;
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        body::before,
        body::after {
            content: "";
            position: fixed;
            inset: -20vh;
            z-index: -1;
            opacity: 0.6;
            pointer-events: none;
            background: radial-gradient(circle at top, rgba(14, 165, 233, 0.25), transparent 55%),
                radial-gradient(circle at 20% 70%, rgba(239, 68, 68, 0.2), transparent 60%),
                radial-gradient(circle at 80% 30%, rgba(16, 185, 129, 0.2), transparent 60%);
            animation: auroraShift 18s ease-in-out infinite;
        }

        body::after {
            opacity: 0.35;
            background: repeating-linear-gradient(120deg, rgba(148, 163, 184, 0.08) 0 2px, transparent 2px 12px);
            animation: scanLines 8s linear infinite;
        }

        body.is-paused * {
            animation-play-state: paused !important;
        }

        body.h-screen {
            height: 100svh;
            min-height: 100svh;
        }

        body.p-4 {
            padding: clamp(8px, 2vw, 16px);
        }

        .anta { font-family: 'Anta', sans-serif; }

        .enemy-grid-shell {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .enemy-row-labels {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            font-size: 10px;
            color: #94a3b8;
            font-weight: 700;
            letter-spacing: 0.08em;
        }

        .enemy-row-labels span {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px;
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid #1f2937;
        }

        .enemy-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.85);
            border: 2px solid #1e293b;
            box-shadow: 0 0 24px rgba(30, 64, 175, 0.25);
            animation: gridGlow 6s ease-in-out infinite;
        }

        .enemy-cell {
            position: relative;
            min-height: clamp(62px, 12vh, 86px);
            border-radius: 10px;
            border: 1px solid #1f2937;
            background: rgba(15, 23, 42, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .enemy-cell.is-empty {
            border-style: dashed;
            color: #475569;
            font-size: 10px;
        }

        .enemy-cell.is-hit {
            animation: hitShake 0.45s ease;
            box-shadow: 0 0 14px rgba(248, 113, 113, 0.6);
        }

        .enemy-card {
            width: 100%;
            height: 100%;
            padding: 6px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(127, 29, 29, 0.6));
            border-radius: 8px;
            border: 1px solid rgba(248, 113, 113, 0.6);
            gap: 4px;
            animation: cardFloat 5s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .enemy-card.is-front {
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.4) inset;
            animation: frontPulse 3s ease-in-out infinite;
        }

        .enemy-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 20%, rgba(248, 113, 113, 0.5), transparent 55%);
            opacity: 0.2;
            animation: emberDrift 6s ease-in-out infinite;
        }

        .enemy-name {
            font-size: 10px;
            font-weight: 700;
            color: #fecaca;
        }

        .enemy-hp-bar {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(30, 41, 59, 0.8);
            overflow: hidden;
            position: relative;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f87171, #dc2626);
            transition: width 0.2s ease;
        }

        .hp-bar-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 900;
            color: #f8fafc;
            text-shadow: 0 0 4px rgba(15, 23, 42, 0.9);
            letter-spacing: 0.04em;
            pointer-events: none;
        }

        .enemy-action {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #bae6fd;
            font-weight: 700;
        }

        .enemy-action-bar {
            flex: 1;
            height: 4px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            overflow: hidden;
        }

        .enemy-action-fill {
            height: 100%;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            transition: width 0.2s ease;
        }

        .enemy-action.is-idle {
            opacity: 0.35;
        }

        .lane-container {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .lane-container::-webkit-scrollbar { display: none; }

        .skill-block {
            min-width: clamp(48px, 12vw, 60px);
            height: clamp(60px, 12vh, 75px);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            cursor: pointer;
            position: relative;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            animation: laneFloat 6s ease-in-out infinite;
        }

        .skill-block:active { transform: scale(0.95) translateY(2px); box-shadow: none; }
        .skill-block:hover { transform: translateY(-4px) scale(1.03); }

        .skill-block.is-spawned {
            animation: spawnPop 0.6s ease;
        }

        .skill-block.is-chain {
            animation: chainSpark 0.8s ease;
            box-shadow: 0 0 14px rgba(253, 230, 138, 0.8);
        }

        .type-red { background: linear-gradient(135deg, #ef4444, #991b1b); border: 2px solid #f87171; }
        .type-blue { background: linear-gradient(135deg, #3b82f6, #1e3a8a); border: 2px solid #60a5fa; }
        .type-green { background: linear-gradient(135deg, #10b981, #064e3b); border: 2px solid #34d399; }

        .chain-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #fff;
            color: #000;
            font-size: 12px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            animation: badgeBounce 1.6s ease-in-out infinite;
        }

        .enemy-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.85);
            border: 2px solid #1e293b;
        }

        .enemy-cell {
            position: relative;
            min-height: clamp(62px, 12vh, 86px);
            border-radius: 10px;
            border: 1px solid #1f2937;
            background: rgba(15, 23, 42, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .enemy-cell.is-empty {
            border-style: dashed;
            color: #475569;
            font-size: 10px;
        }

        .enemy-card {
            width: 100%;
            height: 100%;
            padding: 6px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(127, 29, 29, 0.6));
            border-radius: 8px;
            border: 1px solid rgba(248, 113, 113, 0.6);
            gap: 4px;
        }

        .enemy-card.is-front {
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.4) inset;
        }

        .enemy-name {
            font-size: 10px;
            font-weight: 700;
            color: #fecaca;
        }

        .enemy-hp-bar {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(30, 41, 59, 0.8);
            overflow: hidden;
            position: relative;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f87171, #dc2626);
            transition: width 0.2s ease;
        }

        .hp-bar-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 900;
            color: #f8fafc;
            text-shadow: 0 0 4px rgba(15, 23, 42, 0.9);
            letter-spacing: 0.04em;
            pointer-events: none;
        }

        .enemy-action {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #bae6fd;
            font-weight: 700;
        }

        .enemy-action-bar {
            flex: 1;
            height: 4px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            overflow: hidden;
        }

        body.is-paused .pause-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        body.is-paused .enemy-grid,
        body.is-paused .lane-container,
        body.is-paused #logs {
            filter: grayscale(0.4) brightness(0.7);
        }

        .attack-btn {
            min-width: clamp(72px, 20vw, 96px);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 900;
            font-size: clamp(12px, 3vw, 14px);
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            color: #e0f2fe;
            box-shadow: 0 4px 0 rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .attack-btn.is-active {
            filter: brightness(1.2);
            box-shadow: 0 0 12px rgba(56, 189, 248, 0.7);
            animation: targetPulse 1.6s ease-in-out infinite;
        }

        .attack-btn::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: translateX(-120%);
            transition: transform 0.6s ease;
        }

        .attack-btn:hover::after {
            transform: translateX(120%);
        }

        .attack-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .lane-hint {
            font-size: 10px;
            color: #94a3b8;
            text-align: center;
        }

        #logs {
            max-height: 24vh;
            overflow: hidden;
            font-size: clamp(8px, 1.6vw, 11px);
        }

        .log-item {
            animation: logSlide 0.4s ease;
        }

        .lane-container.is-flash {
            animation: laneFlash 0.6s ease;
        }

        #player-hp-shell {
            box-shadow: 0 0 12px rgba(15, 23, 42, 0.7) inset;
            transition: box-shadow 0.3s ease;
        }

        #player-hp-bar {
            transition: width 0.4s ease;
        }

        #player-hp-bar.is-heal {
            animation: healPulse 0.6s ease;
            background: linear-gradient(90deg, #22c55e, #86efac);
        }

        #player-hp-bar.is-shield {
            animation: shieldPulse 0.6s ease;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
        }

        #player-hp-bar.is-damage {
            animation: damagePulse 0.6s ease;
            background: linear-gradient(90deg, #f87171, #ef4444);
        }

        .pause-button {
            width: 36px;
            height: 36px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid #334155;
            color: #e2e8f0;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .pause-button.is-paused {
            box-shadow: 0 0 12px rgba(148, 163, 184, 0.6);
            animation: pauseGlow 1.8s ease-in-out infinite;
        }

        .pause-overlay {
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 23, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 900;
            letter-spacing: 0.2em;
            color: #e2e8f0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .pop-up {
            position: absolute;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(15, 23, 42, 0.9);
            animation: popUp 0.8s ease forwards;
            pointer-events: none;
        }

        .attack-btn {
            min-width: clamp(72px, 20vw, 96px);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 900;
            font-size: clamp(12px, 3vw, 14px);
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            color: #e0f2fe;
            box-shadow: 0 4px 0 rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.2s ease;
        }

        @keyframes auroraShift {
            0%, 100% { transform: translate3d(0, 0, 0) scale(1); }
            50% { transform: translate3d(2%, -3%, 0) scale(1.05); }
        }

        @keyframes scanLines {
            0% { transform: translateX(0); }
            100% { transform: translateX(20%); }
        }

        @keyframes gridGlow {
            0%, 100% { box-shadow: 0 0 18px rgba(59, 130, 246, 0.25); }
            50% { box-shadow: 0 0 30px rgba(56, 189, 248, 0.45); }
        }

        @keyframes cardFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @keyframes frontPulse {
            0%, 100% { box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.4) inset; }
            50% { box-shadow: 0 0 14px rgba(56, 189, 248, 0.65); }
        }

        @keyframes emberDrift {
            0%, 100% { transform: translateY(0); opacity: 0.2; }
            50% { transform: translateY(-6px); opacity: 0.45; }
        }

        @keyframes hitShake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
            100% { transform: translateX(0); }
        }

        @keyframes laneFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        @keyframes spawnPop {
            0% { transform: scale(0.4); opacity: 0; }
            60% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes chainSpark {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); filter: brightness(1.3); }
            100% { transform: scale(1); }
        }

        @keyframes badgeBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-3px) scale(1.08); }
        }

        @keyframes targetPulse {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        @keyframes logSlide {
            0% { transform: translateY(6px); opacity: 0; }
            100% { transform: translateY(0); opacity: 0.8; }
        }

        @keyframes laneFlash {
            0% { filter: brightness(1); }
            30% { filter: brightness(1.4); }
            100% { filter: brightness(1); }
        }

        @keyframes healPulse {
            0% { box-shadow: 0 0 0 rgba(34, 197, 94, 0.6); }
            50% { box-shadow: 0 0 16px rgba(34, 197, 94, 0.8); }
            100% { box-shadow: 0 0 0 rgba(34, 197, 94, 0.6); }
        }

        @keyframes shieldPulse {
            0% { box-shadow: 0 0 0 rgba(56, 189, 248, 0.6); }
            50% { box-shadow: 0 0 16px rgba(56, 189, 248, 0.8); }
            100% { box-shadow: 0 0 0 rgba(56, 189, 248, 0.6); }
        }

        @keyframes damagePulse {
            0% { box-shadow: 0 0 0 rgba(248, 113, 113, 0.6); }
            50% { box-shadow: 0 0 16px rgba(248, 113, 113, 0.8); }
            100% { box-shadow: 0 0 0 rgba(248, 113, 113, 0.6); }
        }

        @keyframes pauseGlow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        @keyframes popUp {
            0% { transform: translateY(0); opacity: 0; }
            20% { opacity: 1; transform: translateY(-16px); }
            100% { transform: translateY(-60px); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col h-screen p-4">
    <div class="mb-4">
        <div class="flex justify-between items-end mb-2 px-1">
            <span class="text-xs text-red-400 font-bold anta">ENEMY LANE 3x3</span>
            <span id="enemy-count" class="text-sm font-bold anta">9 / 9</span>
        </div>
        <div class="enemy-grid-shell">
            <div class="enemy-row-labels">
                <span>後列</span>
                <span>中列</span>
                <span class="text-cyan-300">前列</span>
            </div>
            <div id="enemy-grid" class="enemy-grid"></div>
        </div>
    </div>

    <div class="mb-4">
        <div class="text-[10px] text-slate-500 mb-1 text-center font-bold">ATTACK LANE (タップで発動)</div>
        <div id="skill-lane" class="lane-container"></div>
    </div>

    <div class="mb-4">
        <div class="text-[10px] text-slate-500 mb-2 text-center font-bold">攻撃対象の列を選択</div>
        <div class="flex items-center justify-center gap-3">
            <button id="pause-btn" class="pause-button" type="button" aria-pressed="false" aria-label="一時停止">⏸</button>
            <button class="attack-btn" data-col="0" type="button">左列</button>
            <button class="attack-btn" data-col="1" type="button">中央</button>
            <button class="attack-btn" data-col="2" type="button">右列</button>
        </div>
    </div>

    <div class="mb-4">
        <div class="flex justify-between items-end mb-1 px-2">
            <div class="flex flex-col">
                <span class="text-[10px] text-green-400 font-bold">PLAYER HP</span>
            </div>
        </div>
        <div id="player-hp-shell" class="w-full bg-slate-800 h-3 rounded-full overflow-hidden relative">
            <div id="player-hp-bar" class="bg-green-500 h-full w-full transition-all"></div>
            <div id="player-hp-txt" class="hp-bar-text">100 / 100</div>
        </div>
    </div>

    <div id="logs" class="flex-grow flex flex-col justify-end text-[10px] gap-1 opacity-60 font-mono mb-2">
        <div>-- BATTLE START --</div>
    </div>

    <div class="lane-hint">下が最前列。前列が倒れると後ろが前にスライドします。</div>

    <div id="pause-overlay" class="pause-overlay" aria-hidden="true">
        <span>PAUSED</span>
    </div>

    <script>
        const enemyRows = 3;
        const enemyCols = 3;

        const state = {
            player: { hp: 100, maxHp: 100, shield: 0 },
            columns: [],
            lane: [],
            isGameOver: false,
            isPaused: false,
            lastFrameTime: 0,
            spawnInterval: 1800,
            lastSpawn: 0,
            selectedColumn: 1,
            lastHit: null,
            lastSpawnId: null,
            lastChainIds: [],
            lastAction: null,
            types: [
                { name: '斬', type: 'red', val: 35, desc: 'ATTACK' },
                { name: '防', type: 'blue', val: 25, desc: 'SHIELD' },
                { name: '癒', type: 'green', val: 20, desc: 'HEAL' }
            ]
        };

        const enemyGrid = document.getElementById('enemy-grid');
        const enemyCountText = document.getElementById('enemy-count');
        const playerHpText = document.getElementById('player-hp-txt');
        const playerHpBar = document.getElementById('player-hp-bar');
        const skillLane = document.getElementById('skill-lane');
        const pauseBtn = document.getElementById('pause-btn');
        const pauseOverlay = document.getElementById('pause-overlay');
        const logs = document.getElementById('logs');

        function createEnemy(row, col) {
            const base = 80 + row * 30 + col * 10;
            return {
                id: `${row}-${col}-${Math.random()}`,
                name: `E${row + 1}-${col + 1}`,
                hp: base,
                maxHp: base,
                action: 0
            };
        }

        function initEnemies() {
            state.columns = Array.from({ length: enemyCols }, (_, col) => (
                Array.from({ length: enemyRows }, (_, row) => createEnemy(row, col))
            ));
            render();
        }

        function addLog(message) {
            const div = document.createElement('div');
            div.className = 'log-item';
            div.innerText = `> ${message}`;
            logs.appendChild(div);
            if (logs.childNodes.length > 6) {
                logs.removeChild(logs.firstChild);
            }
        }

        function popText(text, color, x, y) {
            const el = document.createElement('div');
            el.className = `pop-up ${color} text-xl`;
            el.innerText = text;
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function countEnemies() {
            return state.columns.reduce((sum, column) => (
                sum + column.filter(Boolean).length
            ), 0);
        }

        function renderEnemies() {
            enemyGrid.innerHTML = '';
            const now = performance.now();
            for (let row = 0; row < enemyRows; row++) {
                for (let col = 0; col < enemyCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'enemy-cell';
                    const enemy = state.columns[col][row];
                    if (!enemy) {
                        cell.classList.add('is-empty');
                        cell.innerHTML = '<span>--</span>';
                    } else {
                        const card = document.createElement('div');
                        const isFront = row === getFrontEnemyRow(state.columns[col]);
                        card.className = `enemy-card${isFront ? ' is-front' : ''}`;
                        card.innerHTML = `
                            <div>
                                <div class="enemy-name">${enemy.name}</div>
                            </div>
                            <div class="enemy-hp-bar">
                                <div class="enemy-hp-fill" style="width:${(enemy.hp / enemy.maxHp) * 100}%"></div>
                                <div class="hp-bar-text">${enemy.hp} / ${enemy.maxHp}</div>
                            </div>
                            <div class="enemy-action${isFront ? '' : ' is-idle'}">
                                <span>行動</span>
                                <div class="enemy-action-bar">
                                    <div class="enemy-action-fill" style="width:${Math.min(100, enemy.action * 100)}%"></div>
                                </div>
                            </div>
                        `;
                        cell.appendChild(card);
                        if (state.lastHit && state.lastHit.col === col && state.lastHit.row === row && now - state.lastHit.time < 600) {
                            cell.classList.add('is-hit');
                        }
                    }
                    enemyGrid.appendChild(cell);
                }
            }
        }

        function renderLane() {
            skillLane.innerHTML = '';

            const withChain = state.lane.map((block, i) => {
                let count = 1;
                let l = i - 1;
                while (l >= 0 && state.lane[l].type === block.type) { count++; l--; }
                let r = i + 1;
                while (r < state.lane.length && state.lane[r].type === block.type) { count++; r++; }
                return { ...block, chain: count };
            });

            withChain.forEach((block, index) => {
                const div = document.createElement('div');
                div.className = `skill-block type-${block.type} flex-shrink-0`;
                div.innerHTML = `<span class="text-[8px] opacity-60">${block.desc}</span><span class="text-xl">${block.name}</span>`;
                if (block.id === state.lastSpawnId) {
                    div.classList.add('is-spawned');
                }
                if (state.lastChainIds.includes(block.id)) {
                    div.classList.add('is-chain');
                }

                if (block.chain > 1) {
                    const badge = document.createElement('div');
                    badge.className = 'chain-badge font-bold';
                    badge.innerText = block.chain;
                    div.appendChild(badge);
                }

                div.onclick = () => executeChain(index);
                skillLane.appendChild(div);
            });
        }

        function render() {
            renderEnemies();
            renderLane();
            updateUI();
        }

        function updateUI() {
            const remaining = countEnemies();
            enemyCountText.innerText = `${remaining} / ${enemyRows * enemyCols}`;
            playerHpText.innerText = `${state.player.hp} / ${state.player.maxHp}`;
            playerHpBar.style.width = `${(state.player.hp / state.player.maxHp) * 100}%`;
            const now = performance.now();
            const recent = state.lastAction && now - state.lastAction.time < 700;
            playerHpBar.classList.toggle('is-heal', recent && state.lastAction.type === 'heal');
            playerHpBar.classList.toggle('is-shield', recent && state.lastAction.type === 'shield');
            playerHpBar.classList.toggle('is-damage', recent && state.lastAction.type === 'damage');
            document.querySelectorAll('.attack-btn').forEach((button) => {
                const col = Number(button.dataset.col);
                button.classList.toggle('is-active', col === state.selectedColumn);
            });
        }

        function shiftColumn(colIndex) {
            const column = state.columns[colIndex];
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) continue;
                let above = row - 1;
                while (above >= 0 && !column[above]) {
                    above -= 1;
                }
                if (above >= 0) {
                    column[row] = column[above];
                    column[above] = null;
                }
            }
        }

        function getFrontEnemyRow(column) {
            for (let row = enemyRows - 1; row >= 0; row--) {
                if (column[row]) return row;
            }
            return null;
        }

        function attackColumn(colIndex, damage) {
            if (state.isGameOver) return;
            const column = state.columns[colIndex];
            const targetRow = getFrontEnemyRow(column);
            if (targetRow === null) {
                addLog(`列${colIndex + 1}に敵がいません。`);
                return;
            }
            const enemy = column[targetRow];
            enemy.hp = Math.max(0, enemy.hp - damage);
            state.lastHit = { col: colIndex, row: targetRow, time: performance.now() };
            state.lastAction = { type: 'attack', time: performance.now() };
            popText(`-${damage}`, 'text-red-400', 50, 30);
            addLog(`列${colIndex + 1}の前列に攻撃！ ${damage}ダメージ`);
            if (enemy.hp === 0) {
                addLog(`${enemy.name}を撃破！`);
                column[targetRow] = null;
                shiftColumn(colIndex);
            }
            if (countEnemies() === 0) {
                state.isGameOver = true;
                addLog('VICTORY!');
            }
            render();
        }

        function spawnBlock() {
            if (state.lane.length >= 10) return;
            const proto = state.types[Math.floor(Math.random() * state.types.length)];
            const block = { ...proto, id: Math.random() };
            state.lane.push(block);
            state.lastSpawnId = block.id;
            render();
        }

        function executeChain(index) {
            const type = state.lane[index].type;
            let indices = [index];

            let l = index - 1;
            while (l >= 0 && state.lane[l].type === type) { indices.push(l); l--; }
            let r = index + 1;
            while (r < state.lane.length && state.lane[r].type === type) { indices.push(r); r++; }

            const chainSize = indices.length;
            const multiplier = [0, 1, 2.4, 5.5, 9.5, 14][Math.min(chainSize, 5)];
            const baseVal = state.lane[index].val;
            const chainIds = indices.map((i) => state.lane[i].id);

            indices.sort((a, b) => b - a).forEach((i) => state.lane.splice(i, 1));
            state.lastChainIds = chainIds;
            skillLane.classList.remove('is-flash');
            void skillLane.offsetWidth;
            skillLane.classList.add('is-flash');

            if (type === 'red') {
                const damage = Math.floor(baseVal * multiplier);
                attackColumn(state.selectedColumn, damage);
            } else if (type === 'blue') {
                const shield = Math.floor(baseVal * multiplier);
                state.player.shield += shield;
                state.lastAction = { type: 'shield', time: performance.now() };
                popText(`+${shield} SHIELD`, 'text-blue-300', 50, 30);
                addLog(`${chainSize}チェイン：防御(+${shield})`);
            } else if (type === 'green') {
                const heal = Math.floor(baseVal * multiplier);
                state.player.hp = Math.min(state.player.maxHp, state.player.hp + heal);
                state.lastAction = { type: 'heal', time: performance.now() };
                popText(`+${heal} HEAL`, 'text-green-300', 50, 30);
                addLog(`${chainSize}チェイン：回復(+${heal})`);
            }

            render();
        }

        function enemyAction(enemy) {
            if (state.isGameOver) return;
            const damage = 7 + Math.floor(enemy.maxHp / 50);
            let remaining = damage;
            if (state.player.shield > 0) {
                const absorbed = Math.min(state.player.shield, remaining);
                state.player.shield -= absorbed;
                remaining -= absorbed;
            }
            if (remaining > 0) {
                state.player.hp = Math.max(0, state.player.hp - remaining);
            }
            state.lastAction = { type: 'damage', time: performance.now() };
            addLog(`${enemy.name}の攻撃！ ${damage}ダメージ`);
            if (state.player.hp === 0) {
                state.isGameOver = true;
                addLog('DEFEAT...');
            }
            render();
        }

        function updateEnemyActions(delta) {
            const actionSpeed = 3200;
            state.columns.forEach((column) => {
                const frontRow = getFrontEnemyRow(column);
                column.forEach((enemy, row) => {
                    if (!enemy) return;
                    if (row !== frontRow) return;
                    enemy.action = Math.min(1, enemy.action + delta / actionSpeed);
                    if (enemy.action >= 1) {
                        enemy.action = 0;
                        enemyAction(enemy);
                    }
                });
            });
        }

        function gameLoop(time) {
            if (state.isGameOver) return;
            if (state.isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            if (!state.lastFrameTime) state.lastFrameTime = time;
            const delta = time - state.lastFrameTime;
            state.lastFrameTime = time;

            if (time - state.lastSpawn > state.spawnInterval) {
                spawnBlock();
                state.lastSpawn = time;
            }

            updateEnemyActions(delta);
            requestAnimationFrame(gameLoop);
        }

        function setPaused(nextPaused, time) {
            state.isPaused = nextPaused;
            pauseBtn.classList.toggle('is-paused', state.isPaused);
            pauseBtn.setAttribute('aria-pressed', state.isPaused ? 'true' : 'false');
            pauseBtn.textContent = state.isPaused ? '▶' : '⏸';
            document.body.classList.toggle('is-paused', state.isPaused);
            pauseOverlay.setAttribute('aria-hidden', state.isPaused ? 'false' : 'true');
            if (typeof time === 'number') {
                state.lastFrameTime = time;
                state.lastSpawn = time;
            }
        }

        pauseBtn.addEventListener('click', () => {
            if (state.isGameOver) return;
            setPaused(!state.isPaused, performance.now());
        });

        pauseOverlay.addEventListener('click', () => {
            if (state.isGameOver || !state.isPaused) return;
            setPaused(false, performance.now());
        });

        document.querySelectorAll('.attack-btn').forEach((button) => {
            button.addEventListener('click', () => {
                state.selectedColumn = Number(button.dataset.col);
                updateUI();
            });
        });

        initEnemies();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
